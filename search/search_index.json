{
    "docs": [
        {
            "location": "/",
            "text": "Tutoriais do Zend Framework\n\n    \n\n\n    \n\n        \n\n            \nTutoriais sobre MVC\n\n        \n\n\n        \n\n            \n\n                Os seguintes tutoriais ir\u00e3o orientar voc\u00ea atrav\u00e9s da cria\u00e7\u00e3o da sua primeira\n                aplica\u00e7\u00e3o zend-mvc, testando-a, e adicionando recursos a ela. O\n                tutorial \"Aprofundado\" mergulha em alguns detalhes mais avan\u00e7ados de como\n                o MVC funciona, juntamente com estrat\u00e9gias para desenvolver modelos e alcan\u00e7ar\n                separa\u00e7\u00e3o de conceitos.\n            \n\n\n            \n\n                \nIniciando com o Zend Framework\n\n                \nRealizando Testes Unit\u00e1rios em uma Aplica\u00e7\u00e3o zend-mvc\n\n                \nAdicionando zend-navigation ao M\u00f3dulo Album\n\n                \nAdicionando zend-paginator ao M\u00f3dulo Album\n\n                \nTutorial Aprofundado\n\n                \nConfigura\u00e7\u00e3o Avan\u00e7ada\n\n                \nInternacionaliza\u00e7\u00e3o\n\n            \n\n        \n\n    \n\n\n    \n\n        \n\n            \nTutoriais de Componentes\n\n        \n\n\n        \n\n            \nOs seguintes tutoriais s\u00e3o focados em componentes espec\u00edficos.\n\n\n            \n\n                \nConfigurando um Adapter de Bancos de Dados\n\n                \nUsando o EventManager\n\n            \n\n        \n\n    \n\n\n    \n\n        \n\n            \nMigrando para a Vers\u00e3o 3\n\n        \n\n\n        \n\n            \n\n                \nVis\u00e3o Geral\n\n                \nComponentes\n\n                \nAplica\u00e7\u00f5es",
            "title": "Home"
        },
        {
            "location": "/getting-started/overview/",
            "text": "Come\u00e7ando com Aplica\u00e7\u00f5es MVC do Zend Framework\n\n\nEste tutorial destina-se a dar uma introdu\u00e7\u00e3o ao uso do Zend Framework criando uma aplica\u00e7\u00e3o simples com banco de dados usando o paradigma Model-View-Controller. No final voc\u00ea ter\u00e1 uma aplica\u00e7\u00e3o ZF funcionando e voc\u00ea poder\u00e1 ent\u00e3o dar uma olhada no c\u00f3digo para descobrir mais sobre como tudo funciona e se encaixa.\n\n\nAlgumas premissas\n\n\nEste tutorial assume que voc\u00ea est\u00e1 executando ao menos o PHP 5.6 com o servidor\nweb Apache e MySQL, acess\u00edvel atrav\u00e9s da extens\u00e3o PDO. Sua instala\u00e7\u00e3o do Apache\ndeve ter a extens\u00e3o \nmod_rewrite\n instalada e configurada.\n\n\nVoc\u00ea tamb\u00e9m deve garantir que o Apache esteja configurado para suportar arquivos \n.htaccess\n.\nIsso geralmente \u00e9 feito alterando a configura\u00e7\u00e3o:\n\n\nAllowOverride None\n\n\n\npara\n\n\nAllowOverride FileInfo\n\n\n\nno seu arquivo \nhttpd.conf\n. Verifique na documenta\u00e7\u00e3o da sua distribui\u00e7\u00e3o para\ndetalhes exatos. Voc\u00ea n\u00e3o poder\u00e1 navegar para nenhuma outra p\u00e1gina al\u00e9m da p\u00e1gina\ninicial neste tutorial se voc\u00ea n\u00e3o configurou o uso do \nmod_rewrite\n e\n\n.htaccess\n corretamente.\n\n\n\n\nCome\u00e7ando mais r\u00e1pido\n\n\nPor outro lado, voc\u00ea tamb\u00e9m pode usar qualquer uma das seguintes op\u00e7\u00f5es:\n\n\n\n\nO servidor web interno do PHP. Execute \nphp -S 0.0.0.0:8080 -t public\n  public/index.php\n na raiz de sua aplica\u00e7\u00e3o para iniciar um servidor web escutando\n  na porta 8080.\n\n\nUse o \nVagrantfile\n enviado, executando \nvagrant up\n a partir da\n  raiz da aplica\u00e7\u00e3o. Isso liga a porta 8080 da m\u00e1quina host \u00e0 inst\u00e2ncia do\n  servidor Apache rodando na imagem do Vagrant.\n\n\nUse a integra\u00e7\u00e3o com o \ndocker-compose\n\n  enviada, executando \ndocker-compose up -d --build\n a partir da\n  raiz da aplica\u00e7\u00e3o. Isso liga a porta 8080 da m\u00e1quina host \u00e0 inst\u00e2ncia do\n  servidor Apache rodando no container.\n\n\n\n\n\n\nA aplica\u00e7\u00e3o do tutorial\n\n\nA aplica\u00e7\u00e3o que iremos construir \u00e9 um sistema de invent\u00e1rio simples para\nexibir os \u00e1lbuns que possu\u00edmos. A p\u00e1gina principal listar\u00e1 nossa cole\u00e7\u00e3o e nos permitir\u00e1\nadicionar, editar e deletar CDs. N\u00f3s vamos precisar de quatro p\u00e1ginas em nosso website:\n\n\n\n\n\n\n\n\nP\u00e1gina\n\n\nDescri\u00e7\u00e3o\n\n\n\n\n\n\n\n\n\n\nLista de \u00e1lbuns\n\n\nEsta p\u00e1gina exibir\u00e1 a lista de \u00e1lbuns e fornecer\u00e1 links para edit\u00e1-los e exclu\u00ed-los. Al\u00e9m disso, um link para permitir a adi\u00e7\u00e3o de novos \u00e1lbuns ser\u00e1 fornecido.\n\n\n\n\n\n\nAdicionar novo \u00e1lbum\n\n\nEsta p\u00e1gina fornecer\u00e1 um formul\u00e1rio para adicionar um novo \u00e1lbum.\n\n\n\n\n\n\nEditar \u00e1lbum\n\n\nEsta p\u00e1gina fornecer\u00e1 um formul\u00e1rio para editar um \u00e1lbum.\n\n\n\n\n\n\nExcluir \u00e1lbum\n\n\nEsta p\u00e1gina ir\u00e1 confirmar que queremos excluir um \u00e1lbum e ent\u00e3o ir\u00e1 exclu\u00ed-lo.\n\n\n\n\n\n\n\n\nTamb\u00e9m precisaremos armazenar nossos dados em um banco de dados. N\u00f3s s\u00f3 iremos precisar de uma tabela\ncom estes campos:\n\n\n\n\n\n\n\n\nNome do campo\n\n\nTipo\n\n\nNulo?\n\n\nNotas\n\n\n\n\n\n\n\n\n\n\nid\n\n\ninteger\n\n\nN\u00e3o\n\n\nPrimary key, auto-increment\n\n\n\n\n\n\nartist\n\n\nvarchar(100)\n\n\nN\u00e3o\n\n\n\n\n\n\n\n\ntitle\n\n\nvarchar(100)\n\n\nN\u00e3o",
            "title": "Vis\u00e3o Geral"
        },
        {
            "location": "/getting-started/overview/#comecando-com-aplicacoes-mvc-do-zend-framework",
            "text": "Este tutorial destina-se a dar uma introdu\u00e7\u00e3o ao uso do Zend Framework criando uma aplica\u00e7\u00e3o simples com banco de dados usando o paradigma Model-View-Controller. No final voc\u00ea ter\u00e1 uma aplica\u00e7\u00e3o ZF funcionando e voc\u00ea poder\u00e1 ent\u00e3o dar uma olhada no c\u00f3digo para descobrir mais sobre como tudo funciona e se encaixa.",
            "title": "Come\u00e7ando com Aplica\u00e7\u00f5es MVC do Zend Framework"
        },
        {
            "location": "/getting-started/overview/#algumas-premissas",
            "text": "Este tutorial assume que voc\u00ea est\u00e1 executando ao menos o PHP 5.6 com o servidor\nweb Apache e MySQL, acess\u00edvel atrav\u00e9s da extens\u00e3o PDO. Sua instala\u00e7\u00e3o do Apache\ndeve ter a extens\u00e3o  mod_rewrite  instalada e configurada.  Voc\u00ea tamb\u00e9m deve garantir que o Apache esteja configurado para suportar arquivos  .htaccess .\nIsso geralmente \u00e9 feito alterando a configura\u00e7\u00e3o:  AllowOverride None  para  AllowOverride FileInfo  no seu arquivo  httpd.conf . Verifique na documenta\u00e7\u00e3o da sua distribui\u00e7\u00e3o para\ndetalhes exatos. Voc\u00ea n\u00e3o poder\u00e1 navegar para nenhuma outra p\u00e1gina al\u00e9m da p\u00e1gina\ninicial neste tutorial se voc\u00ea n\u00e3o configurou o uso do  mod_rewrite  e .htaccess  corretamente.",
            "title": "Algumas premissas"
        },
        {
            "location": "/getting-started/overview/#comecando-mais-rapido",
            "text": "Por outro lado, voc\u00ea tamb\u00e9m pode usar qualquer uma das seguintes op\u00e7\u00f5es:   O servidor web interno do PHP. Execute  php -S 0.0.0.0:8080 -t public\n  public/index.php  na raiz de sua aplica\u00e7\u00e3o para iniciar um servidor web escutando\n  na porta 8080.  Use o  Vagrantfile  enviado, executando  vagrant up  a partir da\n  raiz da aplica\u00e7\u00e3o. Isso liga a porta 8080 da m\u00e1quina host \u00e0 inst\u00e2ncia do\n  servidor Apache rodando na imagem do Vagrant.  Use a integra\u00e7\u00e3o com o  docker-compose \n  enviada, executando  docker-compose up -d --build  a partir da\n  raiz da aplica\u00e7\u00e3o. Isso liga a porta 8080 da m\u00e1quina host \u00e0 inst\u00e2ncia do\n  servidor Apache rodando no container.",
            "title": "Come\u00e7ando mais r\u00e1pido"
        },
        {
            "location": "/getting-started/overview/#a-aplicacao-do-tutorial",
            "text": "A aplica\u00e7\u00e3o que iremos construir \u00e9 um sistema de invent\u00e1rio simples para\nexibir os \u00e1lbuns que possu\u00edmos. A p\u00e1gina principal listar\u00e1 nossa cole\u00e7\u00e3o e nos permitir\u00e1\nadicionar, editar e deletar CDs. N\u00f3s vamos precisar de quatro p\u00e1ginas em nosso website:     P\u00e1gina  Descri\u00e7\u00e3o      Lista de \u00e1lbuns  Esta p\u00e1gina exibir\u00e1 a lista de \u00e1lbuns e fornecer\u00e1 links para edit\u00e1-los e exclu\u00ed-los. Al\u00e9m disso, um link para permitir a adi\u00e7\u00e3o de novos \u00e1lbuns ser\u00e1 fornecido.    Adicionar novo \u00e1lbum  Esta p\u00e1gina fornecer\u00e1 um formul\u00e1rio para adicionar um novo \u00e1lbum.    Editar \u00e1lbum  Esta p\u00e1gina fornecer\u00e1 um formul\u00e1rio para editar um \u00e1lbum.    Excluir \u00e1lbum  Esta p\u00e1gina ir\u00e1 confirmar que queremos excluir um \u00e1lbum e ent\u00e3o ir\u00e1 exclu\u00ed-lo.     Tamb\u00e9m precisaremos armazenar nossos dados em um banco de dados. N\u00f3s s\u00f3 iremos precisar de uma tabela\ncom estes campos:     Nome do campo  Tipo  Nulo?  Notas      id  integer  N\u00e3o  Primary key, auto-increment    artist  varchar(100)  N\u00e3o     title  varchar(100)  N\u00e3o",
            "title": "A aplica\u00e7\u00e3o do tutorial"
        },
        {
            "location": "/getting-started/skeleton-application/",
            "text": "Come\u00e7ando: Uma aplica\u00e7\u00e3o esqueleto\n\n\nPara construir a nossa aplica\u00e7\u00e3o come\u00e7aremos com a\n\nZendSkeletonApplication\n\ndispon\u00edvel no \ngithub\n. Use o \nComposer\n\npara criar um novo projeto do zero:\n\n\n$ composer create-project -s dev zendframework/skeleton-application caminho/para/instalar\n\n\n\nIsso ir\u00e1 instalar um conjunto initial de depend\u00eancias, incluindo:\n\n\n\n\nzend-component-installer, que ajuda a automatizar a inje\u00e7\u00e3o de configura\u00e7\u00e3o de\n  componentes na sua aplica\u00e7\u00e3o.\n\n\nzend-mvc, o kernel para aplica\u00e7\u00f5es MVC.\n\n\n\n\nO padr\u00e3o \u00e9 fornecer a quantidade m\u00ednima de depend\u00eancias necess\u00e1rias para executar uma\naplica\u00e7\u00e3o zend-mvc. Entretanto, voc\u00ea pode ter necessidades adicionais que voc\u00ea conhece desde\no in\u00edcio, e, assim sendo, o esqueleto tamb\u00e9m vem com um plugin instalador que\nir\u00e1 fazer a voc\u00ea algumas perguntas.\n\n\nPrimeiro, ele ir\u00e1 perguntar:\n\n\n    Do you want a minimal install (no optional packages)? Y/n\n\n\n\n\n\nPerguntas e valores padr\u00e3o\n\n\nTodas as perguntas feitas pelo instalador fornecem a lista de op\u00e7\u00f5es dispon\u00edveis,\ne ir\u00e3o especificar a op\u00e7\u00e3o padr\u00e3o por meio de uma letra mai\u00fascula. Os valores padr\u00e3o s\u00e3o\nusados se o usu\u00e1rio pressionar \"Enter\" sem informar um valor. No exemplo anterior, \"Y\"\n\u00e9 o padr\u00e3o.\n\n\n\n\nSe voc\u00ea responder \"Y\", ou pressionar \"Enter\" sem nenhuma sele\u00e7\u00e3o, o instalador n\u00e3o\nfar\u00e1 mais perguntas e ir\u00e1 terminar\u00e1 de instalar a sua aplica\u00e7\u00e3o. Se voc\u00ea\nresponder \"n\", ele continuar\u00e1 com as perguntas:\n\n\n    Would you like to install the developer toolbar? y/N\n\n\n\nA \nbarra de ferramentas do desenvolvedor\n\nfornece uma barra de ferramentas no navegador com informa\u00e7\u00f5es de tempo e profiling, e pode ser\n\u00fatil ao debugar uma aplica\u00e7\u00e3o. Para os fins do tutorial, entretanto,\nn\u00e3o iremos us\u00e1-la; tecle \"Enter\" ou \"n\" seguido de \"Enter\".\n\n\n    Would you like to install caching support? y/N\n\n\n\nN\u00f3s n\u00e3o vamos demonstrar o armazenamento em cache neste tutorial, ent\u00e3o tecle \"Enter\" ou\n\"n\" seguido de \"Enter\".\n\n\n    Would you like to install database support (installs zend-db)? y/N\n\n\n\nN\u00f3s \niremos\n usar zend-db extensivamente neste tutorial, ent\u00e3o tecle \"y\" seguido de\n\"Enter\". Voc\u00ea deve ver o seguinte texto aparecer:\n\n\n    Will install zendframework/zend-db (^2.8.1)\n    When prompted to install as a module, select application.config.php or modules.config.php\n\n\n\nA pr\u00f3xima pergunta \u00e9:\n\n\n    Would you like to install forms support (installs zend-form)? y/N\n\n\n\nEste tutorial tamb\u00e9m usa zend-form, ent\u00e3o vamos selecionar novamente \"y\" para instal\u00e1-lo;\nao fazer isso ser\u00e1 emitida uma mensagem parecida com aquela emitida para o zend-db.\n\n\nNeste ponto, podemos responder \"n\" para os seguintes recursos restantes:\n\n\n    Would you like to install JSON de/serialization support? y/N\n    Would you like to install logging support? y/N\n    Would you like to install MVC-based console support? (We recommend migrating to zf-console, symfony/console, or Aura.CLI) y/N\n    Would you like to install i18n support? y/N\n    Would you like to install the official MVC plugins, including PRG support, identity, and flash messages? y/N\n    Would you like to use the PSR-7 middleware dispatcher? y/N\n    Would you like to install sessions support? y/N\n    Would you like to install MVC testing support? y/N\n    Would you like to install the zend-di integration for zend-servicemanager? y/N\n\n\n\nEm um determinado ponto, voc\u00ea ver\u00e1 o seguinte texto:\n\n\nUpdating root package\n    Running an update to install optional packages\n\n...\n\nUpdating application configuration...\n\n  Please select which config file you wish to inject 'Zend\\Db' into:\n  [0] Do not inject\n  [1] config/modules.config.php\n  Make your selection (default is 0):\n\n\n\nQueremos habilitar as v\u00e1rias sele\u00e7\u00f5es que fizemos na aplica\u00e7\u00e3o. Assim sendo,\niremos escolher \n1\n, o que ent\u00e3o nos dar\u00e1 o seguinte aviso:\n\n\n  Remember this option for other packages of the same type? (y/N)\n\n\n\nEm nosso caso, podemos seguramente dizer \"y\", o que significa que n\u00e3o seremos mais\nsolicitados a escolher pacotes adicionais. (O \u00fanico pacote no conjunto padr\u00e3o de\nperguntas que voc\u00ea pode n\u00e3o querer habilitar por padr\u00e3o \u00e9 \nZend\\Test\n.)\n\n\nUma vez que a instala\u00e7\u00e3o esteja conclu\u00edda, o instalador do esqueleto ir\u00e1 se remover, e a\nnova aplica\u00e7\u00e3o est\u00e1 pronta para come\u00e7ar!\n\n\n\n\nBaixando o esqueleto\n\n\nOutra forma de instalar a ZendSkeletonApplication \u00e9 usar o github para\nbaixar um arquivo comprimido. Acesse\nhttps://github.com/zendframework/ZendSkeletonApplication, clique no bot\u00e3o \"Clone\nor download\", e selecione \"Download ZIP\". Isso ir\u00e1 baixar um arquivo com um\nnome como \nZendSkeletonApplication-master.zip\n ou algo parecido.\n\n\nDescompacte este arquivo no diret\u00f3rio onde voc\u00ea mant\u00e9m todos os seus vhosts e renomeie\no diret\u00f3rio resultante para \ntutorial-zf\n.\n\n\nA ZendSkeletonApplication est\u00e1 configurada para usar o \nComposer\n\npara resolver suas depend\u00eancias. Execute o seguinte de dentro da sua nova\npasta tutorial-zf para instal\u00e1-las:\n\n\n$ composer self-update\n$ composer install\n\n\n\nIsso demora um pouco. Voc\u00ea deve ver uma sa\u00edda como a seguinte:\n\n\nInstalling dependencies from lock file\n- Installing zendframework/zend-component-installer (0.2.0)\n  \n...\n\nGenerating autoload files\n\n\n\nNeste ponto, voc\u00ea ser\u00e1 solicitado a responder algumas perguntas como mencionado acima.\n\n\nPor outro lado, se voc\u00ea n\u00e3o tem o Composer instalado, mas \ntem\n o\nVagrant ou o docker-compose dispon\u00edvel, voc\u00ea pode executar o Composer atrav\u00e9s deles:\n\n\n# Para o Vagrant:\n$ vagrant up\n$ vagrant ssh -c 'composer install'\n# Para o docker-compose:\n$ docker-compose build\n$ docker-compose run zf composer install\n\n\n\nTempos limite\n\n\nSe voc\u00ea ver esta mensagem:\n\n\n[RuntimeException]      \n  The process timed out.\n\n\n\nent\u00e3o sua conex\u00e3o estava muito lenta para baixar o pacote inteiro a tempo, e\no composer expirou. Para evitar isso, ao inv\u00e9s de executar:\n\n\n$ composer install\n\n\n\nexecute isso:\n\n\n$ COMPOSER_PROCESS_TIMEOUT=5000 composer install\n\n\n\nUsu\u00e1rios do Windows usando o WAMP\n\n\nPara usu\u00e1rios do Windows com o WAMP:\n\n\n\n\nInstale o \ncomposer para o Windows\n.\n   Verifique se o composer est\u00e1 instalado corretamente executando:\n\n\n\n\n$ composer\n\n\n\n\n\nInstale o \nGitHub Desktop\n para Windows.\n     Verifique se o git est\u00e1 instalado corretamente executando:\n\n\n\n\n$ git\n\n\n\n\n\nAgora instale o esqueleto usando:\n\n\n\n\n$ composer create-project -s dev zendframework/skeleton-application caminho/para/instalar\n\n\n\n\n\nAgora podemos avan\u00e7ar para a configura\u00e7\u00e3o do servidor web.\n\n\nServidores Web\n\n\nNeste tutorial, passaremos por quatro formas diferentes de configurar seu servidor\nweb:\n\n\n\n\nAtrav\u00e9s do servidor web interno do PHP.\n\n\nAtrav\u00e9s do Vagrant.\n\n\nAtrav\u00e9s do docker-compose.\n\n\nUsando o Apache.\n\n\n\n\nUsando o Servidor Web Interno do PHP\n\n\nVoc\u00ea pode usar o servidor web interno do PHP ao desenvolver sua aplica\u00e7\u00e3o. Para fazer\nisso, inicie o servidor a partir do diret\u00f3rio raiz do projeto:\n\n\n$ php -S 0.0.0.0:8080 -t public public/index.php\n\n\n\nIsso tornar\u00e1 o site dispon\u00edvel na porta 8080 de todas as interfaces de rede,\nusando \npublic/index.php\n para lidar com o roteamento. Isso significa que o site estar\u00e1 acess\u00edvel\natrav\u00e9s de \nhttp://localhost:8080\n ou \nhttp://<seu-IP-local>:8080\n.\n\n\nSe voc\u00ea fez isso direito, voc\u00ea deve ver o seguinte:\n\n\n\n\nPara testar que o seu roteamento est\u00e1 funcionando, acesse \nhttp://localhost:8080/1234\n,\ne voc\u00ea deve ver a seguinte p\u00e1gina 404:\n\n\n\n\n\n\nApenas para desenvolvimento\n\n\nO servidor web interno do PHP deve ser usado \napenas para desenvolvimento\n.\n\n\n\n\nUsando o Vagrant\n\n\nO \nVagrant\n fornece uma maneira de descrever e provisionar\nm\u00e1quinas virtuais, e \u00e9 uma maneira comum de fornecer um ambiente de desenvolvimento\ncoerente e consistente para as equipes de desenvolvimento. A aplica\u00e7\u00e3o esqueleto fornece\num \nVagrantfile\n baseado no Ubuntu 14.04, e usa o PPA \nondrej/php\n para fornecer o\nPHP 7.0. Inicie o Vagrant usando:\n\n\n$ vagrant up\n\n\n\nUma vez que ele tenha sido constru\u00eddo e esteja rodando, voc\u00ea poder\u00e1 tamb\u00e9m executar o composer a partir da\nm\u00e1quina virtual. Como exemplo, o seguinte comando ir\u00e1 instalar as depend\u00eancias:\n\n\n$ vagrant ssh -c 'composer install'\n\n\n\nenquanto este ir\u00e1 atualiz\u00e1-las:\n\n\n$ vagrant ssh -c 'composer update'\n\n\n\nA imagem usa o Apache 2.4, e mapeia a porta 8080 do host para a porta 80 na m\u00e1quina\nvirtual.\n\n\nUsando o docker-compose\n\n\nOs containers do \nDocker\n empacotam uma por\u00e7\u00e3o de software e tudo o que \u00e9 necess\u00e1rio para execut\u00e1-lo,\ngarantindo uma opera\u00e7\u00e3o consistente independentemente do ambiente do host; o Docker \u00e9 uma\nalternativa \u00e0s m\u00e1quinas virtuais, pois \u00e9 executado como uma camada em cima do ambiente do\nhost.\n\n\nO \ndocker-compose\n \u00e9 uma ferramenta para automatizar\na configura\u00e7\u00e3o de containers e compor as depend\u00eancias entre eles, como\narmazenamento de volume, rede, etc.\n\n\nA aplica\u00e7\u00e3o esqueleto vem com um \nDockerfile\n e configura\u00e7\u00e3o para o\ndocker-compose; recomendamos usar o docker-compose, pois ele fornece uma base\npara mapear containers adicionais que voc\u00ea possa precisar como parte de sua aplica\u00e7\u00e3o,\nincluindo um servidor de banco de dados, servidores de cache, entre outros. Para construir a imagem e iniciar os\ncontainers, use:\n\n\n$ docker-compose up -d --build\n\n\n\nDepois da primeira constru\u00e7\u00e3o, voc\u00ea pode reduzir o comando para:\n\n\n$ docker-compose up -d\n\n\n\nUma vez constru\u00edda a imagem, voc\u00ea tamb\u00e9m pode executar comandos no container. A configura\u00e7\u00e3o\ndo docker-compose inicialmente define apenas um container, com o nome de ambiente\n\"zf\"; use-o para executar comandos, como atualizar depend\u00eancias via composer:\n\n\n$ docker-compose run zf composer update\n\n\n\nA configura\u00e7\u00e3o inclui o PHP 7.0 e o Apache 2.4, e mapeia a porta 8080 do\nhost para a porta 80 do container.\n\n\nUsando o Servidor Web Apache\n\n\nN\u00e3o abordaremos a instala\u00e7\u00e3o do \nApache\n, e assumiremos\nque voc\u00ea j\u00e1 o tenha instalado. Recomendamos instalar o Apache 2.4, e iremos cobrir\napenas a configura\u00e7\u00e3o para esta vers\u00e3o.\n\n\nAgora voc\u00ea precisa criar um virtual host no Apache para a aplica\u00e7\u00e3o e editar seu\narquivo de hosts para que \nhttp://tutorial-zf.localhost\n sirva o \nindex.php\n do\ndiret\u00f3rio \ntutorial-zf/public/\n.\n\n\nA configura\u00e7\u00e3o do virtual host geralmente \u00e9 feita no \nhttpd.conf\n ou em\n\nextra/httpd-vhosts.conf\n. Se voc\u00ea est\u00e1 usando \nhttpd-vhosts.conf\n, verifique se\neste arquivo est\u00e1 inclu\u00eddo no seu arquivo principal \nhttpd.conf\n. Algumas distribui\u00e7\u00f5es Linux\n(ex: Ubuntu) empacotam o Apache de forma que os arquivos de configura\u00e7\u00e3o sejam armazenados em\n\n/etc/apache2\n e criam um arquivo para cada virtual host dentro da pasta\n\n/etc/apache2/sites-enabled\n. Neste caso, voc\u00ea colocaria o bloco de virtual\nhost abaixo no arquivo \n/etc/apache2/sites-enabled/tutorial-zf\n.\n\n\nCertifique-se de que \nNameVirtualHost\n est\u00e1 definido como \n*:80\n ou algo parecido, e ent\u00e3o\ndefina um virtual host como esse:\n\n\n<VirtualHost *:80>\n    ServerName tutorial-zf.localhost\n    DocumentRoot /caminho/para/tutorial-zf/public\n    SetEnv APPLICATION_ENV \"development\"\n    <Directory /caminho/para/tutorial-zf/public>\n        DirectoryIndex index.php\n        AllowOverride All\n        Require all granted\n    </Directory>\n</VirtualHost>\n\n\n\nCertifique-se de atualizar seu arquivo \n/etc/hosts\n ou\n\nc:\\windows\\system32\\drivers\\etc\\hosts\n para que \ntutorial-zf.localhost\n seja\nmapeado para \n127.0.0.1\n. O site pode ent\u00e3o ser acessado usando\n\nhttp://tutorial-zf.localhost\n.\n\n\n127.0.0.1 tutorial-zf.localhost localhost\n\n\n\nReinicie o Apache.\n\n\nSe voc\u00ea fez isso de forma correta, voc\u00ea ter\u00e1 os mesmos resultados mostrados com\n\no servidor web interno do PHP\n.\n\n\nPara testar que o seu arquivo \n.htaccess\n est\u00e1 funcionando, acesse\n\nhttp://tutorial-zf.localhost/1234\n, e voc\u00ea deve ver a p\u00e1gina 404 como mencionado\nanteriormente. Se voc\u00ea ver um erro 404 padr\u00e3o do Apache, ent\u00e3o voc\u00ea precisa corrigir o\nseu \n.htaccess\n antes de continuar.\n\n\nSe voc\u00ea estiver usando o IIS com o m\u00f3dulo URL Rewrite, importe o seguinte:\n\n\nRewriteCond %{REQUEST_FILENAME} !-f\nRewriteRule ^ index.php [NC,L]\n\n\n\nVoc\u00ea agora possui uma aplica\u00e7\u00e3o esqueleto funcionando e podemos come\u00e7ar a adicionar os detalhes da nossa aplica\u00e7\u00e3o.\n\n\nRelat\u00f3rio de erros\n\n\nOpcionalmente, \nao usar o Apache\n, voc\u00ea pode usar a configura\u00e7\u00e3o \nAPPLICATION_ENV\n no\nseu \nVirtualHost\n para permitir que o PHP envie todos os seus erros para o navegador. Isso pode ser\n\u00fatil durante o desenvolvimento da sua aplica\u00e7\u00e3o.\n\n\nEdite o arquivo \ntutorial-zf/public/index.php\n e altere-o para o seguinte:\n\n\n<?php\n\nuse Zend\\Mvc\\Application;\n\n/**\n * Exibir todos os erros quando o valor de APPLICATION_ENV \u00e9 development.\n */\nif ($_SERVER['APPLICATION_ENV'] === 'development') {\n    error_reporting(E_ALL);\n    ini_set(\"display_errors\", 1);\n}\n\n/**\n * Isso torna nossa vida mais f\u00e1cil ao lidar com caminhos. Tudo \u00e9 relativo\n * \u00e0 raiz da aplica\u00e7\u00e3o agora.\n */\nchdir(dirname(__DIR__));\n\n// Recusar requisi\u00e7\u00f5es de arquivos est\u00e1ticos ao servidor web interno do PHP\nif (php_sapi_name() === 'cli-server') {\n    $path = realpath(__DIR__ . parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH));\n    if (__FILE__ !== $path && is_file($path)) {\n        return false;\n    }\n    unset($path);\n}\n\n// Autoloading do Composer\ninclude __DIR__ . '/../vendor/autoload.php';\n\nif (! class_exists(Application::class)) {\n    throw new RuntimeException(\n        \"N\u00e3o \u00e9 poss\u00edvel carregar a aplica\u00e7\u00e3o.\\n\"\n        . \"- Digite `composer install` se voc\u00ea estiver desenvolvendo localmente.\\n\"\n        . \"- Digite `vagrant ssh -c 'composer install'` se voc\u00ea estiver usando o Vagrant.\\n\"\n        . \"- Digite `docker-compose run zf composer install` se voc\u00ea estiver usando o Docker.\\n\"\n    );\n}\n\n// Carrega a configura\u00e7\u00e3o\n$appConfig = require __DIR__ . '/../config/application.config.php';\nif (file_exists(__DIR__ . '/../config/development.config.php')) {\n    $appConfig = ArrayUtils::merge($appConfig, require __DIR__ . '/../config/development.config.php');\n}\n\n// Executa a aplica\u00e7\u00e3o!\nApplication::init($appConfig)->run();\n\n\n\nModo de desenvolvimento\n\n\nAntes de come\u00e7armos, vamos habilitar o \nmodo de desenvolvimento\n para a aplica\u00e7\u00e3o.\nA aplica\u00e7\u00e3o esqueleto fornece dois arquivos que nos permitem especificar configura\u00e7\u00f5es\ngerais de desenvolvimento que queremos usar em todos os lugares; estas podem incluir habilitar\nm\u00f3dulos para depura\u00e7\u00e3o, ou habilitar a exibi\u00e7\u00e3o de erros em nossos view scripts. Estes\narquivos est\u00e3o localizados em:\n\n\n\n\nconfig/development.config.php.dist\n\n\nconfig/autoload/development.local.php.dist\n\n\n\n\nQuando habilitamos o modo de desenvolvimento, estes arquivos s\u00e3o copiados para:\n\n\n\n\nconfig/development.config.php\n\n\nconfig/autoload/development.local.php\n\n\n\n\nIsso permite que eles sejam incorporados na nossa aplica\u00e7\u00e3o. Quando desabilitamos o modo de\ndesenvolvimento, estes dois arquivos que foram criados s\u00e3o ent\u00e3o removidos, deixando apenas as\nvers\u00f5es \n.dist\n. (O reposit\u00f3rio tamb\u00e9m cont\u00e9m regras para ignorar as c\u00f3pias.)\n\n\nAgora vamos habilitar o modo de desenvolvimento:\n\n\n$ composer development-enable\n\n\n\n\n\nNunca habilite o modo de desenvolvimento em produ\u00e7\u00e3o\n\n\nVoc\u00ea nunca deve habilitar o modo de desenvolvimento em produ\u00e7\u00e3o, pois a raz\u00e3o\nt\u00edpica para habilit\u00e1-lo \u00e9 para habilitar a depura\u00e7\u00e3o! Conforme observado, os artefatos gerados\nao habilitar o modo de desenvolvimento n\u00e3o podem ser enviados para o seu reposit\u00f3rio, ent\u00e3o\ndesde que voc\u00ea n\u00e3o execute o comando em produ\u00e7\u00e3o, voc\u00ea deve estar seguro.\n\n\nVoc\u00ea pode testar o status do modo de desenvolvimento usando:\n\n\n$ composer development-status\n\n\n\nE voc\u00ea pode desabilit\u00e1-lo usando:\n\n\n$ composer development-disable",
            "title": "A Aplica\u00e7\u00e3o Esqueleto"
        },
        {
            "location": "/getting-started/skeleton-application/#comecando-uma-aplicacao-esqueleto",
            "text": "Para construir a nossa aplica\u00e7\u00e3o come\u00e7aremos com a ZendSkeletonApplication \ndispon\u00edvel no  github . Use o  Composer \npara criar um novo projeto do zero:  $ composer create-project -s dev zendframework/skeleton-application caminho/para/instalar  Isso ir\u00e1 instalar um conjunto initial de depend\u00eancias, incluindo:   zend-component-installer, que ajuda a automatizar a inje\u00e7\u00e3o de configura\u00e7\u00e3o de\n  componentes na sua aplica\u00e7\u00e3o.  zend-mvc, o kernel para aplica\u00e7\u00f5es MVC.   O padr\u00e3o \u00e9 fornecer a quantidade m\u00ednima de depend\u00eancias necess\u00e1rias para executar uma\naplica\u00e7\u00e3o zend-mvc. Entretanto, voc\u00ea pode ter necessidades adicionais que voc\u00ea conhece desde\no in\u00edcio, e, assim sendo, o esqueleto tamb\u00e9m vem com um plugin instalador que\nir\u00e1 fazer a voc\u00ea algumas perguntas.  Primeiro, ele ir\u00e1 perguntar:      Do you want a minimal install (no optional packages)? Y/n",
            "title": "Come\u00e7ando: Uma aplica\u00e7\u00e3o esqueleto"
        },
        {
            "location": "/getting-started/skeleton-application/#perguntas-e-valores-padrao",
            "text": "Todas as perguntas feitas pelo instalador fornecem a lista de op\u00e7\u00f5es dispon\u00edveis,\ne ir\u00e3o especificar a op\u00e7\u00e3o padr\u00e3o por meio de uma letra mai\u00fascula. Os valores padr\u00e3o s\u00e3o\nusados se o usu\u00e1rio pressionar \"Enter\" sem informar um valor. No exemplo anterior, \"Y\"\n\u00e9 o padr\u00e3o.   Se voc\u00ea responder \"Y\", ou pressionar \"Enter\" sem nenhuma sele\u00e7\u00e3o, o instalador n\u00e3o\nfar\u00e1 mais perguntas e ir\u00e1 terminar\u00e1 de instalar a sua aplica\u00e7\u00e3o. Se voc\u00ea\nresponder \"n\", ele continuar\u00e1 com as perguntas:      Would you like to install the developer toolbar? y/N  A  barra de ferramentas do desenvolvedor \nfornece uma barra de ferramentas no navegador com informa\u00e7\u00f5es de tempo e profiling, e pode ser\n\u00fatil ao debugar uma aplica\u00e7\u00e3o. Para os fins do tutorial, entretanto,\nn\u00e3o iremos us\u00e1-la; tecle \"Enter\" ou \"n\" seguido de \"Enter\".      Would you like to install caching support? y/N  N\u00f3s n\u00e3o vamos demonstrar o armazenamento em cache neste tutorial, ent\u00e3o tecle \"Enter\" ou\n\"n\" seguido de \"Enter\".      Would you like to install database support (installs zend-db)? y/N  N\u00f3s  iremos  usar zend-db extensivamente neste tutorial, ent\u00e3o tecle \"y\" seguido de\n\"Enter\". Voc\u00ea deve ver o seguinte texto aparecer:      Will install zendframework/zend-db (^2.8.1)\n    When prompted to install as a module, select application.config.php or modules.config.php  A pr\u00f3xima pergunta \u00e9:      Would you like to install forms support (installs zend-form)? y/N  Este tutorial tamb\u00e9m usa zend-form, ent\u00e3o vamos selecionar novamente \"y\" para instal\u00e1-lo;\nao fazer isso ser\u00e1 emitida uma mensagem parecida com aquela emitida para o zend-db.  Neste ponto, podemos responder \"n\" para os seguintes recursos restantes:      Would you like to install JSON de/serialization support? y/N\n    Would you like to install logging support? y/N\n    Would you like to install MVC-based console support? (We recommend migrating to zf-console, symfony/console, or Aura.CLI) y/N\n    Would you like to install i18n support? y/N\n    Would you like to install the official MVC plugins, including PRG support, identity, and flash messages? y/N\n    Would you like to use the PSR-7 middleware dispatcher? y/N\n    Would you like to install sessions support? y/N\n    Would you like to install MVC testing support? y/N\n    Would you like to install the zend-di integration for zend-servicemanager? y/N  Em um determinado ponto, voc\u00ea ver\u00e1 o seguinte texto:  Updating root package\n    Running an update to install optional packages\n\n...\n\nUpdating application configuration...\n\n  Please select which config file you wish to inject 'Zend\\Db' into:\n  [0] Do not inject\n  [1] config/modules.config.php\n  Make your selection (default is 0):  Queremos habilitar as v\u00e1rias sele\u00e7\u00f5es que fizemos na aplica\u00e7\u00e3o. Assim sendo,\niremos escolher  1 , o que ent\u00e3o nos dar\u00e1 o seguinte aviso:    Remember this option for other packages of the same type? (y/N)  Em nosso caso, podemos seguramente dizer \"y\", o que significa que n\u00e3o seremos mais\nsolicitados a escolher pacotes adicionais. (O \u00fanico pacote no conjunto padr\u00e3o de\nperguntas que voc\u00ea pode n\u00e3o querer habilitar por padr\u00e3o \u00e9  Zend\\Test .)  Uma vez que a instala\u00e7\u00e3o esteja conclu\u00edda, o instalador do esqueleto ir\u00e1 se remover, e a\nnova aplica\u00e7\u00e3o est\u00e1 pronta para come\u00e7ar!",
            "title": "Perguntas e valores padr\u00e3o"
        },
        {
            "location": "/getting-started/skeleton-application/#baixando-o-esqueleto",
            "text": "Outra forma de instalar a ZendSkeletonApplication \u00e9 usar o github para\nbaixar um arquivo comprimido. Acesse\nhttps://github.com/zendframework/ZendSkeletonApplication, clique no bot\u00e3o \"Clone\nor download\", e selecione \"Download ZIP\". Isso ir\u00e1 baixar um arquivo com um\nnome como  ZendSkeletonApplication-master.zip  ou algo parecido.  Descompacte este arquivo no diret\u00f3rio onde voc\u00ea mant\u00e9m todos os seus vhosts e renomeie\no diret\u00f3rio resultante para  tutorial-zf .  A ZendSkeletonApplication est\u00e1 configurada para usar o  Composer \npara resolver suas depend\u00eancias. Execute o seguinte de dentro da sua nova\npasta tutorial-zf para instal\u00e1-las:  $ composer self-update\n$ composer install  Isso demora um pouco. Voc\u00ea deve ver uma sa\u00edda como a seguinte:  Installing dependencies from lock file\n- Installing zendframework/zend-component-installer (0.2.0)\n  \n...\n\nGenerating autoload files  Neste ponto, voc\u00ea ser\u00e1 solicitado a responder algumas perguntas como mencionado acima.  Por outro lado, se voc\u00ea n\u00e3o tem o Composer instalado, mas  tem  o\nVagrant ou o docker-compose dispon\u00edvel, voc\u00ea pode executar o Composer atrav\u00e9s deles:  # Para o Vagrant:\n$ vagrant up\n$ vagrant ssh -c 'composer install'\n# Para o docker-compose:\n$ docker-compose build\n$ docker-compose run zf composer install",
            "title": "Baixando o esqueleto"
        },
        {
            "location": "/getting-started/skeleton-application/#tempos-limite",
            "text": "Se voc\u00ea ver esta mensagem:  [RuntimeException]      \n  The process timed out.  ent\u00e3o sua conex\u00e3o estava muito lenta para baixar o pacote inteiro a tempo, e\no composer expirou. Para evitar isso, ao inv\u00e9s de executar:  $ composer install  execute isso:  $ COMPOSER_PROCESS_TIMEOUT=5000 composer install",
            "title": "Tempos limite"
        },
        {
            "location": "/getting-started/skeleton-application/#usuarios-do-windows-usando-o-wamp",
            "text": "Para usu\u00e1rios do Windows com o WAMP:   Instale o  composer para o Windows .\n   Verifique se o composer est\u00e1 instalado corretamente executando:   $ composer   Instale o  GitHub Desktop  para Windows.\n     Verifique se o git est\u00e1 instalado corretamente executando:   $ git   Agora instale o esqueleto usando:   $ composer create-project -s dev zendframework/skeleton-application caminho/para/instalar   Agora podemos avan\u00e7ar para a configura\u00e7\u00e3o do servidor web.",
            "title": "Usu\u00e1rios do Windows usando o WAMP"
        },
        {
            "location": "/getting-started/skeleton-application/#servidores-web",
            "text": "Neste tutorial, passaremos por quatro formas diferentes de configurar seu servidor\nweb:   Atrav\u00e9s do servidor web interno do PHP.  Atrav\u00e9s do Vagrant.  Atrav\u00e9s do docker-compose.  Usando o Apache.",
            "title": "Servidores Web"
        },
        {
            "location": "/getting-started/skeleton-application/#usando-o-servidor-web-interno-do-php",
            "text": "Voc\u00ea pode usar o servidor web interno do PHP ao desenvolver sua aplica\u00e7\u00e3o. Para fazer\nisso, inicie o servidor a partir do diret\u00f3rio raiz do projeto:  $ php -S 0.0.0.0:8080 -t public public/index.php  Isso tornar\u00e1 o site dispon\u00edvel na porta 8080 de todas as interfaces de rede,\nusando  public/index.php  para lidar com o roteamento. Isso significa que o site estar\u00e1 acess\u00edvel\natrav\u00e9s de  http://localhost:8080  ou  http://<seu-IP-local>:8080 .  Se voc\u00ea fez isso direito, voc\u00ea deve ver o seguinte:   Para testar que o seu roteamento est\u00e1 funcionando, acesse  http://localhost:8080/1234 ,\ne voc\u00ea deve ver a seguinte p\u00e1gina 404:",
            "title": "Usando o Servidor Web Interno do PHP"
        },
        {
            "location": "/getting-started/skeleton-application/#apenas-para-desenvolvimento",
            "text": "O servidor web interno do PHP deve ser usado  apenas para desenvolvimento .",
            "title": "Apenas para desenvolvimento"
        },
        {
            "location": "/getting-started/skeleton-application/#usando-o-vagrant",
            "text": "O  Vagrant  fornece uma maneira de descrever e provisionar\nm\u00e1quinas virtuais, e \u00e9 uma maneira comum de fornecer um ambiente de desenvolvimento\ncoerente e consistente para as equipes de desenvolvimento. A aplica\u00e7\u00e3o esqueleto fornece\num  Vagrantfile  baseado no Ubuntu 14.04, e usa o PPA  ondrej/php  para fornecer o\nPHP 7.0. Inicie o Vagrant usando:  $ vagrant up  Uma vez que ele tenha sido constru\u00eddo e esteja rodando, voc\u00ea poder\u00e1 tamb\u00e9m executar o composer a partir da\nm\u00e1quina virtual. Como exemplo, o seguinte comando ir\u00e1 instalar as depend\u00eancias:  $ vagrant ssh -c 'composer install'  enquanto este ir\u00e1 atualiz\u00e1-las:  $ vagrant ssh -c 'composer update'  A imagem usa o Apache 2.4, e mapeia a porta 8080 do host para a porta 80 na m\u00e1quina\nvirtual.",
            "title": "Usando o Vagrant"
        },
        {
            "location": "/getting-started/skeleton-application/#usando-o-docker-compose",
            "text": "Os containers do  Docker  empacotam uma por\u00e7\u00e3o de software e tudo o que \u00e9 necess\u00e1rio para execut\u00e1-lo,\ngarantindo uma opera\u00e7\u00e3o consistente independentemente do ambiente do host; o Docker \u00e9 uma\nalternativa \u00e0s m\u00e1quinas virtuais, pois \u00e9 executado como uma camada em cima do ambiente do\nhost.  O  docker-compose  \u00e9 uma ferramenta para automatizar\na configura\u00e7\u00e3o de containers e compor as depend\u00eancias entre eles, como\narmazenamento de volume, rede, etc.  A aplica\u00e7\u00e3o esqueleto vem com um  Dockerfile  e configura\u00e7\u00e3o para o\ndocker-compose; recomendamos usar o docker-compose, pois ele fornece uma base\npara mapear containers adicionais que voc\u00ea possa precisar como parte de sua aplica\u00e7\u00e3o,\nincluindo um servidor de banco de dados, servidores de cache, entre outros. Para construir a imagem e iniciar os\ncontainers, use:  $ docker-compose up -d --build  Depois da primeira constru\u00e7\u00e3o, voc\u00ea pode reduzir o comando para:  $ docker-compose up -d  Uma vez constru\u00edda a imagem, voc\u00ea tamb\u00e9m pode executar comandos no container. A configura\u00e7\u00e3o\ndo docker-compose inicialmente define apenas um container, com o nome de ambiente\n\"zf\"; use-o para executar comandos, como atualizar depend\u00eancias via composer:  $ docker-compose run zf composer update  A configura\u00e7\u00e3o inclui o PHP 7.0 e o Apache 2.4, e mapeia a porta 8080 do\nhost para a porta 80 do container.",
            "title": "Usando o docker-compose"
        },
        {
            "location": "/getting-started/skeleton-application/#usando-o-servidor-web-apache",
            "text": "N\u00e3o abordaremos a instala\u00e7\u00e3o do  Apache , e assumiremos\nque voc\u00ea j\u00e1 o tenha instalado. Recomendamos instalar o Apache 2.4, e iremos cobrir\napenas a configura\u00e7\u00e3o para esta vers\u00e3o.  Agora voc\u00ea precisa criar um virtual host no Apache para a aplica\u00e7\u00e3o e editar seu\narquivo de hosts para que  http://tutorial-zf.localhost  sirva o  index.php  do\ndiret\u00f3rio  tutorial-zf/public/ .  A configura\u00e7\u00e3o do virtual host geralmente \u00e9 feita no  httpd.conf  ou em extra/httpd-vhosts.conf . Se voc\u00ea est\u00e1 usando  httpd-vhosts.conf , verifique se\neste arquivo est\u00e1 inclu\u00eddo no seu arquivo principal  httpd.conf . Algumas distribui\u00e7\u00f5es Linux\n(ex: Ubuntu) empacotam o Apache de forma que os arquivos de configura\u00e7\u00e3o sejam armazenados em /etc/apache2  e criam um arquivo para cada virtual host dentro da pasta /etc/apache2/sites-enabled . Neste caso, voc\u00ea colocaria o bloco de virtual\nhost abaixo no arquivo  /etc/apache2/sites-enabled/tutorial-zf .  Certifique-se de que  NameVirtualHost  est\u00e1 definido como  *:80  ou algo parecido, e ent\u00e3o\ndefina um virtual host como esse:  <VirtualHost *:80>\n    ServerName tutorial-zf.localhost\n    DocumentRoot /caminho/para/tutorial-zf/public\n    SetEnv APPLICATION_ENV \"development\"\n    <Directory /caminho/para/tutorial-zf/public>\n        DirectoryIndex index.php\n        AllowOverride All\n        Require all granted\n    </Directory>\n</VirtualHost>  Certifique-se de atualizar seu arquivo  /etc/hosts  ou c:\\windows\\system32\\drivers\\etc\\hosts  para que  tutorial-zf.localhost  seja\nmapeado para  127.0.0.1 . O site pode ent\u00e3o ser acessado usando http://tutorial-zf.localhost .  127.0.0.1 tutorial-zf.localhost localhost  Reinicie o Apache.  Se voc\u00ea fez isso de forma correta, voc\u00ea ter\u00e1 os mesmos resultados mostrados com o servidor web interno do PHP .  Para testar que o seu arquivo  .htaccess  est\u00e1 funcionando, acesse http://tutorial-zf.localhost/1234 , e voc\u00ea deve ver a p\u00e1gina 404 como mencionado\nanteriormente. Se voc\u00ea ver um erro 404 padr\u00e3o do Apache, ent\u00e3o voc\u00ea precisa corrigir o\nseu  .htaccess  antes de continuar.  Se voc\u00ea estiver usando o IIS com o m\u00f3dulo URL Rewrite, importe o seguinte:  RewriteCond %{REQUEST_FILENAME} !-f\nRewriteRule ^ index.php [NC,L]  Voc\u00ea agora possui uma aplica\u00e7\u00e3o esqueleto funcionando e podemos come\u00e7ar a adicionar os detalhes da nossa aplica\u00e7\u00e3o.",
            "title": "Usando o Servidor Web Apache"
        },
        {
            "location": "/getting-started/skeleton-application/#relatorio-de-erros",
            "text": "Opcionalmente,  ao usar o Apache , voc\u00ea pode usar a configura\u00e7\u00e3o  APPLICATION_ENV  no\nseu  VirtualHost  para permitir que o PHP envie todos os seus erros para o navegador. Isso pode ser\n\u00fatil durante o desenvolvimento da sua aplica\u00e7\u00e3o.  Edite o arquivo  tutorial-zf/public/index.php  e altere-o para o seguinte:  <?php\n\nuse Zend\\Mvc\\Application;\n\n/**\n * Exibir todos os erros quando o valor de APPLICATION_ENV \u00e9 development.\n */\nif ($_SERVER['APPLICATION_ENV'] === 'development') {\n    error_reporting(E_ALL);\n    ini_set(\"display_errors\", 1);\n}\n\n/**\n * Isso torna nossa vida mais f\u00e1cil ao lidar com caminhos. Tudo \u00e9 relativo\n * \u00e0 raiz da aplica\u00e7\u00e3o agora.\n */\nchdir(dirname(__DIR__));\n\n// Recusar requisi\u00e7\u00f5es de arquivos est\u00e1ticos ao servidor web interno do PHP\nif (php_sapi_name() === 'cli-server') {\n    $path = realpath(__DIR__ . parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH));\n    if (__FILE__ !== $path && is_file($path)) {\n        return false;\n    }\n    unset($path);\n}\n\n// Autoloading do Composer\ninclude __DIR__ . '/../vendor/autoload.php';\n\nif (! class_exists(Application::class)) {\n    throw new RuntimeException(\n        \"N\u00e3o \u00e9 poss\u00edvel carregar a aplica\u00e7\u00e3o.\\n\"\n        . \"- Digite `composer install` se voc\u00ea estiver desenvolvendo localmente.\\n\"\n        . \"- Digite `vagrant ssh -c 'composer install'` se voc\u00ea estiver usando o Vagrant.\\n\"\n        . \"- Digite `docker-compose run zf composer install` se voc\u00ea estiver usando o Docker.\\n\"\n    );\n}\n\n// Carrega a configura\u00e7\u00e3o\n$appConfig = require __DIR__ . '/../config/application.config.php';\nif (file_exists(__DIR__ . '/../config/development.config.php')) {\n    $appConfig = ArrayUtils::merge($appConfig, require __DIR__ . '/../config/development.config.php');\n}\n\n// Executa a aplica\u00e7\u00e3o!\nApplication::init($appConfig)->run();",
            "title": "Relat\u00f3rio de erros"
        },
        {
            "location": "/getting-started/skeleton-application/#modo-de-desenvolvimento",
            "text": "Antes de come\u00e7armos, vamos habilitar o  modo de desenvolvimento  para a aplica\u00e7\u00e3o.\nA aplica\u00e7\u00e3o esqueleto fornece dois arquivos que nos permitem especificar configura\u00e7\u00f5es\ngerais de desenvolvimento que queremos usar em todos os lugares; estas podem incluir habilitar\nm\u00f3dulos para depura\u00e7\u00e3o, ou habilitar a exibi\u00e7\u00e3o de erros em nossos view scripts. Estes\narquivos est\u00e3o localizados em:   config/development.config.php.dist  config/autoload/development.local.php.dist   Quando habilitamos o modo de desenvolvimento, estes arquivos s\u00e3o copiados para:   config/development.config.php  config/autoload/development.local.php   Isso permite que eles sejam incorporados na nossa aplica\u00e7\u00e3o. Quando desabilitamos o modo de\ndesenvolvimento, estes dois arquivos que foram criados s\u00e3o ent\u00e3o removidos, deixando apenas as\nvers\u00f5es  .dist . (O reposit\u00f3rio tamb\u00e9m cont\u00e9m regras para ignorar as c\u00f3pias.)  Agora vamos habilitar o modo de desenvolvimento:  $ composer development-enable",
            "title": "Modo de desenvolvimento"
        },
        {
            "location": "/getting-started/skeleton-application/#nunca-habilite-o-modo-de-desenvolvimento-em-producao",
            "text": "Voc\u00ea nunca deve habilitar o modo de desenvolvimento em produ\u00e7\u00e3o, pois a raz\u00e3o\nt\u00edpica para habilit\u00e1-lo \u00e9 para habilitar a depura\u00e7\u00e3o! Conforme observado, os artefatos gerados\nao habilitar o modo de desenvolvimento n\u00e3o podem ser enviados para o seu reposit\u00f3rio, ent\u00e3o\ndesde que voc\u00ea n\u00e3o execute o comando em produ\u00e7\u00e3o, voc\u00ea deve estar seguro.  Voc\u00ea pode testar o status do modo de desenvolvimento usando:  $ composer development-status  E voc\u00ea pode desabilit\u00e1-lo usando:  $ composer development-disable",
            "title": "Nunca habilite o modo de desenvolvimento em produ\u00e7\u00e3o"
        },
        {
            "location": "/getting-started/modules/",
            "text": "M\u00f3dulos\n\n\nO zend-mvc usa um sistema de m\u00f3dulos para organizar seu c\u00f3digo espec\u00edfico da aplica\u00e7\u00e3o\nprincipal dentro de cada m\u00f3dulo. O m\u00f3dulo \nApplication\n fornecido pelo esqueleto \u00e9 usado\npara fornecer configura\u00e7\u00e3o de bootstrapping, erro e roteamento para toda a\naplica\u00e7\u00e3o. Ele geralmente \u00e9 usado para fornecer controllers a n\u00edvel de aplica\u00e7\u00e3o para\na p\u00e1gina inicial de uma aplica\u00e7\u00e3o, mas n\u00e3o vamos usar o padr\u00e3o\nfornecido neste tutorial, pois queremos que nossa lista de \u00e1lbuns seja a p\u00e1gina inicial,\nque ficar\u00e1 em nosso pr\u00f3prio m\u00f3dulo.\n\n\nVamos colocar todo o nosso c\u00f3digo no m\u00f3dulo \nAlbum\n, que ir\u00e1 conter nossos\ncontrollers, models, forms e views, juntamente com a configura\u00e7\u00e3o. Tamb\u00e9m ajustaremos\no m\u00f3dulo \nApplication\n conforme necess\u00e1rio.\n\n\nVamos come\u00e7ar com os diret\u00f3rios necess\u00e1rios.\n\n\nConfigurando o m\u00f3dulo Album\n\n\nComece criando um diret\u00f3rio chamado \nAlbum\n em \nmodule\n com os seguintes\nsubdiret\u00f3rios para manter os arquivos do m\u00f3dulo:\n\n\ntutorial-zf/\n    /module\n        /Album\n            /config\n            /src\n                /Controller\n                /Form\n                /Model\n            /view\n                /album\n                    /album\n\n\n\nO m\u00f3dulo \nAlbum\n possui diret\u00f3rios separados para os diferentes tipos de arquivos que\nteremos. Os arquivos PHP que cont\u00eam classes dentro do namespace \nAlbum\n ficam\nno diret\u00f3rio \nsrc/\n. O diret\u00f3rio \nview\n tamb\u00e9m tem uma sub-pasta chamada \nalbum\n\npara os view scripts do nosso m\u00f3dulo.\n\n\nPara carregar e configurar um m\u00f3dulo, o Zend Framework fornece um\n\nModuleManager\n. Este ir\u00e1 procurar por uma classe \nModule\n no namespace do m\u00f3dulo\nespecificado (ou seja, \nAlbum\n); no caso do nosso novo m\u00f3dulo, isso significa a classe\n\nAlbum\\Module\n, que ser\u00e1 encontrada em \nmodule/Album/src/Module.php\n.\n\n\nVamos criar esse arquivo agora, com o seguinte conte\u00fado:\n\n\nnamespace Album;\n\nuse Zend\\ModuleManager\\Feature\\ConfigProviderInterface;\n\nclass Module implements ConfigProviderInterface\n{\n    public function getConfig()\n    {\n        return include __DIR__ . '/../config/module.config.php';\n    }\n}\n\n\n\nO \nModuleManager\n chamar\u00e1 \ngetConfig()\n automaticamente para n\u00f3s.\n\n\nAutoloading\n\n\nEmbora o Zend Framework forne\u00e7a recursos de autoloading atrav\u00e9s do seu\ncomponente \nzend-loader\n,\nrecomendamos o uso dos recursos de autoloading do Composer. Assim sendo, precisamos informar\nao Composer nosso novo namespace, e onde seus arquivos ficam.\n\n\nAbra o \ncomposer.json\n na raiz do seu projeto, e procure a se\u00e7\u00e3o \nautoload\n;\nela deve parecer o seguinte por padr\u00e3o:\n\n\n\"autoload\": {\n    \"psr-4\": {\n        \"Application\\\\\": \"module/Application/src/\"\n    }\n},\n\n\n\nAgora vamos adicionar o nosso novo m\u00f3dulo \u00e0 lista, ent\u00e3o agora a se\u00e7\u00e3o \u00e9 lida assim:\n\n\n\"autoload\": {\n    \"psr-4\": {\n        \"Application\\\\\": \"module/Application/src/\",\n        \"Album\\\\\": \"module/Album/src/\"\n    }\n},\n\n\n\nDepois de fazer essa altera\u00e7\u00e3o, execute o seguinte comando para garantir que o Composer atualize suas\nregras de autoloading:\n\n\n$ composer dump-autoload\n\n\n\nConfigura\u00e7\u00e3o\n\n\nTendo registrado o autoloader, vamos dar uma olhada no m\u00e9todo \ngetConfig()\n\nem \nAlbum\\Module\n. Este m\u00e9todo carrega o arquivo \nconfig/module.config.php\n\nno diret\u00f3rio raiz do m\u00f3dulo.\n\n\nCrie um arquivo chamado \nmodule.config.php\n em\n\ntutorial-zf/module/Album/config/\n:\n\n\nnamespace Album;\n\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    'controllers' => [\n        'factories' => [\n            Controller\\AlbumController::class => InvokableFactory::class,\n        ],\n    ],\n    'view_manager' => [\n        'template_path_stack' => [\n            'album' => __DIR__ . '/../view',\n        ],\n    ],\n];\n\n\n\nA informa\u00e7\u00e3o de configura\u00e7\u00e3o \u00e9 passada para os componentes relevantes pelo\n\nServiceManager\n. Precisamos de duas se\u00e7\u00f5es iniciais: \ncontrollers\n e\n\nview_manager\n. A se\u00e7\u00e3o \ncontrollers\n fornece uma lista de todos os controllers\nfornecidos pelo m\u00f3dulo. N\u00f3s precisaremos de um controller, \nAlbumController\n; iremos\nreferenci\u00e1-lo pelo seu nome de classe totalmente qualificado, e usaremos a \nInvokableFactory\n\ndo zend-servicemanager para criar inst\u00e2ncias dele.\n\n\nNa se\u00e7\u00e3o \nview_manager\n, adicionamos nosso diret\u00f3rio de view \u00e0\nconfigura\u00e7\u00e3o \nTemplatePathStack\n. Isso permitir\u00e1 que ele encontre os view scripts\ndo m\u00f3dulo \nAlbum\n que est\u00e3o armazenados em nosso diret\u00f3rio \nview/\n.\n\n\nInformando a aplica\u00e7\u00e3o sobre nosso novo m\u00f3dulo\n\n\nAgora precisamos dizer ao \nModuleManager\n que este novo m\u00f3dulo existe. Isso \u00e9\nfeito no arquivo \nconfig/modules.config.php\n da aplica\u00e7\u00e3o, que \u00e9 fornecido\npela aplica\u00e7\u00e3o esqueleto. Atualize este arquivo para que o array que ele retorna\ntamb\u00e9m contenha o m\u00f3dulo \nAlbum\n, ent\u00e3o o arquivo agora parece com isso:\n\n\n(As altera\u00e7\u00f5es necess\u00e1rias est\u00e3o destacadas usando coment\u00e1rios; os coment\u00e1rios originais do\narquivo foram omitidos por brevidade.)\n\n\nreturn [\n    'Zend\\Form',\n    'Zend\\Db',\n    'Zend\\Router',\n    'Zend\\Validator',\n    'Application',\n    'Album',          // <-- Adicione esta linha\n];\n\n\n\nComo voc\u00ea pode ver, adicionamos nosso m\u00f3dulo \nAlbum\n na lista de m\u00f3dulos ap\u00f3s\no m\u00f3dulo \nApplication\n.\n\n\nAgora deixamos o m\u00f3dulo configurado, pronto para colocar nosso c\u00f3digo personalizado nele.",
            "title": "M\u00f3dulos"
        },
        {
            "location": "/getting-started/modules/#modulos",
            "text": "O zend-mvc usa um sistema de m\u00f3dulos para organizar seu c\u00f3digo espec\u00edfico da aplica\u00e7\u00e3o\nprincipal dentro de cada m\u00f3dulo. O m\u00f3dulo  Application  fornecido pelo esqueleto \u00e9 usado\npara fornecer configura\u00e7\u00e3o de bootstrapping, erro e roteamento para toda a\naplica\u00e7\u00e3o. Ele geralmente \u00e9 usado para fornecer controllers a n\u00edvel de aplica\u00e7\u00e3o para\na p\u00e1gina inicial de uma aplica\u00e7\u00e3o, mas n\u00e3o vamos usar o padr\u00e3o\nfornecido neste tutorial, pois queremos que nossa lista de \u00e1lbuns seja a p\u00e1gina inicial,\nque ficar\u00e1 em nosso pr\u00f3prio m\u00f3dulo.  Vamos colocar todo o nosso c\u00f3digo no m\u00f3dulo  Album , que ir\u00e1 conter nossos\ncontrollers, models, forms e views, juntamente com a configura\u00e7\u00e3o. Tamb\u00e9m ajustaremos\no m\u00f3dulo  Application  conforme necess\u00e1rio.  Vamos come\u00e7ar com os diret\u00f3rios necess\u00e1rios.",
            "title": "M\u00f3dulos"
        },
        {
            "location": "/getting-started/modules/#configurando-o-modulo-album",
            "text": "Comece criando um diret\u00f3rio chamado  Album  em  module  com os seguintes\nsubdiret\u00f3rios para manter os arquivos do m\u00f3dulo:  tutorial-zf/\n    /module\n        /Album\n            /config\n            /src\n                /Controller\n                /Form\n                /Model\n            /view\n                /album\n                    /album  O m\u00f3dulo  Album  possui diret\u00f3rios separados para os diferentes tipos de arquivos que\nteremos. Os arquivos PHP que cont\u00eam classes dentro do namespace  Album  ficam\nno diret\u00f3rio  src/ . O diret\u00f3rio  view  tamb\u00e9m tem uma sub-pasta chamada  album \npara os view scripts do nosso m\u00f3dulo.  Para carregar e configurar um m\u00f3dulo, o Zend Framework fornece um ModuleManager . Este ir\u00e1 procurar por uma classe  Module  no namespace do m\u00f3dulo\nespecificado (ou seja,  Album ); no caso do nosso novo m\u00f3dulo, isso significa a classe Album\\Module , que ser\u00e1 encontrada em  module/Album/src/Module.php .  Vamos criar esse arquivo agora, com o seguinte conte\u00fado:  namespace Album;\n\nuse Zend\\ModuleManager\\Feature\\ConfigProviderInterface;\n\nclass Module implements ConfigProviderInterface\n{\n    public function getConfig()\n    {\n        return include __DIR__ . '/../config/module.config.php';\n    }\n}  O  ModuleManager  chamar\u00e1  getConfig()  automaticamente para n\u00f3s.",
            "title": "Configurando o m\u00f3dulo Album"
        },
        {
            "location": "/getting-started/modules/#autoloading",
            "text": "Embora o Zend Framework forne\u00e7a recursos de autoloading atrav\u00e9s do seu\ncomponente  zend-loader ,\nrecomendamos o uso dos recursos de autoloading do Composer. Assim sendo, precisamos informar\nao Composer nosso novo namespace, e onde seus arquivos ficam.  Abra o  composer.json  na raiz do seu projeto, e procure a se\u00e7\u00e3o  autoload ;\nela deve parecer o seguinte por padr\u00e3o:  \"autoload\": {\n    \"psr-4\": {\n        \"Application\\\\\": \"module/Application/src/\"\n    }\n},  Agora vamos adicionar o nosso novo m\u00f3dulo \u00e0 lista, ent\u00e3o agora a se\u00e7\u00e3o \u00e9 lida assim:  \"autoload\": {\n    \"psr-4\": {\n        \"Application\\\\\": \"module/Application/src/\",\n        \"Album\\\\\": \"module/Album/src/\"\n    }\n},  Depois de fazer essa altera\u00e7\u00e3o, execute o seguinte comando para garantir que o Composer atualize suas\nregras de autoloading:  $ composer dump-autoload",
            "title": "Autoloading"
        },
        {
            "location": "/getting-started/modules/#configuracao",
            "text": "Tendo registrado o autoloader, vamos dar uma olhada no m\u00e9todo  getConfig() \nem  Album\\Module . Este m\u00e9todo carrega o arquivo  config/module.config.php \nno diret\u00f3rio raiz do m\u00f3dulo.  Crie um arquivo chamado  module.config.php  em tutorial-zf/module/Album/config/ :  namespace Album;\n\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    'controllers' => [\n        'factories' => [\n            Controller\\AlbumController::class => InvokableFactory::class,\n        ],\n    ],\n    'view_manager' => [\n        'template_path_stack' => [\n            'album' => __DIR__ . '/../view',\n        ],\n    ],\n];  A informa\u00e7\u00e3o de configura\u00e7\u00e3o \u00e9 passada para os componentes relevantes pelo ServiceManager . Precisamos de duas se\u00e7\u00f5es iniciais:  controllers  e view_manager . A se\u00e7\u00e3o  controllers  fornece uma lista de todos os controllers\nfornecidos pelo m\u00f3dulo. N\u00f3s precisaremos de um controller,  AlbumController ; iremos\nreferenci\u00e1-lo pelo seu nome de classe totalmente qualificado, e usaremos a  InvokableFactory \ndo zend-servicemanager para criar inst\u00e2ncias dele.  Na se\u00e7\u00e3o  view_manager , adicionamos nosso diret\u00f3rio de view \u00e0\nconfigura\u00e7\u00e3o  TemplatePathStack . Isso permitir\u00e1 que ele encontre os view scripts\ndo m\u00f3dulo  Album  que est\u00e3o armazenados em nosso diret\u00f3rio  view/ .",
            "title": "Configura\u00e7\u00e3o"
        },
        {
            "location": "/getting-started/modules/#informando-a-aplicacao-sobre-nosso-novo-modulo",
            "text": "Agora precisamos dizer ao  ModuleManager  que este novo m\u00f3dulo existe. Isso \u00e9\nfeito no arquivo  config/modules.config.php  da aplica\u00e7\u00e3o, que \u00e9 fornecido\npela aplica\u00e7\u00e3o esqueleto. Atualize este arquivo para que o array que ele retorna\ntamb\u00e9m contenha o m\u00f3dulo  Album , ent\u00e3o o arquivo agora parece com isso:  (As altera\u00e7\u00f5es necess\u00e1rias est\u00e3o destacadas usando coment\u00e1rios; os coment\u00e1rios originais do\narquivo foram omitidos por brevidade.)  return [\n    'Zend\\Form',\n    'Zend\\Db',\n    'Zend\\Router',\n    'Zend\\Validator',\n    'Application',\n    'Album',          // <-- Adicione esta linha\n];  Como voc\u00ea pode ver, adicionamos nosso m\u00f3dulo  Album  na lista de m\u00f3dulos ap\u00f3s\no m\u00f3dulo  Application .  Agora deixamos o m\u00f3dulo configurado, pronto para colocar nosso c\u00f3digo personalizado nele.",
            "title": "Informando a aplica\u00e7\u00e3o sobre nosso novo m\u00f3dulo"
        },
        {
            "location": "/getting-started/routing-and-controllers/",
            "text": "Roteamento e Controllers\n\n\nN\u00f3s iremos construir um sistema de invent\u00e1rio bem simples para exibir a nossa cole\u00e7\u00e3o de \u00e1lbuns.\nA p\u00e1gina inicial listar\u00e1 nossa cole\u00e7\u00e3o e nos permitir\u00e1 adicionar, editar e excluir\n\u00e1lbuns. Por isso, as seguintes p\u00e1ginas s\u00e3o necess\u00e1rias:\n\n\n\n\n\n\n\n\nP\u00e1gina\n\n\nDescri\u00e7\u00e3o\n\n\n\n\n\n\n\n\n\n\nHome\n\n\nEsta p\u00e1gina exibir\u00e1 a lista de \u00e1lbuns e fornecer\u00e1 links para edit\u00e1-los e exclu\u00ed-los. Al\u00e9m disso, um link para permitir a adi\u00e7\u00e3o de novos \u00e1lbuns ser\u00e1 fornecido.\n\n\n\n\n\n\nAdicionar novo \u00e1lbum\n\n\nEsta p\u00e1gina fornecer\u00e1 um formul\u00e1rio para adicionar um novo \u00e1lbum.\n\n\n\n\n\n\nEditar \u00e1lbum\n\n\nEsta p\u00e1gina fornecer\u00e1 um formul\u00e1rio para editar um \u00e1lbum.\n\n\n\n\n\n\nExcluir \u00e1lbum\n\n\nEsta p\u00e1gina ir\u00e1 confirmar que queremos excluir um \u00e1lbum e ent\u00e3o ir\u00e1 exclu\u00ed-lo.\n\n\n\n\n\n\n\n\nAntes de configurar nossos arquivos, \u00e9 importante entender como o framework\nespera que as p\u00e1ginas sejam organizadas. Cada p\u00e1gina da aplica\u00e7\u00e3o \u00e9 conhecida como uma\n\naction\n e actions s\u00e3o agrupadas em \ncontrollers\n dentro de \nm\u00f3dulos\n. Assim, voc\u00ea\ngeralmente agruparia actions relacionadas em um controller; por exemplo, um controller\nde not\u00edcia pode ter as actions \natual\n, \narquivadas\n e \nexibir\n.\n\n\nComo temos quatro p\u00e1ginas que se aplicam a \u00e1lbuns, as agruparemos em um \u00fanico\ncontroller \nAlbumController\n dentro do nosso m\u00f3dulo \nAlbum\n como quatro actions. As quatro\nactions ser\u00e3o:\n\n\n\n\n\n\n\n\nP\u00e1gina\n\n\nController\n\n\nAction\n\n\n\n\n\n\n\n\n\n\nHome\n\n\nAlbumController\n\n\nindex\n\n\n\n\n\n\nAdicionar novo \u00e1lbum\n\n\nAlbumController\n\n\nadd\n\n\n\n\n\n\nEditar \u00e1lbum\n\n\nAlbumController\n\n\nedit\n\n\n\n\n\n\nExcluir \u00e1lbum\n\n\nAlbumController\n\n\ndelete\n\n\n\n\n\n\n\n\nO mapeamento de um URL para uma action espec\u00edfica \u00e9 feito usando rotas que s\u00e3o\ndefinidas no arquivo \nmodule.config.php\n do m\u00f3dulo. Iremos adicionar uma rota para nossas\nactions de \u00e1lbum. Este \u00e9 o arquivo de configura\u00e7\u00e3o do m\u00f3dulo atualizado com o novo c\u00f3digo\ndestacado com coment\u00e1rios:\n\n\nnamespace Album;\n\nuse Zend\\Router\\Http\\Segment;\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    'controllers' => [\n        'factories' => [\n            Controller\\AlbumController::class => InvokableFactory::class,\n        ],\n    ],\n\n    // A se\u00e7\u00e3o a seguir \u00e9 nova e deve ser adicionada ao seu arquivo:\n    'router' => [\n        'routes' => [\n            'album' => [\n                'type'    => Segment::class,\n                'options' => [\n                    'route' => '/album[/:action[/:id]]',\n                    'constraints' => [\n                        'action' => '[a-zA-Z][a-zA-Z0-9_-]*',\n                        'id'     => '[0-9]+',\n                    ],\n                    'defaults' => [\n                        'controller' => Controller\\AlbumController::class,\n                        'action'     => 'index',\n                    ],\n                ],\n            ],\n        ],\n    ],\n\n    'view_manager' => [\n        'template_path_stack' => [\n            'album' => __DIR__ . '/../view',\n        ],\n    ],\n];\n\n\n\nO nome da rota \u00e9 'album' e tem um tipo de 'segment'. Rotas de segmento\nnos permitem especificar espa\u00e7os reservados no padr\u00e3o do URL (rota) que ser\u00e3o mapeados\npara par\u00e2metros nomeados na rota casada. Neste caso, a rota \u00e9\n\n/album[/:action[/:id]]\n e ir\u00e1 casar com qualquer URL que comece com \n/album\n.\nO pr\u00f3ximo segmento ser\u00e1 um nome de action opcional e, finalmente, o pr\u00f3ximo\nsegmento ser\u00e1 mapeado para um ID opcional. Os colchetes indicam que um\nsegmento \u00e9 opcional. A se\u00e7\u00e3o constraints nos permite garantir que os\ncaracteres dentro de um segmento s\u00e3o como esperados, ent\u00e3o n\u00f3s temos actions limitadas a\ncome\u00e7ar com uma letra e ent\u00e3o caracteres subseq\u00fcentes sendo apenas alfanum\u00e9ricos,\nsublinhados ou h\u00edfens. Tamb\u00e9m limitamos o ID a apenas d\u00edgitos.\n\n\nEsta rota nos permite ter os seguintes URLs:\n\n\n\n\n\n\n\n\nURL\n\n\nP\u00e1gina\n\n\nAction\n\n\n\n\n\n\n\n\n\n\n/album\n\n\nHome (lista de \u00e1lbuns)\n\n\nindex\n\n\n\n\n\n\n/album/add\n\n\nAdicionar novo \u00e1lbum\n\n\nadd\n\n\n\n\n\n\n/album/edit/2\n\n\nEditar o \u00e1lbum com o ID 2\n\n\nedit\n\n\n\n\n\n\n/album/delete/4\n\n\nExcluir o \u00e1lbum com o ID 4\n\n\ndelete\n\n\n\n\n\n\n\n\nCrie o controller\n\n\nAgora estamos prontos para configurar nosso controller. Para o zend-mvc, o controller\n\u00e9 uma classe que \u00e9 geralmente chamada \n{Nome do Controller}Controller\n; note que\n\n{Nome do Controller}\n deve come\u00e7ar com uma letra mai\u00fascula. Essa classe fica em um arquivo\nchamado \n{Nome do Controller}Controller.php\n dentro do subdiret\u00f3rio \nController\n do\nm\u00f3dulo; no nosso caso \u00e9 \nmodule/Album/src/Controller/\n. Cada action\n\u00e9 um m\u00e9todo p\u00fablico dentro da classe controller que \u00e9 nomeado \n{nome da\naction}Action\n, onde \n{nome da action}\n deve come\u00e7ar com uma letra\nmin\u00fascula.\n\n\n\n\nConven\u00e7\u00f5es n\u00e3o aplicadas estritamente\n\n\nIsto \u00e9 por conven\u00e7\u00e3o. O zend-mvc n\u00e3o oferece muitas restri\u00e7\u00f5es aos\ncontrollers al\u00e9m de que eles devem implementar a interface \nZend\\Stdlib\\Dispatchable\n.\nO framework fornece duas classes abstratas que fazem isso por n\u00f3s:\n\nZend\\Mvc\\Controller\\AbstractActionController\n e\n\nZend\\Mvc\\Controller\\AbstractRestfulController\n. Iremos usar o padr\u00e3o\n\nAbstractActionController\n, mas se voc\u00ea pretende escrever um servi\u00e7o web\nRESTful, \nAbstractRestfulController\n pode ser \u00fatil.\n\n\n\n\nVamos seguir em frente e criar nossa classe controller no arquivo\n\ntutorial-zf/module/Album/src/Controller/AlbumController.php\n:\n\n\nnamespace Album\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass AlbumController extends AbstractActionController\n{\n    public function indexAction()\n    {\n    }\n\n    public function addAction()\n    {\n    }\n\n    public function editAction()\n    {\n    }\n\n    public function deleteAction()\n    {\n    }\n}\n\n\n\nAgora criamos as quatro actions que queremos usar. Elas n\u00e3o ir\u00e3o funcionar ainda\nat\u00e9 que configuremos as views. Os URLs para cada action s\u00e3o:\n\n\n\n\n\n\n\n\nURL\n\n\nM\u00e9todo chamado\n\n\n\n\n\n\n\n\n\n\nhttp://tutorial-zf.localhost/album\n\n\nAlbum\\Controller\\AlbumController::indexAction\n\n\n\n\n\n\nhttp://tutorial-zf.localhost/album/add\n\n\nAlbum\\Controller\\AlbumController::addAction\n\n\n\n\n\n\nhttp://tutorial-zf.localhost/album/edit\n\n\nAlbum\\Controller\\AlbumController::editAction\n\n\n\n\n\n\nhttp://tutorial-zf.localhost/album/delete\n\n\nAlbum\\Controller\\AlbumController::deleteAction\n\n\n\n\n\n\n\n\nAgora temos um router funcionando e as actions est\u00e3o configuradas para cada p\u00e1gina da nossa\naplica\u00e7\u00e3o.\n\n\n\u00c9 hora de construir a camada da view e do model.\n\n\nInicialize os view scripts\n\n\nPara integrar a view em nossa aplica\u00e7\u00e3o, precisamos criar alguns arquivos de view\nscript. Esses arquivos ser\u00e3o executados pela \nDefaultViewStrategy\n e lhes ser\u00e3o\npassadas quaisquer vari\u00e1veis ou view models que sejam retornados do m\u00e9todo action do\ncontroller. Esses view scripts s\u00e3o armazenados no diret\u00f3rio views do nosso m\u00f3dulo dentro de um\ndiret\u00f3rio com o nome do controller. Crie esses quatro arquivos vazios agora:\n\n\n\n\nmodule/Album/view/album/album/index.phtml\n\n\nmodule/Album/view/album/album/add.phtml\n\n\nmodule/Album/view/album/album/edit.phtml\n\n\nmodule/Album/view/album/album/delete.phtml\n\n\n\n\nAgora podemos come\u00e7ar a preencher tudo, come\u00e7ando com nosso banco de dados e models.",
            "title": "Roteamento e Controllers"
        },
        {
            "location": "/getting-started/routing-and-controllers/#roteamento-e-controllers",
            "text": "N\u00f3s iremos construir um sistema de invent\u00e1rio bem simples para exibir a nossa cole\u00e7\u00e3o de \u00e1lbuns.\nA p\u00e1gina inicial listar\u00e1 nossa cole\u00e7\u00e3o e nos permitir\u00e1 adicionar, editar e excluir\n\u00e1lbuns. Por isso, as seguintes p\u00e1ginas s\u00e3o necess\u00e1rias:     P\u00e1gina  Descri\u00e7\u00e3o      Home  Esta p\u00e1gina exibir\u00e1 a lista de \u00e1lbuns e fornecer\u00e1 links para edit\u00e1-los e exclu\u00ed-los. Al\u00e9m disso, um link para permitir a adi\u00e7\u00e3o de novos \u00e1lbuns ser\u00e1 fornecido.    Adicionar novo \u00e1lbum  Esta p\u00e1gina fornecer\u00e1 um formul\u00e1rio para adicionar um novo \u00e1lbum.    Editar \u00e1lbum  Esta p\u00e1gina fornecer\u00e1 um formul\u00e1rio para editar um \u00e1lbum.    Excluir \u00e1lbum  Esta p\u00e1gina ir\u00e1 confirmar que queremos excluir um \u00e1lbum e ent\u00e3o ir\u00e1 exclu\u00ed-lo.     Antes de configurar nossos arquivos, \u00e9 importante entender como o framework\nespera que as p\u00e1ginas sejam organizadas. Cada p\u00e1gina da aplica\u00e7\u00e3o \u00e9 conhecida como uma action  e actions s\u00e3o agrupadas em  controllers  dentro de  m\u00f3dulos . Assim, voc\u00ea\ngeralmente agruparia actions relacionadas em um controller; por exemplo, um controller\nde not\u00edcia pode ter as actions  atual ,  arquivadas  e  exibir .  Como temos quatro p\u00e1ginas que se aplicam a \u00e1lbuns, as agruparemos em um \u00fanico\ncontroller  AlbumController  dentro do nosso m\u00f3dulo  Album  como quatro actions. As quatro\nactions ser\u00e3o:     P\u00e1gina  Controller  Action      Home  AlbumController  index    Adicionar novo \u00e1lbum  AlbumController  add    Editar \u00e1lbum  AlbumController  edit    Excluir \u00e1lbum  AlbumController  delete     O mapeamento de um URL para uma action espec\u00edfica \u00e9 feito usando rotas que s\u00e3o\ndefinidas no arquivo  module.config.php  do m\u00f3dulo. Iremos adicionar uma rota para nossas\nactions de \u00e1lbum. Este \u00e9 o arquivo de configura\u00e7\u00e3o do m\u00f3dulo atualizado com o novo c\u00f3digo\ndestacado com coment\u00e1rios:  namespace Album;\n\nuse Zend\\Router\\Http\\Segment;\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    'controllers' => [\n        'factories' => [\n            Controller\\AlbumController::class => InvokableFactory::class,\n        ],\n    ],\n\n    // A se\u00e7\u00e3o a seguir \u00e9 nova e deve ser adicionada ao seu arquivo:\n    'router' => [\n        'routes' => [\n            'album' => [\n                'type'    => Segment::class,\n                'options' => [\n                    'route' => '/album[/:action[/:id]]',\n                    'constraints' => [\n                        'action' => '[a-zA-Z][a-zA-Z0-9_-]*',\n                        'id'     => '[0-9]+',\n                    ],\n                    'defaults' => [\n                        'controller' => Controller\\AlbumController::class,\n                        'action'     => 'index',\n                    ],\n                ],\n            ],\n        ],\n    ],\n\n    'view_manager' => [\n        'template_path_stack' => [\n            'album' => __DIR__ . '/../view',\n        ],\n    ],\n];  O nome da rota \u00e9 'album' e tem um tipo de 'segment'. Rotas de segmento\nnos permitem especificar espa\u00e7os reservados no padr\u00e3o do URL (rota) que ser\u00e3o mapeados\npara par\u00e2metros nomeados na rota casada. Neste caso, a rota \u00e9 /album[/:action[/:id]]  e ir\u00e1 casar com qualquer URL que comece com  /album .\nO pr\u00f3ximo segmento ser\u00e1 um nome de action opcional e, finalmente, o pr\u00f3ximo\nsegmento ser\u00e1 mapeado para um ID opcional. Os colchetes indicam que um\nsegmento \u00e9 opcional. A se\u00e7\u00e3o constraints nos permite garantir que os\ncaracteres dentro de um segmento s\u00e3o como esperados, ent\u00e3o n\u00f3s temos actions limitadas a\ncome\u00e7ar com uma letra e ent\u00e3o caracteres subseq\u00fcentes sendo apenas alfanum\u00e9ricos,\nsublinhados ou h\u00edfens. Tamb\u00e9m limitamos o ID a apenas d\u00edgitos.  Esta rota nos permite ter os seguintes URLs:     URL  P\u00e1gina  Action      /album  Home (lista de \u00e1lbuns)  index    /album/add  Adicionar novo \u00e1lbum  add    /album/edit/2  Editar o \u00e1lbum com o ID 2  edit    /album/delete/4  Excluir o \u00e1lbum com o ID 4  delete",
            "title": "Roteamento e Controllers"
        },
        {
            "location": "/getting-started/routing-and-controllers/#crie-o-controller",
            "text": "Agora estamos prontos para configurar nosso controller. Para o zend-mvc, o controller\n\u00e9 uma classe que \u00e9 geralmente chamada  {Nome do Controller}Controller ; note que {Nome do Controller}  deve come\u00e7ar com uma letra mai\u00fascula. Essa classe fica em um arquivo\nchamado  {Nome do Controller}Controller.php  dentro do subdiret\u00f3rio  Controller  do\nm\u00f3dulo; no nosso caso \u00e9  module/Album/src/Controller/ . Cada action\n\u00e9 um m\u00e9todo p\u00fablico dentro da classe controller que \u00e9 nomeado  {nome da\naction}Action , onde  {nome da action}  deve come\u00e7ar com uma letra\nmin\u00fascula.",
            "title": "Crie o controller"
        },
        {
            "location": "/getting-started/routing-and-controllers/#convencoes-nao-aplicadas-estritamente",
            "text": "Isto \u00e9 por conven\u00e7\u00e3o. O zend-mvc n\u00e3o oferece muitas restri\u00e7\u00f5es aos\ncontrollers al\u00e9m de que eles devem implementar a interface  Zend\\Stdlib\\Dispatchable .\nO framework fornece duas classes abstratas que fazem isso por n\u00f3s: Zend\\Mvc\\Controller\\AbstractActionController  e Zend\\Mvc\\Controller\\AbstractRestfulController . Iremos usar o padr\u00e3o AbstractActionController , mas se voc\u00ea pretende escrever um servi\u00e7o web\nRESTful,  AbstractRestfulController  pode ser \u00fatil.   Vamos seguir em frente e criar nossa classe controller no arquivo tutorial-zf/module/Album/src/Controller/AlbumController.php :  namespace Album\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass AlbumController extends AbstractActionController\n{\n    public function indexAction()\n    {\n    }\n\n    public function addAction()\n    {\n    }\n\n    public function editAction()\n    {\n    }\n\n    public function deleteAction()\n    {\n    }\n}  Agora criamos as quatro actions que queremos usar. Elas n\u00e3o ir\u00e3o funcionar ainda\nat\u00e9 que configuremos as views. Os URLs para cada action s\u00e3o:     URL  M\u00e9todo chamado      http://tutorial-zf.localhost/album  Album\\Controller\\AlbumController::indexAction    http://tutorial-zf.localhost/album/add  Album\\Controller\\AlbumController::addAction    http://tutorial-zf.localhost/album/edit  Album\\Controller\\AlbumController::editAction    http://tutorial-zf.localhost/album/delete  Album\\Controller\\AlbumController::deleteAction     Agora temos um router funcionando e as actions est\u00e3o configuradas para cada p\u00e1gina da nossa\naplica\u00e7\u00e3o.  \u00c9 hora de construir a camada da view e do model.",
            "title": "Conven\u00e7\u00f5es n\u00e3o aplicadas estritamente"
        },
        {
            "location": "/getting-started/routing-and-controllers/#inicialize-os-view-scripts",
            "text": "Para integrar a view em nossa aplica\u00e7\u00e3o, precisamos criar alguns arquivos de view\nscript. Esses arquivos ser\u00e3o executados pela  DefaultViewStrategy  e lhes ser\u00e3o\npassadas quaisquer vari\u00e1veis ou view models que sejam retornados do m\u00e9todo action do\ncontroller. Esses view scripts s\u00e3o armazenados no diret\u00f3rio views do nosso m\u00f3dulo dentro de um\ndiret\u00f3rio com o nome do controller. Crie esses quatro arquivos vazios agora:   module/Album/view/album/album/index.phtml  module/Album/view/album/album/add.phtml  module/Album/view/album/album/edit.phtml  module/Album/view/album/album/delete.phtml   Agora podemos come\u00e7ar a preencher tudo, come\u00e7ando com nosso banco de dados e models.",
            "title": "Inicialize os view scripts"
        },
        {
            "location": "/getting-started/database-and-models/",
            "text": "Database and models\n\n\nThe database\n\n\nNow that we have the \nAlbum\n module set up with controller action methods and\nview scripts, it is time to look at the model section of our application.\nRemember that the model is the part that deals with the application's core\npurpose (the so-called \u201cbusiness rules\u201d) and, in our case, deals with the\ndatabase. We will make use of zend-db's \nZend\\Db\\TableGateway\\TableGateway\n to\nfind, insert, update, and delete rows from a database table.\n\n\nWe are going to use Sqlite, via PHP's PDO driver. Create a text file\n\ndata/schema.sql\n with the following contents:\n\n\nCREATE TABLE album (id INTEGER PRIMARY KEY AUTOINCREMENT, artist varchar(100) NOT NULL, title varchar(100) NOT NULL);\nINSERT INTO album (artist, title) VALUES ('The Military Wives', 'In My Dreams');\nINSERT INTO album (artist, title) VALUES ('Adele', '21');\nINSERT INTO album (artist, title) VALUES ('Bruce Springsteen', 'Wrecking Ball (Deluxe)');\nINSERT INTO album (artist, title) VALUES ('Lana Del Rey', 'Born To Die');\nINSERT INTO album (artist, title) VALUES ('Gotye', 'Making Mirrors');\n\n\n\n(The test data chosen happens to be the Bestsellers on Amazon UK at the time of writing!)\n\n\nNow create the database using the following:\n\n\n$ sqlite data/zftutorial.db < data/schema.sql\n\n\n\nSome systems, including Ubuntu, use the command \nsqlite3\n; check to see which\none to use on your system.\n\n\n\n\nUsing PHP to create the database\n\n\nIf you do not have Sqlite installed on your system, you can use PHP to load\nthe database using the same SQL schema file created earlier. Create the file\n\ndata/load_db.php\n with the following contents:\n\n\n<?php\n$db = new PDO('sqlite:' . realpath(__DIR__) . '/zftutorial.db');\n$fh = fopen(__DIR__ . '/schema.sql', 'r');\nwhile ($line = fread($fh, 4096)) {\n    $db->exec($line);\n}\nfclose($fh);\n\n\n\nOnce created, execute it:\n\n\n$ php data/load_db.php\n\n\n\n\n\nWe now have some data in a database and can write a very simple model for it.\n\n\nThe model files\n\n\nZend Framework does not provide a zend-model component because the model is your\nbusiness logic, and it's up to you to decide how you want it to work. There are\nmany components that you can use for this depending on your needs. One approach\nis to have model classes represent each entity in your application and then use\nmapper objects that load and save entities to the database. Another is to use an\nObject-Relational Mapping (ORM) technology, such as Doctrine or Propel.\n\n\nFor this tutorial, we are going to create a model by creating an \nAlbumTable\n\nclass that consumes a \nZend\\Db\\TableGateway\\TableGateway\n, and in which each\nalbum will be represented as an \nAlbum\n object (known as an \nentity\n). This is\nan implementation of the \nTable Data Gateway\n\ndesign pattern to allow for interfacing with data in a database table. Be aware,\nthough, that the Table Data Gateway pattern can become limiting in larger\nsystems. There is also a temptation to put database access code into controller\naction methods as these are exposed by \nZend\\Db\\TableGateway\\AbstractTableGateway\n.\n\nDon't do this\n!\n\n\nLet's start by creating a file called \nAlbum.php\n under\n\nmodule/Album/src/Model\n:\n\n\nnamespace Album\\Model;\n\nclass Album\n{\n    public $id;\n    public $artist;\n    public $title;\n\n    public function exchangeArray(array $data)\n    {\n        $this->id     = !empty($data['id']) ? $data['id'] : null;\n        $this->artist = !empty($data['artist']) ? $data['artist'] : null;\n        $this->title  = !empty($data['title']) ? $data['title'] : null;\n    }\n}\n\n\n\nOur \nAlbum\n entity object is a PHP class. In order to work with zend-db's\n\nTableGateway\n class, we need to implement the \nexchangeArray()\n method; this\nmethod copies the data from the provided array to our entity's properties. We\nwill add an input filter later to ensure the values injected are valid.\n\n\nNext, we create our \nAlbumTable.php\n file in \nmodule/Album/src/Model\n directory like this:\n\n\nnamespace Album\\Model;\n\nuse RuntimeException;\nuse Zend\\Db\\TableGateway\\TableGatewayInterface;\n\nclass AlbumTable\n{\n    private $tableGateway;\n\n    public function __construct(TableGatewayInterface $tableGateway)\n    {\n        $this->tableGateway = $tableGateway;\n    }\n\n    public function fetchAll()\n    {\n        return $this->tableGateway->select();\n    }\n\n    public function getAlbum($id)\n    {\n        $id = (int) $id;\n        $rowset = $this->tableGateway->select(['id' => $id]);\n        $row = $rowset->current();\n        if (! $row) {\n            throw new RuntimeException(sprintf(\n                'Could not find row with identifier %d',\n                $id\n            ));\n        }\n\n        return $row;\n    }\n\n    public function saveAlbum(Album $album)\n    {\n        $data = [\n            'artist' => $album->artist,\n            'title'  => $album->title,\n        ];\n\n        $id = (int) $album->id;\n\n        if ($id === 0) {\n            $this->tableGateway->insert($data);\n            return;\n        }\n\n        if (! $this->getAlbum($id)) {\n            throw new RuntimeException(sprintf(\n                'Cannot update album with identifier %d; does not exist',\n                $id\n            ));\n        }\n\n        $this->tableGateway->update($data, ['id' => $id]);\n    }\n\n    public function deleteAlbum($id)\n    {\n        $this->tableGateway->delete(['id' => (int) $id]);\n    }\n}\n\n\n\n\nThere's a lot going on here. Firstly, we set the protected property\n\n$tableGateway\n to the \nTableGateway\n instance passed in the constructor,\nhinting against the \nTableGatewayInterface\n (which allows us to provide\nalternate implementations easily, including mock instances during testing). We\nwill use this to perform operations on the database table for our albums.\n\n\nWe then create some helper methods that our application will use to interface\nwith the table gateway. \nfetchAll()\n retrieves all albums rows from the database\nas a \nResultSet\n, \ngetAlbum()\n retrieves a single row as an \nAlbum\n object,\n\nsaveAlbum()\n either creates a new row in the database or updates a row that\nalready exists, and \ndeleteAlbum()\n removes the row completely. The code for each\nof these methods is, hopefully, self-explanatory.\n\n\nUsing ServiceManager to configure the table gateway and inject into the AlbumTable\n\n\nIn order to always use the same instance of our \nAlbumTable\n, we will use the\n\nServiceManager\n to define how to create one. This is most easily done in the\n\nModule\n class where we create a method called \ngetServiceConfig()\n which is\nautomatically called by the \nModuleManager\n and applied to the \nServiceManager\n.\nWe'll then be able to retrieve when we need it.\n\n\nTo configure the \nServiceManager\n, we can either supply the name of the class to\nbe instantiated or a factory (closure, callback, or class name of a factory\nclass) that instantiates the object when the \nServiceManager\n needs it. We start\nby implementing \ngetServiceConfig()\n to provide a factory that creates an\n\nAlbumTable\n. Add this method to the bottom of the \nmodule/Album/src/Module.php\n\nfile:\n\n\nnamespace Album;\n\n// Add these import statements:\nuse Zend\\Db\\Adapter\\AdapterInterface;\nuse Zend\\Db\\ResultSet\\ResultSet;\nuse Zend\\Db\\TableGateway\\TableGateway;\nuse Zend\\ModuleManager\\Feature\\ConfigProviderInterface;\n\nclass Module implements ConfigProviderInterface\n{\n    // getConfig() method is here\n\n    // Add this method:\n    public function getServiceConfig()\n    {\n        return [\n            'factories' => [\n                Model\\AlbumTable::class => function($container) {\n                    $tableGateway = $container->get(Model\\AlbumTableGateway::class);\n                    return new Model\\AlbumTable($tableGateway);\n                },\n                Model\\AlbumTableGateway::class => function ($container) {\n                    $dbAdapter = $container->get(AdapterInterface::class);\n                    $resultSetPrototype = new ResultSet();\n                    $resultSetPrototype->setArrayObjectPrototype(new Model\\Album());\n                    return new TableGateway('album', $dbAdapter, null, $resultSetPrototype);\n                },\n            ],\n        ];\n    }\n}\n\n\n\nThis method returns an array of \nfactories\n that are all merged together by the\n\nModuleManager\n before passing them to the \nServiceManager\n. The factory for\n\nAlbum\\Model\\AlbumTable\n uses the \nServiceManager\n to create an\n\nAlbum\\Model\\AlbumTableGateway\n service representing a \nTableGateway\n to pass to\nits constructor. We also tell the \nServiceManager\n that the \nAlbumTableGateway\n\nservice is created by fetching a \nZend\\Db\\Adapter\\AdapterInterface\n\nimplementation (also from the \nServiceManager\n) and using it to create a\n\nTableGateway\n object. The \nTableGateway\n is told to use an \nAlbum\n object\nwhenever it creates a new result row. The \nTableGateway\n classes use the\nprototype pattern for creation of result sets and entities. This means that\ninstead of instantiating when required, the system clones a previously\ninstantiated object. See\n\nPHP Constructor Best Practices and the Prototype Pattern\n\nfor more details.\n\n\n\n\nFactories\n\n\nThe above demonstrates building factories as closures within your module\nclass. Another option is to build the factory as a \nclass\n, and then map the\nclass in your module configuration. This approach has a number of benefits:\n\n\n\n\nThe code is not parsed or executed unless the factory is invoked.\n\n\nYou can easily unit test the factory to ensure it does what it should.\n\n\nYou can extend the factory if desired.\n\n\nYou can re-use the factory across multiple instances that have related\n  construction.\n\n\n\n\nCreating factories is covered in the \nzend-servicemanager documentation\n.\n\n\n\n\nThe \nZend\\Db\\Adapter\\AdapterInterface\n service is registered by the zend-db\ncomponent.  You may have noticed earlier that \nconfig/modules.config.php\n\ncontains the following entries:\n\n\nreturn [\n    'Zend\\Form',\n    'Zend\\Db',\n    'Zend\\Router',\n    'Zend\\Validator',\n    /* ... */\n],\n\n\n\nAll Zend Framework components that provide zend-servicemanager configuration are\nalso exposed as modules themselves; the prompts as to where to register the\ncomponents during our initial installation occurred to ensure that the above\nentries are created for you.\n\n\nThe end result is that we can already rely on having a factory for the\n\nZend\\Db\\Adapter\\AdapterInterface\n service; now we need to provide configuration\nso it can create an adapter for us.\n\n\nZend Framework's \nModuleManager\n merges all the configuration from each module's\n\nmodule.config.php\n file, and then merges in the files in \nconfig/autoload/\n\n(first \n*.global.php\n files, and then \n*.local.php\n files). We'll add our\ndatabase configuration information to \nglobal.php\n, which you should commit to\nyour version control system. You can use \nlocal.php\n (outside of the VCS) to\nstore the credentials for your database if you want to. Modify\n\nconfig/autoload/global.php\n (in the project root, not inside the \nAlbum\n\nmodule) with following code:\n\n\nreturn [\n    'db' => [\n        'driver' => 'Pdo',\n        'dsn'    => sprintf('sqlite:%s/data/zftutorial.db', realpath(getcwd())),\n    ],\n];\n\n\n\nIf you were configuring a database that required credentials, you would put the\ngeneral configuration in your \nconfig/autoload/global.php\n, and then the\nconfiguration for the current environment, including the DSN and credentials, in\nthe \nconfig/autoload/local.php\n file. These get merged when the application\nruns, ensuring you have a full definition, but allows you to keep files with\ncredentials outside of version control.\n\n\nBack to the controller\n\n\nNow that we have a model, we need to inject it into our controller so we can use\nit.\n\n\nFirstly, we'll add a constructor to our controller. Open the file\n\nmodule/Album/src/Controller/AlbumController.php\n and add the following property\nand constructor:\n\n\nnamespace Album\\Controller;\n\n// Add the following import:\nuse Album\\Model\\AlbumTable;\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass AlbumController extends AbstractActionController\n{\n    // Add this property:\n    private $table;\n\n    // Add this constructor:\n    public function __construct(AlbumTable $table)\n    {\n        $this->table = $table;\n    }\n\n    /* ... */\n}\n\n\n\nOur controller now depends on \nAlbumTable\n, so we will need to create a factory\nfor the controller.  Similar to how we created factories for the model, we'll\ncreate it in our \nModule\n class, only this time, under a new method,\n\nAlbum\\Module::getControllerConfig()\n:\n\n\nnamespace Album;\n\nuse Zend\\Db\\Adapter\\Adapter;\nuse Zend\\Db\\ResultSet\\ResultSet;\nuse Zend\\Db\\TableGateway\\TableGateway;\nuse Zend\\ModuleManager\\Feature\\ConfigProviderInterface;\n\nclass Module implements ConfigProviderInterface\n{\n    // getConfig() and getServiceConfig methods are here\n\n    // Add this method:\n    public function getControllerConfig()\n    {\n        return [\n            'factories' => [\n                Controller\\AlbumController::class => function($container) {\n                    return new Controller\\AlbumController(\n                        $container->get(Model\\AlbumTable::class)\n                    );\n                },\n            ],\n        ];\n    }\n}\n\n\n\nBecause we're now defining our own factory, we can modify our\n\nmodule.config.php\n to remove the definition. Open\n\nmodule/Album/config/module.config.php\n and remove the following lines:\n\n\n<?php\nnamespace Album;\n\n// Remove this:\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    // And remove the entire \"controllers\" section here:\n    'controllers' => [\n        'factories' => [\n            Controller\\AlbumController::class => InvokableFactory::class,\n        ],\n    ],\n\n    /* ... */\n];\n\n\n\nWe can now access the property \n$table\n from within our controller whenever we\nneed to interact with our model.\n\n\nListing albums\n\n\nIn order to list the albums, we need to retrieve them from the model and pass\nthem to the view. To do this, we fill in \nindexAction()\n within\n\nAlbumController\n. Update the \nAlbumController::indexAction()\n as follows:\n\n\n// module/Album/src/Controller/AlbumController.php:\n// ...\n    public function indexAction()\n    {\n        return new ViewModel([\n            'albums' => $this->table->fetchAll(),\n        ]);\n    }\n// ...\n\n\n\nWith Zend Framework, in order to set variables in the view, we return a\n\nViewModel\n instance where the first parameter of the constructor is an array\ncontaining data we wish to represent. These are then automatically passed to the\nview script. The \nViewModel\n object also allows us to change the view script\nthat is used, but the default is to use \n{module name}/{controller name}/{action\nname}\n. We can now fill in the \nindex.phtml\n view script:\n\n\n<?php\n// module/Album/view/album/album/index.phtml:\n\n$title = 'My albums';\n$this->headTitle($title);\n?>\n<h1><?= $this->escapeHtml($title) ?></h1>\n<p>\n    <a href=\"<?= $this->url('album', ['action' => 'add']) ?>\">Add new album</a>\n</p>\n\n<table class=\"table\">\n<tr>\n    <th>Title</th>\n    <th>Artist</th>\n    <th>&nbsp;</th>\n</tr>\n<?php foreach ($albums as $album) : ?>\n    <tr>\n        <td><?= $this->escapeHtml($album->title) ?></td>\n        <td><?= $this->escapeHtml($album->artist) ?></td>\n        <td>\n            <a href=\"<?= $this->url('album', ['action' => 'edit', 'id' => $album->id]) ?>\">Edit</a>\n            <a href=\"<?= $this->url('album', ['action' => 'delete', 'id' => $album->id]) ?>\">Delete</a>\n        </td>\n    </tr>\n<?php endforeach; ?>\n</table>\n\n\n\nThe first thing we do is to set the title for the page (used in the layout) and\nalso set the title for the \n<head>\n section using the \nheadTitle()\n view helper\nwhich will display in the browser's title bar. We then create a link to add a\nnew album.\n\n\nThe \nurl()\n view helper is provided by zend-mvc and zend-view, and is used to create\nthe links we need. The first parameter to \nurl()\n is the route name we wish to\nuse for construction of the URL, and the second parameter is an array of\nvariables to substitute into route placeholders. In this case we use our \nalbum\n\nroute which is set up to accept two placeholder variables: \naction\n and \nid\n.\n\n\nWe iterate over the \n$albums\n that we assigned from the controller action.\nzend-view automatically ensures that these variables are extracted into the\nscope of the view script; you may also access them using \n$this->{variable\nname}\n in order to differentiate between variables provided to the view script\nand those created inside it.\n\n\nWe then create a table to display each album's title and artist, and provide\nlinks to allow for editing and deleting the record. A standard \nforeach:\n loop\nis used to iterate over the list of albums, and we use the alternate form using\na colon and \nendforeach;\n as it is easier to scan than to try and match up\nbraces. Again, the \nurl()\n view helper is used to create the edit and delete\nlinks.\n\n\n\n\nEscaping\n\n\nWe always use the \nescapeHtml()\n view helper to help protect ourselves from\n\nCross Site Scripting (XSS) vulnerabilities\n.\n\n\n\n\nIf you open \nhttp://localhost:8080/album\n (or \nhttp://zf-tutorial.localhost/album\n \nif you are using self-hosted Apache) you should see this:",
            "title": "Banco de Dados e Models"
        },
        {
            "location": "/getting-started/database-and-models/#database-and-models",
            "text": "",
            "title": "Database and models"
        },
        {
            "location": "/getting-started/database-and-models/#the-database",
            "text": "Now that we have the  Album  module set up with controller action methods and\nview scripts, it is time to look at the model section of our application.\nRemember that the model is the part that deals with the application's core\npurpose (the so-called \u201cbusiness rules\u201d) and, in our case, deals with the\ndatabase. We will make use of zend-db's  Zend\\Db\\TableGateway\\TableGateway  to\nfind, insert, update, and delete rows from a database table.  We are going to use Sqlite, via PHP's PDO driver. Create a text file data/schema.sql  with the following contents:  CREATE TABLE album (id INTEGER PRIMARY KEY AUTOINCREMENT, artist varchar(100) NOT NULL, title varchar(100) NOT NULL);\nINSERT INTO album (artist, title) VALUES ('The Military Wives', 'In My Dreams');\nINSERT INTO album (artist, title) VALUES ('Adele', '21');\nINSERT INTO album (artist, title) VALUES ('Bruce Springsteen', 'Wrecking Ball (Deluxe)');\nINSERT INTO album (artist, title) VALUES ('Lana Del Rey', 'Born To Die');\nINSERT INTO album (artist, title) VALUES ('Gotye', 'Making Mirrors');  (The test data chosen happens to be the Bestsellers on Amazon UK at the time of writing!)  Now create the database using the following:  $ sqlite data/zftutorial.db < data/schema.sql  Some systems, including Ubuntu, use the command  sqlite3 ; check to see which\none to use on your system.",
            "title": "The database"
        },
        {
            "location": "/getting-started/database-and-models/#using-php-to-create-the-database",
            "text": "If you do not have Sqlite installed on your system, you can use PHP to load\nthe database using the same SQL schema file created earlier. Create the file data/load_db.php  with the following contents:  <?php\n$db = new PDO('sqlite:' . realpath(__DIR__) . '/zftutorial.db');\n$fh = fopen(__DIR__ . '/schema.sql', 'r');\nwhile ($line = fread($fh, 4096)) {\n    $db->exec($line);\n}\nfclose($fh);  Once created, execute it:  $ php data/load_db.php   We now have some data in a database and can write a very simple model for it.",
            "title": "Using PHP to create the database"
        },
        {
            "location": "/getting-started/database-and-models/#the-model-files",
            "text": "Zend Framework does not provide a zend-model component because the model is your\nbusiness logic, and it's up to you to decide how you want it to work. There are\nmany components that you can use for this depending on your needs. One approach\nis to have model classes represent each entity in your application and then use\nmapper objects that load and save entities to the database. Another is to use an\nObject-Relational Mapping (ORM) technology, such as Doctrine or Propel.  For this tutorial, we are going to create a model by creating an  AlbumTable \nclass that consumes a  Zend\\Db\\TableGateway\\TableGateway , and in which each\nalbum will be represented as an  Album  object (known as an  entity ). This is\nan implementation of the  Table Data Gateway \ndesign pattern to allow for interfacing with data in a database table. Be aware,\nthough, that the Table Data Gateway pattern can become limiting in larger\nsystems. There is also a temptation to put database access code into controller\naction methods as these are exposed by  Zend\\Db\\TableGateway\\AbstractTableGateway . Don't do this !  Let's start by creating a file called  Album.php  under module/Album/src/Model :  namespace Album\\Model;\n\nclass Album\n{\n    public $id;\n    public $artist;\n    public $title;\n\n    public function exchangeArray(array $data)\n    {\n        $this->id     = !empty($data['id']) ? $data['id'] : null;\n        $this->artist = !empty($data['artist']) ? $data['artist'] : null;\n        $this->title  = !empty($data['title']) ? $data['title'] : null;\n    }\n}  Our  Album  entity object is a PHP class. In order to work with zend-db's TableGateway  class, we need to implement the  exchangeArray()  method; this\nmethod copies the data from the provided array to our entity's properties. We\nwill add an input filter later to ensure the values injected are valid.  Next, we create our  AlbumTable.php  file in  module/Album/src/Model  directory like this:  namespace Album\\Model;\n\nuse RuntimeException;\nuse Zend\\Db\\TableGateway\\TableGatewayInterface;\n\nclass AlbumTable\n{\n    private $tableGateway;\n\n    public function __construct(TableGatewayInterface $tableGateway)\n    {\n        $this->tableGateway = $tableGateway;\n    }\n\n    public function fetchAll()\n    {\n        return $this->tableGateway->select();\n    }\n\n    public function getAlbum($id)\n    {\n        $id = (int) $id;\n        $rowset = $this->tableGateway->select(['id' => $id]);\n        $row = $rowset->current();\n        if (! $row) {\n            throw new RuntimeException(sprintf(\n                'Could not find row with identifier %d',\n                $id\n            ));\n        }\n\n        return $row;\n    }\n\n    public function saveAlbum(Album $album)\n    {\n        $data = [\n            'artist' => $album->artist,\n            'title'  => $album->title,\n        ];\n\n        $id = (int) $album->id;\n\n        if ($id === 0) {\n            $this->tableGateway->insert($data);\n            return;\n        }\n\n        if (! $this->getAlbum($id)) {\n            throw new RuntimeException(sprintf(\n                'Cannot update album with identifier %d; does not exist',\n                $id\n            ));\n        }\n\n        $this->tableGateway->update($data, ['id' => $id]);\n    }\n\n    public function deleteAlbum($id)\n    {\n        $this->tableGateway->delete(['id' => (int) $id]);\n    }\n}  There's a lot going on here. Firstly, we set the protected property $tableGateway  to the  TableGateway  instance passed in the constructor,\nhinting against the  TableGatewayInterface  (which allows us to provide\nalternate implementations easily, including mock instances during testing). We\nwill use this to perform operations on the database table for our albums.  We then create some helper methods that our application will use to interface\nwith the table gateway.  fetchAll()  retrieves all albums rows from the database\nas a  ResultSet ,  getAlbum()  retrieves a single row as an  Album  object, saveAlbum()  either creates a new row in the database or updates a row that\nalready exists, and  deleteAlbum()  removes the row completely. The code for each\nof these methods is, hopefully, self-explanatory.",
            "title": "The model files"
        },
        {
            "location": "/getting-started/database-and-models/#using-servicemanager-to-configure-the-table-gateway-and-inject-into-the-albumtable",
            "text": "In order to always use the same instance of our  AlbumTable , we will use the ServiceManager  to define how to create one. This is most easily done in the Module  class where we create a method called  getServiceConfig()  which is\nautomatically called by the  ModuleManager  and applied to the  ServiceManager .\nWe'll then be able to retrieve when we need it.  To configure the  ServiceManager , we can either supply the name of the class to\nbe instantiated or a factory (closure, callback, or class name of a factory\nclass) that instantiates the object when the  ServiceManager  needs it. We start\nby implementing  getServiceConfig()  to provide a factory that creates an AlbumTable . Add this method to the bottom of the  module/Album/src/Module.php \nfile:  namespace Album;\n\n// Add these import statements:\nuse Zend\\Db\\Adapter\\AdapterInterface;\nuse Zend\\Db\\ResultSet\\ResultSet;\nuse Zend\\Db\\TableGateway\\TableGateway;\nuse Zend\\ModuleManager\\Feature\\ConfigProviderInterface;\n\nclass Module implements ConfigProviderInterface\n{\n    // getConfig() method is here\n\n    // Add this method:\n    public function getServiceConfig()\n    {\n        return [\n            'factories' => [\n                Model\\AlbumTable::class => function($container) {\n                    $tableGateway = $container->get(Model\\AlbumTableGateway::class);\n                    return new Model\\AlbumTable($tableGateway);\n                },\n                Model\\AlbumTableGateway::class => function ($container) {\n                    $dbAdapter = $container->get(AdapterInterface::class);\n                    $resultSetPrototype = new ResultSet();\n                    $resultSetPrototype->setArrayObjectPrototype(new Model\\Album());\n                    return new TableGateway('album', $dbAdapter, null, $resultSetPrototype);\n                },\n            ],\n        ];\n    }\n}  This method returns an array of  factories  that are all merged together by the ModuleManager  before passing them to the  ServiceManager . The factory for Album\\Model\\AlbumTable  uses the  ServiceManager  to create an Album\\Model\\AlbumTableGateway  service representing a  TableGateway  to pass to\nits constructor. We also tell the  ServiceManager  that the  AlbumTableGateway \nservice is created by fetching a  Zend\\Db\\Adapter\\AdapterInterface \nimplementation (also from the  ServiceManager ) and using it to create a TableGateway  object. The  TableGateway  is told to use an  Album  object\nwhenever it creates a new result row. The  TableGateway  classes use the\nprototype pattern for creation of result sets and entities. This means that\ninstead of instantiating when required, the system clones a previously\ninstantiated object. See PHP Constructor Best Practices and the Prototype Pattern \nfor more details.",
            "title": "Using ServiceManager to configure the table gateway and inject into the AlbumTable"
        },
        {
            "location": "/getting-started/database-and-models/#factories",
            "text": "The above demonstrates building factories as closures within your module\nclass. Another option is to build the factory as a  class , and then map the\nclass in your module configuration. This approach has a number of benefits:   The code is not parsed or executed unless the factory is invoked.  You can easily unit test the factory to ensure it does what it should.  You can extend the factory if desired.  You can re-use the factory across multiple instances that have related\n  construction.   Creating factories is covered in the  zend-servicemanager documentation .   The  Zend\\Db\\Adapter\\AdapterInterface  service is registered by the zend-db\ncomponent.  You may have noticed earlier that  config/modules.config.php \ncontains the following entries:  return [\n    'Zend\\Form',\n    'Zend\\Db',\n    'Zend\\Router',\n    'Zend\\Validator',\n    /* ... */\n],  All Zend Framework components that provide zend-servicemanager configuration are\nalso exposed as modules themselves; the prompts as to where to register the\ncomponents during our initial installation occurred to ensure that the above\nentries are created for you.  The end result is that we can already rely on having a factory for the Zend\\Db\\Adapter\\AdapterInterface  service; now we need to provide configuration\nso it can create an adapter for us.  Zend Framework's  ModuleManager  merges all the configuration from each module's module.config.php  file, and then merges in the files in  config/autoload/ \n(first  *.global.php  files, and then  *.local.php  files). We'll add our\ndatabase configuration information to  global.php , which you should commit to\nyour version control system. You can use  local.php  (outside of the VCS) to\nstore the credentials for your database if you want to. Modify config/autoload/global.php  (in the project root, not inside the  Album \nmodule) with following code:  return [\n    'db' => [\n        'driver' => 'Pdo',\n        'dsn'    => sprintf('sqlite:%s/data/zftutorial.db', realpath(getcwd())),\n    ],\n];  If you were configuring a database that required credentials, you would put the\ngeneral configuration in your  config/autoload/global.php , and then the\nconfiguration for the current environment, including the DSN and credentials, in\nthe  config/autoload/local.php  file. These get merged when the application\nruns, ensuring you have a full definition, but allows you to keep files with\ncredentials outside of version control.",
            "title": "Factories"
        },
        {
            "location": "/getting-started/database-and-models/#back-to-the-controller",
            "text": "Now that we have a model, we need to inject it into our controller so we can use\nit.  Firstly, we'll add a constructor to our controller. Open the file module/Album/src/Controller/AlbumController.php  and add the following property\nand constructor:  namespace Album\\Controller;\n\n// Add the following import:\nuse Album\\Model\\AlbumTable;\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass AlbumController extends AbstractActionController\n{\n    // Add this property:\n    private $table;\n\n    // Add this constructor:\n    public function __construct(AlbumTable $table)\n    {\n        $this->table = $table;\n    }\n\n    /* ... */\n}  Our controller now depends on  AlbumTable , so we will need to create a factory\nfor the controller.  Similar to how we created factories for the model, we'll\ncreate it in our  Module  class, only this time, under a new method, Album\\Module::getControllerConfig() :  namespace Album;\n\nuse Zend\\Db\\Adapter\\Adapter;\nuse Zend\\Db\\ResultSet\\ResultSet;\nuse Zend\\Db\\TableGateway\\TableGateway;\nuse Zend\\ModuleManager\\Feature\\ConfigProviderInterface;\n\nclass Module implements ConfigProviderInterface\n{\n    // getConfig() and getServiceConfig methods are here\n\n    // Add this method:\n    public function getControllerConfig()\n    {\n        return [\n            'factories' => [\n                Controller\\AlbumController::class => function($container) {\n                    return new Controller\\AlbumController(\n                        $container->get(Model\\AlbumTable::class)\n                    );\n                },\n            ],\n        ];\n    }\n}  Because we're now defining our own factory, we can modify our module.config.php  to remove the definition. Open module/Album/config/module.config.php  and remove the following lines:  <?php\nnamespace Album;\n\n// Remove this:\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    // And remove the entire \"controllers\" section here:\n    'controllers' => [\n        'factories' => [\n            Controller\\AlbumController::class => InvokableFactory::class,\n        ],\n    ],\n\n    /* ... */\n];  We can now access the property  $table  from within our controller whenever we\nneed to interact with our model.",
            "title": "Back to the controller"
        },
        {
            "location": "/getting-started/database-and-models/#listing-albums",
            "text": "In order to list the albums, we need to retrieve them from the model and pass\nthem to the view. To do this, we fill in  indexAction()  within AlbumController . Update the  AlbumController::indexAction()  as follows:  // module/Album/src/Controller/AlbumController.php:\n// ...\n    public function indexAction()\n    {\n        return new ViewModel([\n            'albums' => $this->table->fetchAll(),\n        ]);\n    }\n// ...  With Zend Framework, in order to set variables in the view, we return a ViewModel  instance where the first parameter of the constructor is an array\ncontaining data we wish to represent. These are then automatically passed to the\nview script. The  ViewModel  object also allows us to change the view script\nthat is used, but the default is to use  {module name}/{controller name}/{action\nname} . We can now fill in the  index.phtml  view script:  <?php\n// module/Album/view/album/album/index.phtml:\n\n$title = 'My albums';\n$this->headTitle($title);\n?>\n<h1><?= $this->escapeHtml($title) ?></h1>\n<p>\n    <a href=\"<?= $this->url('album', ['action' => 'add']) ?>\">Add new album</a>\n</p>\n\n<table class=\"table\">\n<tr>\n    <th>Title</th>\n    <th>Artist</th>\n    <th>&nbsp;</th>\n</tr>\n<?php foreach ($albums as $album) : ?>\n    <tr>\n        <td><?= $this->escapeHtml($album->title) ?></td>\n        <td><?= $this->escapeHtml($album->artist) ?></td>\n        <td>\n            <a href=\"<?= $this->url('album', ['action' => 'edit', 'id' => $album->id]) ?>\">Edit</a>\n            <a href=\"<?= $this->url('album', ['action' => 'delete', 'id' => $album->id]) ?>\">Delete</a>\n        </td>\n    </tr>\n<?php endforeach; ?>\n</table>  The first thing we do is to set the title for the page (used in the layout) and\nalso set the title for the  <head>  section using the  headTitle()  view helper\nwhich will display in the browser's title bar. We then create a link to add a\nnew album.  The  url()  view helper is provided by zend-mvc and zend-view, and is used to create\nthe links we need. The first parameter to  url()  is the route name we wish to\nuse for construction of the URL, and the second parameter is an array of\nvariables to substitute into route placeholders. In this case we use our  album \nroute which is set up to accept two placeholder variables:  action  and  id .  We iterate over the  $albums  that we assigned from the controller action.\nzend-view automatically ensures that these variables are extracted into the\nscope of the view script; you may also access them using  $this->{variable\nname}  in order to differentiate between variables provided to the view script\nand those created inside it.  We then create a table to display each album's title and artist, and provide\nlinks to allow for editing and deleting the record. A standard  foreach:  loop\nis used to iterate over the list of albums, and we use the alternate form using\na colon and  endforeach;  as it is easier to scan than to try and match up\nbraces. Again, the  url()  view helper is used to create the edit and delete\nlinks.",
            "title": "Listing albums"
        },
        {
            "location": "/getting-started/database-and-models/#escaping",
            "text": "We always use the  escapeHtml()  view helper to help protect ourselves from Cross Site Scripting (XSS) vulnerabilities .   If you open  http://localhost:8080/album  (or  http://zf-tutorial.localhost/album  \nif you are using self-hosted Apache) you should see this:",
            "title": "Escaping"
        },
        {
            "location": "/getting-started/forms-and-actions/",
            "text": "Forms and actions\n\n\nAdding new albums\n\n\nWe can now code up the functionality to add new albums. There are two bits to this part:\n\n\n\n\nDisplay a form for user to provide details.\n\n\nProcess the form submission and store to database.\n\n\n\n\nWe will use zend-form to do this. zend-form manages the various form inputs as\nwell as their validation, the latter of which is handled by the zend-inputfilter\ncomponent. We'll start by creating a new class, \nAlbum\\Form\\AlbumForm\n,\nextending from \nZend\\Form\\Form\n. Create the file\n\nmodule/Album/src/Form/AlbumForm.php\n with the following contents:\n\n\nnamespace Album\\Form;\n\nuse Zend\\Form\\Form;\n\nclass AlbumForm extends Form\n{\n    public function __construct($name = null)\n    {\n        // We will ignore the name provided to the constructor\n        parent::__construct('album');\n\n        $this->add([\n            'name' => 'id',\n            'type' => 'hidden',\n        ]);\n        $this->add([\n            'name' => 'title',\n            'type' => 'text',\n            'options' => [\n                'label' => 'Title',\n            ],\n        ]);\n        $this->add([\n            'name' => 'artist',\n            'type' => 'text',\n            'options' => [\n                'label' => 'Artist',\n            ],\n        ]);\n        $this->add([\n            'name' => 'submit',\n            'type' => 'submit',\n            'attributes' => [\n                'value' => 'Go',\n                'id'    => 'submitbutton',\n            ],\n        ]);\n    }\n}\n\n\n\nWithin the constructor of \nAlbumForm\n we do several things. First, we set the\nname of the form as we call the parent's constructor. The, we create four form\nelements: the id, title, artist, and submit button. For each item we set various\nattributes and options, including the label to be displayed.\n\n\n\n\nForm method\n\n\nHTML forms can be sent using \nPOST\n and \nGET\n. zend-form defaults to \nPOST\n;\ntherefore you don't have to be explicit in setting this option. If you want to\nchange it to \nGET\n however, set the method attribute in the constructor:\n\n\n$this->setAttribute('method', 'GET');\n\n\n\n\n\nWe also need to set up validation for this form.  \nzend-inputfilter\n\nprovides a general purpose mechanism for input validation. It also provides an\ninterface, \nInputFilterAwareInterface\n, which zend-form will use in order to\nbind an input filter to a given form. We'll add this capability now to our\n\nAlbum\n class.\n\n\n// module/Album/src/Model/Album.php:\nnamespace Album\\Model;\n\n// Add the following import statements:\nuse DomainException;\nuse Zend\\Filter\\StringTrim;\nuse Zend\\Filter\\StripTags;\nuse Zend\\Filter\\ToInt;\nuse Zend\\InputFilter\\InputFilter;\nuse Zend\\InputFilter\\InputFilterAwareInterface;\nuse Zend\\InputFilter\\InputFilterInterface;\nuse Zend\\Validator\\StringLength;\n\nclass Album implements InputFilterAwareInterface\n{\n    public $id;\n    public $artist;\n    public $title;\n\n    // Add this property:\n    private $inputFilter;\n\n    public function exchangeArray(array $data)\n    {\n        $this->id     = !empty($data['id']) ? $data['id'] : null;\n        $this->artist = !empty($data['artist']) ? $data['artist'] : null;\n        $this->title  = !empty($data['title']) ? $data['title'] : null;\n    }\n\n    /* Add the following methods: */\n\n    public function setInputFilter(InputFilterInterface $inputFilter)\n    {\n        throw new DomainException(sprintf(\n            '%s does not allow injection of an alternate input filter',\n            __CLASS__\n        ));\n    }\n\n    public function getInputFilter()\n    {\n        if ($this->inputFilter) {\n            return $this->inputFilter;\n        }\n\n        $inputFilter = new InputFilter();\n\n        $inputFilter->add([\n            'name' => 'id',\n            'required' => true,\n            'filters' => [\n                ['name' => ToInt::class],\n            ],\n        ]);\n\n        $inputFilter->add([\n            'name' => 'artist',\n            'required' => true,\n            'filters' => [\n                ['name' => StripTags::class],\n                ['name' => StringTrim::class],\n            ],\n            'validators' => [\n                [\n                    'name' => StringLength::class,\n                    'options' => [\n                        'encoding' => 'UTF-8',\n                        'min' => 1,\n                        'max' => 100,\n                    ],\n                ],\n            ],\n        ]);\n\n        $inputFilter->add([\n            'name' => 'title',\n            'required' => true,\n            'filters' => [\n                ['name' => StripTags::class],\n                ['name' => StringTrim::class],\n            ],\n            'validators' => [\n                [\n                    'name' => StringLength::class,\n                    'options' => [\n                        'encoding' => 'UTF-8',\n                        'min' => 1,\n                        'max' => 100,\n                    ],\n                ],\n            ],\n        ]);\n\n        $this->inputFilter = $inputFilter;\n        return $this->inputFilter;\n    }\n}\n\n\n\nThe \nInputFilterAwareInterface\n defines two methods: \nsetInputFilter()\n and\n\ngetInputFilter()\n. We only need to implement \ngetInputFilter()\n so we\nthrow an exception from \nsetInputFilter()\n.\n\n\nWithin \ngetInputFilter()\n, we instantiate an \nInputFilter\n and then add the\ninputs that we require. We add one input for each property that we wish to\nfilter or validate. For the \nid\n field we add an \nint\n filter as we only need\nintegers. For the text elements, we add two filters, \nStripTags\n and\n\nStringTrim\n, to remove unwanted HTML and unnecessary white space. We also set\nthem to be \nrequired\n and add a \nStringLength\n validator to ensure that the user\ndoesn't enter more characters than we can store into the database.\n\n\nWe now need to get the form to display and then process it on submission. This\nis done within the \nAlbumController::addAction()\n:\n\n\n// module/Album/src/Controller/AlbumController.php:\n\n// Add the following import statements at the top of the file:\nuse Album\\Form\\AlbumForm;\nuse Album\\Model\\Album;\n\nclass AlbumController extends AbstractActionController\n{\n    /* ... */\n\n    /* Update the following method to read as follows: */\n    public function addAction()\n    {\n        $form = new AlbumForm();\n        $form->get('submit')->setValue('Add');\n\n        $request = $this->getRequest();\n\n        if (! $request->isPost()) {\n            return ['form' => $form];\n        }\n\n        $album = new Album();\n        $form->setInputFilter($album->getInputFilter());\n        $form->setData($request->getPost());\n\n        if (! $form->isValid()) {\n            return ['form' => $form];\n        }\n\n        $album->exchangeArray($form->getData());\n        $this->table->saveAlbum($album);\n        return $this->redirect()->toRoute('album');\n    }\n\n    /* ... */\n}\n\n\n\nAfter adding the \nAlbum\n and \nAlbumForm\n classes to the import list, we\nimplement \naddAction()\n. Let's look at the \naddAction()\n code in a little more\ndetail:\n\n\n$form = new AlbumForm();\n$form->get('submit')->setValue('Add');\n\n\n\nWe instantiate \nAlbumForm\n and set the label on the submit button to \"Add\". We\ndo this here as we'll want to re-use the form when editing an album and will use\na different label.\n\n\n$request = $this->getRequest();\n\nif (! $request->isPost()) {\n    return ['form' => $form];\n}\n\n\n\nIf the request is not a \nPOST\n request, then no form data has been submitted,\nand we need to display the form. zend-mvc allows you to return an array of data\ninstead of a view model if desired; if you do, the array will be used to create\na view model.\n\n\n$album = new Album();\n$form->setInputFilter($album->getInputFilter());\n$form->setData($request->getPost());\n\n\n\nAt this point, we know we have a form submission. We create an \nAlbum\n instance,\nand pass its input filter on to the form; additionally, we pass the submitted\ndata from the request instance to the form.\n\n\nif (! $form->isValid()) {\n    return ['form' => $form];\n}\n\n\n\nIf form validation fails, we want to redisplay the form. At this point, the form\ncontains information about what fields failed validation, and why, and this\ninformation will be communicated to the view layer.\n\n\n$album->exchangeArray($form->getData());\n$this->table->saveAlbum($album);\n\n\n\nIf the form is valid, then we grab the data from the form and store to the model\nusing \nsaveAlbum()\n.\n\n\nreturn $this->redirect()->toRoute('album');\n\n\n\nAfter we have saved the new album row, we redirect back to the list of albums\nusing the \nRedirect\n controller plugin.\n\n\nWe now need to render the form in the \nadd.phtml\n view script:\n\n\n<?php\n// module/Album/view/album/album/add.phtml:\n\n$title = 'Add new album';\n$this->headTitle($title);\n?>\n<h1><?= $this->escapeHtml($title) ?></h1>\n<?php\n$form->setAttribute('action', $this->url('album', ['action' => 'add']));\n$form->prepare();\n\necho $this->form()->openTag($form);\necho $this->formHidden($form->get('id'));\necho $this->formRow($form->get('title'));\necho $this->formRow($form->get('artist'));\necho $this->formSubmit($form->get('submit'));\necho $this->form()->closeTag();\n\n\n\nWe display a title as before, and then we render the form. zend-form provides\nseveral view helpers to make this a little easier. The \nform()\n view helper has\nan \nopenTag()\n and \ncloseTag()\n method which we use to open and close the form.\nThen for each element with a label, we can use \nformRow()\n to render the label,\ninput, and any validation error messages; for the two elements that are\nstandalone and have no validation rules, we use \nformHidden()\n and\n\nformSubmit()\n.\n\n\nAlternatively, the process of rendering the form can be simplified by using the\nbundled \nformCollection\n view helper. For example, in the view script above\nreplace all the form-rendering echo statements with:\n\n\necho $this->formCollection($form);\n\n\n\nThis will iterate over the form structure, calling the appropriate label,\nelement, and error view helpers for each element, but you still have to wrap\n\nformCollection($form)\n with the open and close form tags. This helps reduce the\ncomplexity of your view script in situations where the default HTML rendering of\nthe form is acceptable.\n\n\nYou should now be able to use the \"Add new album\" link on the home page of the\napplication to add a new album record, resulting in something like the\nfollowing:\n\n\n\n\nThis doesn't look all that great! The reason is because Bootstrap, the CSS\nfoundation used in the skeleton, has specialized markup for displaying forms! We\ncan address that in our view script by:\n\n\n\n\nAdding markup around the elements.\n\n\nRendering labels, elements, and error messages separately.\n\n\nAdding attributes to elements.\n\n\n\n\nUpdate your \nadd.phtml\n view script to read as follows:\n\n\n<?php\n$title = 'Add new album';\n$this->headTitle($title);\n?>\n<h1><?= $this->escapeHtml($title) ?></h1>\n<?php\n// This provides a default CSS class and placeholder text for the title element:\n$album = $form->get('title');\n$album->setAttribute('class', 'form-control');\n$album->setAttribute('placeholder', 'Album title');\n\n// This provides a default CSS class and placeholder text for the artist element:\n$artist = $form->get('artist');\n$artist->setAttribute('class', 'form-control');\n$artist->setAttribute('placeholder', 'Artist');\n\n// This provides CSS classes for the submit button:\n$submit = $form->get('submit');\n$submit->setAttribute('class', 'btn btn-primary');\n\n$form->setAttribute('action', $this->url('album', ['action' => 'add']));\n$form->prepare();\n\necho $this->form()->openTag($form);\n?>\n<?php // Wrap the elements in divs marked as form groups, and render the\n      // label, element, and errors separately within ?>\n<div class=\"form-group\">\n    <?= $this->formLabel($album) ?>\n    <?= $this->formElement($album) ?>\n    <?= $this->formElementErrors()->render($album, ['class' => 'help-block']) ?>\n</div>\n\n<div class=\"form-group\">\n    <?= $this->formLabel($artist) ?>\n    <?= $this->formElement($artist) ?>\n    <?= $this->formElementErrors()->render($artist, ['class' => 'help-block']) ?>\n</div>\n\n<?php\necho $this->formSubmit($submit);\necho $this->formHidden($form->get('id'));\necho $this->form()->closeTag();\n\n\n\nThe results we get are much better:\n\n\n\n\nThe above is meant to demonstrate both the ease of use of the default form\nfeatures, as well as some of the customizations possible when rendering forms.\nYou should be able to generate any markup necessary for your site.\n\n\nEditing an album\n\n\nEditing an album is almost identical to adding one, so the code is very similar.\nThis time we use \neditAction()\n in the \nAlbumController\n:\n\n\n// module/Album/src/Controller/AlbumController.php:\n// ...\n\n    public function editAction()\n    {\n        $id = (int) $this->params()->fromRoute('id', 0);\n\n        if (0 === $id) {\n            return $this->redirect()->toRoute('album', ['action' => 'add']);\n        }\n\n        // Retrieve the album with the specified id. Doing so raises\n        // an exception if the album is not found, which should result\n        // in redirecting to the landing page.\n        try {\n            $album = $this->table->getAlbum($id);\n        } catch (\\Exception $e) {\n            return $this->redirect()->toRoute('album', ['action' => 'index']);\n        }\n\n        $form = new AlbumForm();\n        $form->bind($album);\n        $form->get('submit')->setAttribute('value', 'Edit');\n\n        $request = $this->getRequest();\n        $viewData = ['id' => $id, 'form' => $form];\n\n        if (! $request->isPost()) {\n            return $viewData;\n        }\n\n        $form->setInputFilter($album->getInputFilter());\n        $form->setData($request->getPost());\n\n        if (! $form->isValid()) {\n            return $viewData;\n        }\n\n        $this->table->saveAlbum($album);\n\n        // Redirect to album list\n        return $this->redirect()->toRoute('album', ['action' => 'index']);\n    }\n\n\n\nThis code should look comfortably familiar. Let's look at the differences from\nadding an album. Firstly, we look for the \nid\n that is in the matched route and\nuse it to load the album to be edited:\n\n\n$id = (int) $this->params()->fromRoute('id', 0);\n\nif (0 === $id) {\n    return $this->redirect()->toRoute('album', ['action' => 'add']);\n}\n\n// Retrieve the album with the specified id. Doing so raises\n// an exception if the album is not found, which should result\n// in redirecting to the landing page.\ntry {\n    $album = $this->table->getAlbum($id);\n} catch (\\Exception $e) {\n    return $this->redirect()->toRoute('album', ['action' => 'index']);\n}\n\n\n\nparams\n is a controller plugin that provides a convenient way to retrieve\nparameters from the matched route. We use it to retrieve the \nid\n from the route\nwe created within the Album module's \nmodule.config.php\n. If the \nid\n is zero,\nthen we redirect to the add action, otherwise, we continue by getting the album\nentity from the database.\n\n\nWe have to check to make sure that the album with the specified \nid\n can\nactually be found. If it cannot, then the data access method throws an\nexception. We catch that exception and re-route the user to the index page.\n\n\n$form = new AlbumForm();\n$form->bind($album);\n$form->get('submit')->setAttribute('value', 'Edit');\n\n\n\nThe form's \nbind()\n method attaches the model to the form. This is used in two ways:\n\n\n\n\nWhen displaying the form, the initial values for each element are extracted\n  from the model.\n\n\nAfter successful validation in \nisValid()\n, the data from the form is put back\n  into the model.\n\n\n\n\nThese operations are done using a \nhydrator\n object. There are a number of\nhydrators, but the default one is \nZend\\Hydrator\\ArraySerializable\n which\nexpects to find two methods in the model: \ngetArrayCopy()\n and\n\nexchangeArray()\n. We have already written \nexchangeArray()\n in our \nAlbum\n\nentity, so we now need to write \ngetArrayCopy()\n:\n\n\n// module/Album/src/Model/Album.php:\n// ...\n\n    public function exchangeArray($data)\n    {\n        $this->id     = isset($data['id']) ? $data['id'] : null;\n        $this->artist = isset($data['artist']) ? $data['artist'] : null;\n        $this->title  = isset($data['title']) ? $data['title'] : null;\n    }\n\n    // Add the following method:\n    public function getArrayCopy()\n    {\n        return [\n            'id'     => $this->id,\n            'artist' => $this->artist,\n            'title'  => $this->title,\n        ];\n    }\n\n// ...\n\n\n\nAs a result of using \nbind()\n with its hydrator, we do not need to populate the\nform's data back into the \n$album\n as that's already been done, so we can just\ncall the mapper's \nsaveAlbum()\n method to store the changes back to the\ndatabase.\n\n\nThe view template, \nedit.phtml\n, looks very similar to the one for adding an album:\n\n\n<?php\n// module/Album/view/album/album/edit.phtml:\n\n$title = 'Edit album';\n$this->headTitle($title);\n?>\n<h1><?= $this->escapeHtml($title) ?></h1>\n<?php\n$album = $form->get('title');\n$album->setAttribute('class', 'form-control');\n$album->setAttribute('placeholder', 'Album title');\n\n$artist = $form->get('artist');\n$artist->setAttribute('class', 'form-control');\n$artist->setAttribute('placeholder', 'Artist');\n\n$submit = $form->get('submit');\n$submit->setAttribute('class', 'btn btn-primary');\n\n$form->setAttribute('action', $this->url('album', [\n    'action' => 'edit',\n    'id'     => $id,\n]));\n$form->prepare();\n\necho $this->form()->openTag($form);\n?>\n<div class=\"form-group\">\n    <?= $this->formLabel($album) ?>\n    <?= $this->formElement($album) ?>\n    <?= $this->formElementErrors()->render($album, ['class' => 'help-block']) ?>\n</div>\n\n<div class=\"form-group\">\n    <?= $this->formLabel($artist) ?>\n    <?= $this->formElement($artist) ?>\n    <?= $this->formElementErrors()->render($artist, ['class' => 'help-block']) ?>\n</div>\n\n<?php\necho $this->formSubmit($submit);\necho $this->formHidden($form->get('id'));\necho $this->form()->closeTag();\n\n\n\nThe only changes are to use the \u2018Edit Album' title and set the form's action to\nthe 'edit' action too, using the current album identifier.\n\n\nYou should now be able to edit albums.\n\n\nDeleting an album\n\n\nTo round out our application, we need to add deletion. We have a \"Delete\" link\nnext to each album on our list page, and the naive approach would be to do a\ndelete when it's clicked. This would be wrong. Remembering our HTTP spec, we\nrecall that you shouldn't do an irreversible action using GET and should use\nPOST instead.\n\n\nWe shall show a confirmation form when the user clicks delete, and if they then\nclick \"yes\", we will do the deletion. As the form is trivial, we'll code it\ndirectly into our view (zend-form is, after all, optional!).\n\n\nLet's start with the action code in \nAlbumController::deleteAction()\n:\n\n\n// module/Album/src/Album/Controller/AlbumController.php:\n//...\n    // Add content to the following method:\n    public function deleteAction()\n    {\n        $id = (int) $this->params()->fromRoute('id', 0);\n        if (!$id) {\n            return $this->redirect()->toRoute('album');\n        }\n\n        $request = $this->getRequest();\n        if ($request->isPost()) {\n            $del = $request->getPost('del', 'No');\n\n            if ($del == 'Yes') {\n                $id = (int) $request->getPost('id');\n                $this->table->deleteAlbum($id);\n            }\n\n            // Redirect to list of albums\n            return $this->redirect()->toRoute('album');\n        }\n\n        return [\n            'id'    => $id,\n            'album' => $this->table->getAlbum($id),\n        ];\n    }\n//...\n\n\n\nAs before, we get the \nid\n from the matched route, and check the request object's \nisPost()\n to determine whether to show the confirmation page or to delete the album. We use the table object to delete the row using the \ndeleteAlbum()\n method and then redirect back the list of albums. If the request is not a POST, then we retrieve the correct database record and assign to the view, along with the \nid\n.\n\n\nThe view script is a simple form:\n\n\n<?php\n// module/Album/view/album/album/delete.phtml:\n\n$title = 'Delete album';\n$url   = $this->url('album', ['action' => 'delete', 'id' => $id]);\n\n$this->headTitle($title);\n?>\n<h1><?= $this->escapeHtml($title) ?></h1>\n\n<p>\n    Are you sure that you want to delete\n    \"<?= $this->escapeHtml($album->title) ?>\" by\n    \"<?= $this->escapeHtml($album->artist) ?>\"?\n</p>\n\n<form action=\"<?= $url ?>\" method=\"post\">\n<div class=\"form-group\">\n    <input type=\"hidden\" name=\"id\" value=\"<?= (int) $album->id ?>\" />\n    <input type=\"submit\" class=\"btn btn-danger\" name=\"del\" value=\"Yes\" />\n    <input type=\"submit\" class=\"btn btn-success\" name=\"del\" value=\"No\" />\n</div>\n</form>\n\n\n\nIn this script, we display a confirmation message to the user and then a form\nwith \"Yes\" and \"No\" buttons. In the action, we checked specifically for the\n\"Yes\" value when doing the deletion.\n\n\nEnsuring that the home page displays the list of albums\n\n\nOne final point. At the moment, the home page, \nhttp://zf-tutorial.localhost/\n\ndoesn't display the list of albums.\n\n\nThis is due to a route set up in the \nApplication\n module's \nmodule.config.php\n.\nTo change it, open \nmodule/Application/config/module.config.php\n and find the\nhome route:\n\n\n'home' => [\n    'type' => \\Zend\\Router\\Http\\Literal::class,\n    'options' => [\n        'route'    => '/',\n        'defaults' => [\n            'controller' => Controller\\IndexController::class,\n            'action'     => 'index',\n        ],\n    ],\n],\n\n\n\nImport \nAlbum\\Controller\\AlbumController\n at the top of the file:\n\n\nuse Album\\Controller\\AlbumController;\n\n\n\nand change the \ncontroller\n from \nController\\IndexController::class\n to \nAlbumController::class\n:\n\n\n'home' => [\n    'type' => \\Zend\\Router\\Http\\Literal::class,\n    'options' => [\n        'route'    => '/',\n        'defaults' => [\n            'controller' => AlbumController::class, // <-- change here\n            'action'     => 'index',\n        ],\n    ],\n],\n\n\n\nThat's it \u2014 you now have a fully working application!",
            "title": "Formul\u00e1rios e Actions"
        },
        {
            "location": "/getting-started/forms-and-actions/#forms-and-actions",
            "text": "",
            "title": "Forms and actions"
        },
        {
            "location": "/getting-started/forms-and-actions/#adding-new-albums",
            "text": "We can now code up the functionality to add new albums. There are two bits to this part:   Display a form for user to provide details.  Process the form submission and store to database.   We will use zend-form to do this. zend-form manages the various form inputs as\nwell as their validation, the latter of which is handled by the zend-inputfilter\ncomponent. We'll start by creating a new class,  Album\\Form\\AlbumForm ,\nextending from  Zend\\Form\\Form . Create the file module/Album/src/Form/AlbumForm.php  with the following contents:  namespace Album\\Form;\n\nuse Zend\\Form\\Form;\n\nclass AlbumForm extends Form\n{\n    public function __construct($name = null)\n    {\n        // We will ignore the name provided to the constructor\n        parent::__construct('album');\n\n        $this->add([\n            'name' => 'id',\n            'type' => 'hidden',\n        ]);\n        $this->add([\n            'name' => 'title',\n            'type' => 'text',\n            'options' => [\n                'label' => 'Title',\n            ],\n        ]);\n        $this->add([\n            'name' => 'artist',\n            'type' => 'text',\n            'options' => [\n                'label' => 'Artist',\n            ],\n        ]);\n        $this->add([\n            'name' => 'submit',\n            'type' => 'submit',\n            'attributes' => [\n                'value' => 'Go',\n                'id'    => 'submitbutton',\n            ],\n        ]);\n    }\n}  Within the constructor of  AlbumForm  we do several things. First, we set the\nname of the form as we call the parent's constructor. The, we create four form\nelements: the id, title, artist, and submit button. For each item we set various\nattributes and options, including the label to be displayed.",
            "title": "Adding new albums"
        },
        {
            "location": "/getting-started/forms-and-actions/#form-method",
            "text": "HTML forms can be sent using  POST  and  GET . zend-form defaults to  POST ;\ntherefore you don't have to be explicit in setting this option. If you want to\nchange it to  GET  however, set the method attribute in the constructor:  $this->setAttribute('method', 'GET');   We also need to set up validation for this form.   zend-inputfilter \nprovides a general purpose mechanism for input validation. It also provides an\ninterface,  InputFilterAwareInterface , which zend-form will use in order to\nbind an input filter to a given form. We'll add this capability now to our Album  class.  // module/Album/src/Model/Album.php:\nnamespace Album\\Model;\n\n// Add the following import statements:\nuse DomainException;\nuse Zend\\Filter\\StringTrim;\nuse Zend\\Filter\\StripTags;\nuse Zend\\Filter\\ToInt;\nuse Zend\\InputFilter\\InputFilter;\nuse Zend\\InputFilter\\InputFilterAwareInterface;\nuse Zend\\InputFilter\\InputFilterInterface;\nuse Zend\\Validator\\StringLength;\n\nclass Album implements InputFilterAwareInterface\n{\n    public $id;\n    public $artist;\n    public $title;\n\n    // Add this property:\n    private $inputFilter;\n\n    public function exchangeArray(array $data)\n    {\n        $this->id     = !empty($data['id']) ? $data['id'] : null;\n        $this->artist = !empty($data['artist']) ? $data['artist'] : null;\n        $this->title  = !empty($data['title']) ? $data['title'] : null;\n    }\n\n    /* Add the following methods: */\n\n    public function setInputFilter(InputFilterInterface $inputFilter)\n    {\n        throw new DomainException(sprintf(\n            '%s does not allow injection of an alternate input filter',\n            __CLASS__\n        ));\n    }\n\n    public function getInputFilter()\n    {\n        if ($this->inputFilter) {\n            return $this->inputFilter;\n        }\n\n        $inputFilter = new InputFilter();\n\n        $inputFilter->add([\n            'name' => 'id',\n            'required' => true,\n            'filters' => [\n                ['name' => ToInt::class],\n            ],\n        ]);\n\n        $inputFilter->add([\n            'name' => 'artist',\n            'required' => true,\n            'filters' => [\n                ['name' => StripTags::class],\n                ['name' => StringTrim::class],\n            ],\n            'validators' => [\n                [\n                    'name' => StringLength::class,\n                    'options' => [\n                        'encoding' => 'UTF-8',\n                        'min' => 1,\n                        'max' => 100,\n                    ],\n                ],\n            ],\n        ]);\n\n        $inputFilter->add([\n            'name' => 'title',\n            'required' => true,\n            'filters' => [\n                ['name' => StripTags::class],\n                ['name' => StringTrim::class],\n            ],\n            'validators' => [\n                [\n                    'name' => StringLength::class,\n                    'options' => [\n                        'encoding' => 'UTF-8',\n                        'min' => 1,\n                        'max' => 100,\n                    ],\n                ],\n            ],\n        ]);\n\n        $this->inputFilter = $inputFilter;\n        return $this->inputFilter;\n    }\n}  The  InputFilterAwareInterface  defines two methods:  setInputFilter()  and getInputFilter() . We only need to implement  getInputFilter()  so we\nthrow an exception from  setInputFilter() .  Within  getInputFilter() , we instantiate an  InputFilter  and then add the\ninputs that we require. We add one input for each property that we wish to\nfilter or validate. For the  id  field we add an  int  filter as we only need\nintegers. For the text elements, we add two filters,  StripTags  and StringTrim , to remove unwanted HTML and unnecessary white space. We also set\nthem to be  required  and add a  StringLength  validator to ensure that the user\ndoesn't enter more characters than we can store into the database.  We now need to get the form to display and then process it on submission. This\nis done within the  AlbumController::addAction() :  // module/Album/src/Controller/AlbumController.php:\n\n// Add the following import statements at the top of the file:\nuse Album\\Form\\AlbumForm;\nuse Album\\Model\\Album;\n\nclass AlbumController extends AbstractActionController\n{\n    /* ... */\n\n    /* Update the following method to read as follows: */\n    public function addAction()\n    {\n        $form = new AlbumForm();\n        $form->get('submit')->setValue('Add');\n\n        $request = $this->getRequest();\n\n        if (! $request->isPost()) {\n            return ['form' => $form];\n        }\n\n        $album = new Album();\n        $form->setInputFilter($album->getInputFilter());\n        $form->setData($request->getPost());\n\n        if (! $form->isValid()) {\n            return ['form' => $form];\n        }\n\n        $album->exchangeArray($form->getData());\n        $this->table->saveAlbum($album);\n        return $this->redirect()->toRoute('album');\n    }\n\n    /* ... */\n}  After adding the  Album  and  AlbumForm  classes to the import list, we\nimplement  addAction() . Let's look at the  addAction()  code in a little more\ndetail:  $form = new AlbumForm();\n$form->get('submit')->setValue('Add');  We instantiate  AlbumForm  and set the label on the submit button to \"Add\". We\ndo this here as we'll want to re-use the form when editing an album and will use\na different label.  $request = $this->getRequest();\n\nif (! $request->isPost()) {\n    return ['form' => $form];\n}  If the request is not a  POST  request, then no form data has been submitted,\nand we need to display the form. zend-mvc allows you to return an array of data\ninstead of a view model if desired; if you do, the array will be used to create\na view model.  $album = new Album();\n$form->setInputFilter($album->getInputFilter());\n$form->setData($request->getPost());  At this point, we know we have a form submission. We create an  Album  instance,\nand pass its input filter on to the form; additionally, we pass the submitted\ndata from the request instance to the form.  if (! $form->isValid()) {\n    return ['form' => $form];\n}  If form validation fails, we want to redisplay the form. At this point, the form\ncontains information about what fields failed validation, and why, and this\ninformation will be communicated to the view layer.  $album->exchangeArray($form->getData());\n$this->table->saveAlbum($album);  If the form is valid, then we grab the data from the form and store to the model\nusing  saveAlbum() .  return $this->redirect()->toRoute('album');  After we have saved the new album row, we redirect back to the list of albums\nusing the  Redirect  controller plugin.  We now need to render the form in the  add.phtml  view script:  <?php\n// module/Album/view/album/album/add.phtml:\n\n$title = 'Add new album';\n$this->headTitle($title);\n?>\n<h1><?= $this->escapeHtml($title) ?></h1>\n<?php\n$form->setAttribute('action', $this->url('album', ['action' => 'add']));\n$form->prepare();\n\necho $this->form()->openTag($form);\necho $this->formHidden($form->get('id'));\necho $this->formRow($form->get('title'));\necho $this->formRow($form->get('artist'));\necho $this->formSubmit($form->get('submit'));\necho $this->form()->closeTag();  We display a title as before, and then we render the form. zend-form provides\nseveral view helpers to make this a little easier. The  form()  view helper has\nan  openTag()  and  closeTag()  method which we use to open and close the form.\nThen for each element with a label, we can use  formRow()  to render the label,\ninput, and any validation error messages; for the two elements that are\nstandalone and have no validation rules, we use  formHidden()  and formSubmit() .  Alternatively, the process of rendering the form can be simplified by using the\nbundled  formCollection  view helper. For example, in the view script above\nreplace all the form-rendering echo statements with:  echo $this->formCollection($form);  This will iterate over the form structure, calling the appropriate label,\nelement, and error view helpers for each element, but you still have to wrap formCollection($form)  with the open and close form tags. This helps reduce the\ncomplexity of your view script in situations where the default HTML rendering of\nthe form is acceptable.  You should now be able to use the \"Add new album\" link on the home page of the\napplication to add a new album record, resulting in something like the\nfollowing:   This doesn't look all that great! The reason is because Bootstrap, the CSS\nfoundation used in the skeleton, has specialized markup for displaying forms! We\ncan address that in our view script by:   Adding markup around the elements.  Rendering labels, elements, and error messages separately.  Adding attributes to elements.   Update your  add.phtml  view script to read as follows:  <?php\n$title = 'Add new album';\n$this->headTitle($title);\n?>\n<h1><?= $this->escapeHtml($title) ?></h1>\n<?php\n// This provides a default CSS class and placeholder text for the title element:\n$album = $form->get('title');\n$album->setAttribute('class', 'form-control');\n$album->setAttribute('placeholder', 'Album title');\n\n// This provides a default CSS class and placeholder text for the artist element:\n$artist = $form->get('artist');\n$artist->setAttribute('class', 'form-control');\n$artist->setAttribute('placeholder', 'Artist');\n\n// This provides CSS classes for the submit button:\n$submit = $form->get('submit');\n$submit->setAttribute('class', 'btn btn-primary');\n\n$form->setAttribute('action', $this->url('album', ['action' => 'add']));\n$form->prepare();\n\necho $this->form()->openTag($form);\n?>\n<?php // Wrap the elements in divs marked as form groups, and render the\n      // label, element, and errors separately within ?>\n<div class=\"form-group\">\n    <?= $this->formLabel($album) ?>\n    <?= $this->formElement($album) ?>\n    <?= $this->formElementErrors()->render($album, ['class' => 'help-block']) ?>\n</div>\n\n<div class=\"form-group\">\n    <?= $this->formLabel($artist) ?>\n    <?= $this->formElement($artist) ?>\n    <?= $this->formElementErrors()->render($artist, ['class' => 'help-block']) ?>\n</div>\n\n<?php\necho $this->formSubmit($submit);\necho $this->formHidden($form->get('id'));\necho $this->form()->closeTag();  The results we get are much better:   The above is meant to demonstrate both the ease of use of the default form\nfeatures, as well as some of the customizations possible when rendering forms.\nYou should be able to generate any markup necessary for your site.",
            "title": "Form method"
        },
        {
            "location": "/getting-started/forms-and-actions/#editing-an-album",
            "text": "Editing an album is almost identical to adding one, so the code is very similar.\nThis time we use  editAction()  in the  AlbumController :  // module/Album/src/Controller/AlbumController.php:\n// ...\n\n    public function editAction()\n    {\n        $id = (int) $this->params()->fromRoute('id', 0);\n\n        if (0 === $id) {\n            return $this->redirect()->toRoute('album', ['action' => 'add']);\n        }\n\n        // Retrieve the album with the specified id. Doing so raises\n        // an exception if the album is not found, which should result\n        // in redirecting to the landing page.\n        try {\n            $album = $this->table->getAlbum($id);\n        } catch (\\Exception $e) {\n            return $this->redirect()->toRoute('album', ['action' => 'index']);\n        }\n\n        $form = new AlbumForm();\n        $form->bind($album);\n        $form->get('submit')->setAttribute('value', 'Edit');\n\n        $request = $this->getRequest();\n        $viewData = ['id' => $id, 'form' => $form];\n\n        if (! $request->isPost()) {\n            return $viewData;\n        }\n\n        $form->setInputFilter($album->getInputFilter());\n        $form->setData($request->getPost());\n\n        if (! $form->isValid()) {\n            return $viewData;\n        }\n\n        $this->table->saveAlbum($album);\n\n        // Redirect to album list\n        return $this->redirect()->toRoute('album', ['action' => 'index']);\n    }  This code should look comfortably familiar. Let's look at the differences from\nadding an album. Firstly, we look for the  id  that is in the matched route and\nuse it to load the album to be edited:  $id = (int) $this->params()->fromRoute('id', 0);\n\nif (0 === $id) {\n    return $this->redirect()->toRoute('album', ['action' => 'add']);\n}\n\n// Retrieve the album with the specified id. Doing so raises\n// an exception if the album is not found, which should result\n// in redirecting to the landing page.\ntry {\n    $album = $this->table->getAlbum($id);\n} catch (\\Exception $e) {\n    return $this->redirect()->toRoute('album', ['action' => 'index']);\n}  params  is a controller plugin that provides a convenient way to retrieve\nparameters from the matched route. We use it to retrieve the  id  from the route\nwe created within the Album module's  module.config.php . If the  id  is zero,\nthen we redirect to the add action, otherwise, we continue by getting the album\nentity from the database.  We have to check to make sure that the album with the specified  id  can\nactually be found. If it cannot, then the data access method throws an\nexception. We catch that exception and re-route the user to the index page.  $form = new AlbumForm();\n$form->bind($album);\n$form->get('submit')->setAttribute('value', 'Edit');  The form's  bind()  method attaches the model to the form. This is used in two ways:   When displaying the form, the initial values for each element are extracted\n  from the model.  After successful validation in  isValid() , the data from the form is put back\n  into the model.   These operations are done using a  hydrator  object. There are a number of\nhydrators, but the default one is  Zend\\Hydrator\\ArraySerializable  which\nexpects to find two methods in the model:  getArrayCopy()  and exchangeArray() . We have already written  exchangeArray()  in our  Album \nentity, so we now need to write  getArrayCopy() :  // module/Album/src/Model/Album.php:\n// ...\n\n    public function exchangeArray($data)\n    {\n        $this->id     = isset($data['id']) ? $data['id'] : null;\n        $this->artist = isset($data['artist']) ? $data['artist'] : null;\n        $this->title  = isset($data['title']) ? $data['title'] : null;\n    }\n\n    // Add the following method:\n    public function getArrayCopy()\n    {\n        return [\n            'id'     => $this->id,\n            'artist' => $this->artist,\n            'title'  => $this->title,\n        ];\n    }\n\n// ...  As a result of using  bind()  with its hydrator, we do not need to populate the\nform's data back into the  $album  as that's already been done, so we can just\ncall the mapper's  saveAlbum()  method to store the changes back to the\ndatabase.  The view template,  edit.phtml , looks very similar to the one for adding an album:  <?php\n// module/Album/view/album/album/edit.phtml:\n\n$title = 'Edit album';\n$this->headTitle($title);\n?>\n<h1><?= $this->escapeHtml($title) ?></h1>\n<?php\n$album = $form->get('title');\n$album->setAttribute('class', 'form-control');\n$album->setAttribute('placeholder', 'Album title');\n\n$artist = $form->get('artist');\n$artist->setAttribute('class', 'form-control');\n$artist->setAttribute('placeholder', 'Artist');\n\n$submit = $form->get('submit');\n$submit->setAttribute('class', 'btn btn-primary');\n\n$form->setAttribute('action', $this->url('album', [\n    'action' => 'edit',\n    'id'     => $id,\n]));\n$form->prepare();\n\necho $this->form()->openTag($form);\n?>\n<div class=\"form-group\">\n    <?= $this->formLabel($album) ?>\n    <?= $this->formElement($album) ?>\n    <?= $this->formElementErrors()->render($album, ['class' => 'help-block']) ?>\n</div>\n\n<div class=\"form-group\">\n    <?= $this->formLabel($artist) ?>\n    <?= $this->formElement($artist) ?>\n    <?= $this->formElementErrors()->render($artist, ['class' => 'help-block']) ?>\n</div>\n\n<?php\necho $this->formSubmit($submit);\necho $this->formHidden($form->get('id'));\necho $this->form()->closeTag();  The only changes are to use the \u2018Edit Album' title and set the form's action to\nthe 'edit' action too, using the current album identifier.  You should now be able to edit albums.",
            "title": "Editing an album"
        },
        {
            "location": "/getting-started/forms-and-actions/#deleting-an-album",
            "text": "To round out our application, we need to add deletion. We have a \"Delete\" link\nnext to each album on our list page, and the naive approach would be to do a\ndelete when it's clicked. This would be wrong. Remembering our HTTP spec, we\nrecall that you shouldn't do an irreversible action using GET and should use\nPOST instead.  We shall show a confirmation form when the user clicks delete, and if they then\nclick \"yes\", we will do the deletion. As the form is trivial, we'll code it\ndirectly into our view (zend-form is, after all, optional!).  Let's start with the action code in  AlbumController::deleteAction() :  // module/Album/src/Album/Controller/AlbumController.php:\n//...\n    // Add content to the following method:\n    public function deleteAction()\n    {\n        $id = (int) $this->params()->fromRoute('id', 0);\n        if (!$id) {\n            return $this->redirect()->toRoute('album');\n        }\n\n        $request = $this->getRequest();\n        if ($request->isPost()) {\n            $del = $request->getPost('del', 'No');\n\n            if ($del == 'Yes') {\n                $id = (int) $request->getPost('id');\n                $this->table->deleteAlbum($id);\n            }\n\n            // Redirect to list of albums\n            return $this->redirect()->toRoute('album');\n        }\n\n        return [\n            'id'    => $id,\n            'album' => $this->table->getAlbum($id),\n        ];\n    }\n//...  As before, we get the  id  from the matched route, and check the request object's  isPost()  to determine whether to show the confirmation page or to delete the album. We use the table object to delete the row using the  deleteAlbum()  method and then redirect back the list of albums. If the request is not a POST, then we retrieve the correct database record and assign to the view, along with the  id .  The view script is a simple form:  <?php\n// module/Album/view/album/album/delete.phtml:\n\n$title = 'Delete album';\n$url   = $this->url('album', ['action' => 'delete', 'id' => $id]);\n\n$this->headTitle($title);\n?>\n<h1><?= $this->escapeHtml($title) ?></h1>\n\n<p>\n    Are you sure that you want to delete\n    \"<?= $this->escapeHtml($album->title) ?>\" by\n    \"<?= $this->escapeHtml($album->artist) ?>\"?\n</p>\n\n<form action=\"<?= $url ?>\" method=\"post\">\n<div class=\"form-group\">\n    <input type=\"hidden\" name=\"id\" value=\"<?= (int) $album->id ?>\" />\n    <input type=\"submit\" class=\"btn btn-danger\" name=\"del\" value=\"Yes\" />\n    <input type=\"submit\" class=\"btn btn-success\" name=\"del\" value=\"No\" />\n</div>\n</form>  In this script, we display a confirmation message to the user and then a form\nwith \"Yes\" and \"No\" buttons. In the action, we checked specifically for the\n\"Yes\" value when doing the deletion.",
            "title": "Deleting an album"
        },
        {
            "location": "/getting-started/forms-and-actions/#ensuring-that-the-home-page-displays-the-list-of-albums",
            "text": "One final point. At the moment, the home page,  http://zf-tutorial.localhost/ \ndoesn't display the list of albums.  This is due to a route set up in the  Application  module's  module.config.php .\nTo change it, open  module/Application/config/module.config.php  and find the\nhome route:  'home' => [\n    'type' => \\Zend\\Router\\Http\\Literal::class,\n    'options' => [\n        'route'    => '/',\n        'defaults' => [\n            'controller' => Controller\\IndexController::class,\n            'action'     => 'index',\n        ],\n    ],\n],  Import  Album\\Controller\\AlbumController  at the top of the file:  use Album\\Controller\\AlbumController;  and change the  controller  from  Controller\\IndexController::class  to  AlbumController::class :  'home' => [\n    'type' => \\Zend\\Router\\Http\\Literal::class,\n    'options' => [\n        'route'    => '/',\n        'defaults' => [\n            'controller' => AlbumController::class, // <-- change here\n            'action'     => 'index',\n        ],\n    ],\n],  That's it \u2014 you now have a fully working application!",
            "title": "Ensuring that the home page displays the list of albums"
        },
        {
            "location": "/getting-started/conclusion/",
            "text": "Conclusion\n\n\nThis concludes our brief look at building a simple, but fully functional,\nZend Framework zend-mvc application.\n\n\nIn this tutorial we but briefly touched quite a number of different parts of the\nframework.\n\n\nThe most important part of applications built with zend-mvc are the\n\nmodules\n, the\nbuilding blocks of any \nzend-mvc application\n.\n\n\nTo ease the work with dependencies inside our applications, we use the\n\nservice manager\n.\n\n\nTo be able to map a request to controllers and their actions, we use\n\nroutes\n.\n\n\nData persistence was performed using\n\nzend-db\n to communicate with\na relational database. Input data is filtered and validated with \ninput\nfilters\n,\nand, together with \nzend-form\n,\nthey provide a strong bridge between the domain model and the view layer.\n\n\nzend-view\n is\nresponsible for the View in the MVC stack, together with a vast amount of\n\nview helpers\n.",
            "title": "Conclus\u00e3o"
        },
        {
            "location": "/getting-started/conclusion/#conclusion",
            "text": "This concludes our brief look at building a simple, but fully functional,\nZend Framework zend-mvc application.  In this tutorial we but briefly touched quite a number of different parts of the\nframework.  The most important part of applications built with zend-mvc are the modules , the\nbuilding blocks of any  zend-mvc application .  To ease the work with dependencies inside our applications, we use the service manager .  To be able to map a request to controllers and their actions, we use routes .  Data persistence was performed using zend-db  to communicate with\na relational database. Input data is filtered and validated with  input\nfilters ,\nand, together with  zend-form ,\nthey provide a strong bridge between the domain model and the view layer.  zend-view  is\nresponsible for the View in the MVC stack, together with a vast amount of view helpers .",
            "title": "Conclusion"
        },
        {
            "location": "/unit-testing/",
            "text": "Unit Testing a zend-mvc application\n\n\nA solid unit test suite is essential for ongoing development in large projects,\nespecially those with many people involved. Going back and manually testing\nevery individual component of an application after every change is impractical.\nYour unit tests will help alleviate that by automatically testing your\napplication's components and alerting you when something is not working the same\nway it was when you wrote your tests.\n\n\nThis tutorial is written in the hopes of showing how to test different parts of\na zend-mvc application. As such, this tutorial will use the application written\nin the \ngetting started user guide\n. It is in no way a\nguide to unit testing in general, but is here only to help overcome the initial\nhurdles in writing unit tests for zend-mvc applications.\n\n\nIt is recommended to have at least a basic understanding of unit tests,\nassertions and mocks.\n\n\nzend-test\n, which provides testing\nintegration for zend-mvc, uses \nPHPUnit\n; this tutorial will\ncover using that library for testing your applications.\n\n\nInstalling zend-test\n\n\nzend-test\n provides PHPUnit\nintegration for zend-mvc, including application scaffolding and custom\nassertions. You will need to install it:\n\n\n$ composer require --dev zendframework/zend-test\n\n\n\nThe above command will update your \ncomposer.json\n file and perform an update\nfor you, which will also setup autoloading rules.\n\n\nRunning the initial tests\n\n\nOut-of-the-box, the skeleton application provides several tests for the shipped\n\nApplication\\Controller\\IndexController\n class. Now that you have zend-test\ninstalled, you can run these:\n\n\n$ ./vendor/bin/phpunit\n\n\n\n\n\nPHPUnit invocation on Windows\n\n\nOn Windows, you need to wrap the command in double quotes:\n\n\n$ \"vendor/bin/phpunit\"\n\n\n\n\n\nYou should see output similar to the following:\n\n\nPHPUnit 5.4.6 by Sebastian Bergmann and contributors.\n\n...                                                                 3 / 3 (100%)\n\nTime: 116 ms, Memory: 11.00MB\n\nOK (3 tests, 7 assertions)\n\n\n\nThere might be 2 failing tests if you followed the getting started guide. This\nis because the \nApplication\\IndexController\n is overridden by the\n\nAlbumController\n. This can be ignored for now.\n\n\nNow it's time to write our own tests!\n\n\nSetting up the tests directory\n\n\nAs zend-mvc applications are built from modules that should be\nstandalone blocks of an application, we don't test the application in it's\nentirety, but module by module.\n\n\nWe will demonstrate setting up the minimum requirements to test a module, the\n\nAlbum\n module we wrote in the user guide, which then can be used as a base\nfor testing any other module.\n\n\nStart by creating a directory called \ntest\n under \nmodule/Album/\n with\nthe following subdirectories:\n\n\nmodule/\n    Album/\n        test/\n            Controller/\n\n\n\nAdditionally, add an \nautoload-dev\n rule in your \ncomposer.json\n:\n\n\n\"autoload-dev\": {\n    \"psr-4\": {\n        \"ApplicationTest\\\\\": \"module/Application/test/\",\n        \"AlbumTest\\\\\": \"module/Album/test/\"\n    }\n}\n\n\n\nWhen done, run:\n\n\n$ composer dump-autoload\n\n\n\nThe structure of the \ntest\n directory matches exactly with that of the module's\nsource files, and it will allow you to keep your tests well-organized and easy\nto find.\n\n\nBootstrapping your tests\n\n\nNext, edit the \nphpunit.xml.dist\n file at the project root; we'll add a new\ntest suite to it. When done, it should read as follows:\n\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<phpunit colors=\"true\">\n    <testsuites>\n        <testsuite name=\"ZendSkeletonApplication Test Suite\">\n            <directory>./module/Application/test</directory>\n        </testsuite>\n        <testsuite name=\"Album\">\n            <directory>./module/Album/test</directory>\n        </testsuite>\n    </testsuites>\n</phpunit>\n\n\n\nNow run your new Album test suite from the project root:\n\n\n$ ./vendor/bin/phpunit --testsuite Album\n\n\n\n\n\nWindows and PHPUnit\n\n\nOn Windows, don't forget to wrap the \nphpunit\n command in double quotes:\n\n\n$ \"vendor/bin/phpunit\" --testsuite Album\n\n\n\n\n\nYou should get similar output to the following:\n\n\nPHPUnit 5.4.6 by Sebastian Bergmann and contributors.\n\nTime: 0 seconds, Memory: 1.75Mb\n\nNo tests executed!\n\n\n\nLet's write our first test!\n\n\nYour first controller test\n\n\nTesting controllers is never an easy task, but the zend-test component makes\ntesting much less cumbersome.\n\n\nFirst, create \nAlbumControllerTest.php\n under \nmodule/Album/test/Controller/\n\nwith the following contents:\n\n\n<?php\nnamespace AlbumTest\\Controller;\n\nuse Album\\Controller\\AlbumController;\nuse Zend\\Stdlib\\ArrayUtils;\nuse Zend\\Test\\PHPUnit\\Controller\\AbstractHttpControllerTestCase;\n\nclass AlbumControllerTest extends AbstractHttpControllerTestCase\n{\n    protected $traceError = false;\n\n    public function setUp()\n    {\n        // The module configuration should still be applicable for tests.\n        // You can override configuration here with test case specific values,\n        // such as sample view templates, path stacks, module_listener_options,\n        // etc.\n        $configOverrides = [];\n\n        $this->setApplicationConfig(ArrayUtils::merge(\n            // Grabbing the full application configuration:\n            include __DIR__ . '/../../../../config/application.config.php',\n            $configOverrides\n        ));\n        parent::setUp();\n    }\n}\n\n\n\nThe \nAbstractHttpControllerTestCase\n class we extend here helps us setting up\nthe application itself, helps with dispatching and other tasks that happen\nduring a request, and offers methods for asserting request params, response\nheaders, redirects, and more. See the \nzend-test\n\ndocumentation for more information.\n\n\nThe principal requirement for any zend-test test case is to set the application\nconfig with the \nsetApplicationConfig()\n method. For now, we assume the default\napplication configuration will be appropriate; however, we can override values\nlocally within the test using the \n$configOverrides\n variable.\n\n\nNow, add the following method to the \nAlbumControllerTest\n class:\n\n\npublic function testIndexActionCanBeAccessed()\n{\n    $this->dispatch('/album');\n    $this->assertResponseStatusCode(200);\n    $this->assertModuleName('Album');\n    $this->assertControllerName(AlbumController::class);\n    $this->assertControllerClass('AlbumController');\n    $this->assertMatchedRouteName('album');\n}\n\n\n\nThis test case dispatches the \n/album\n URL, asserts that the response code is\n200, and that we ended up in the desired module and controller.\n\n\n\n\nAssert against controller service names\n\n\nFor asserting the \ncontroller name\n we are using the controller name we\ndefined in our  routing configuration for the Album module. In our example\nthis should be defined on line 16 of the \nmodule.config.php\n file in the Album\nmodule.\n\n\n\n\nIf you run:\n\n\n$ ./vendor/bin/phpunit --testsuite Album\n\n\n\nagain, you should see something like the following:\n\n\nPHPUnit 5.4.6 by Sebastian Bergmann and contributors.\n\n.                                                                   1 / 1 (100%)\n\nTime: 124 ms, Memory: 11.50MB\n\nOK (1 test, 5 assertions)\n\n\n\nA successful first test!\n\n\nA failing test case\n\n\nWe likely don't want to hit the same database during testing as we use for our\nweb property. Let's add some configuration to the test case to remove the\ndatabase configuration. In your \nAlbumControllerTest::setUp()\n method, add the\nfollowing lines right after the call to \nparent::setUp();\n:\n\n\n$services = $this->getApplicationServiceLocator();\n$config = $services->get('config');\nunset($config['db']);\n$services->setAllowOverride(true);\n$services->setService('config', $config);\n$services->setAllowOverride(false);\n\n\n\nThe above removes the 'db' configuration entirely; we'll be replacing it with\nsomething else before long.\n\n\nWhen we run the tests now:\n\n\n$ ./vendor/bin/phpunit --testsuite Album\nPHPUnit 5.4.6 by Sebastian Bergmann and contributors.\n\nF\n\nTime: 0 seconds, Memory: 8.50Mb\n\nThere was 1 failure:\n\n1) AlbumTest\\Controller\\AlbumControllerTest::testIndexActionCanBeAccessed\nFailed asserting response code \"200\", actual status code is \"500\"\n\n{projectPath}/vendor/zendframework/zend-test/src/PHPUnit/Controller/AbstractControllerTestCase.php:{lineNumber}\n{projectPath}/module/Album/test/AlbumTest/Controller/AlbumControllerTest.php:{lineNumber}\n\nFAILURES!\nTests: 1, Assertions: 0, Failures: 1.\n\n\n\nThe failure message doesn't tell us much, apart from that the expected status\ncode is not 200, but 500. To get a bit more information when something goes\nwrong in a test case, we set the protected \n$traceError\n member to \ntrue\n (which\nis the default; we set it to \nfalse\n to demonstrate this capability). Modify the\nfollowing line from just above the \nsetUp\n method in our \nAlbumControllerTest\n class:\n\n\nprotected $traceError = true;\n\n\n\nRunning the \nphpunit\n command again and we should see some more information\nabout what went wrong in our test. You'll get a list of the exceptions raised,\nalong with their messages, the filename, and line number:\n\n\n1) AlbumTest\\Controller\\AlbumControllerTest::testIndexActionCanBeAccessed\nFailed asserting response code \"200\", actual status code is \"500\"\n\nExceptions raised:\nException 'Zend\\ServiceManager\\Exception\\ServiceNotCreatedException' with message 'Service with name \"Zend\\Db\\Adapter\\AdapterInterface\" could not be created. Reason: createDriver expects a \"driver\" key to be present inside the parameters' in {projectPath}/vendor/zendframework/zend-servicemanager/src/ServiceManager.php:{lineNumber}\n\nException 'Zend\\Db\\Adapter\\Exception\\InvalidArgumentException' with message 'createDriver expects a \"driver\" key to be present inside the parameters' in {projectPath}/vendor/zendframework/zend-db/src/Adapter/Adapter.php:{lineNumber}\n\n\n\nBased on the exception messages, it appears we are unable to create a zend-db\nadapter instance, due to missing configuration!\n\n\nConfiguring the service manager for the tests\n\n\nThe error says that the service manager can not create an instance of a database\nadapter for us. The database adapter is indirectly used by our\n\nAlbum\\Model\\AlbumTable\n to fetch the list of albums from the database.\n\n\nThe first thought would be to create an instance of an adapter, pass it to the\nservice manager, and let the code run from there as is. The problem with this\napproach is that we would end up with our test cases actually doing queries\nagainst the database. To keep our tests fast, and to reduce the number of\npossible failure points in our tests, this should be avoided.\n\n\nThe second thought would be then to create a mock of the database adapter, and\nprevent the actual database calls by mocking them out. This is a much better\napproach, but creating the adapter mock is tedious (but no doubt we will have to\ncreate it at some point).\n\n\nThe best thing to do would be to mock out our \nAlbum\\Model\\AlbumTable\n class\nwhich retrieves the list of albums from the database. Remember, we are now\ntesting our controller, so we can mock out the actual call to \nfetchAll\n and\nreplace the return values with dummy values. At this point, we are not\ninterested in how \nfetchAll()\n retrieves the albums, but only that it gets called\nand that it returns an array of albums; these facts allow us to provide mock\ninstances. When we test \nAlbumTable\n itself, we can write the actual tests for\nthe \nfetchAll\n method.\n\n\nFirst, let's do some setup.\n\n\nAdd import statements to the top of the test class file for each of the\n\nAlbumTable\n and \nServiceManager\n classes:\n\n\nuse Album\\Model\\AlbumTable;\nuse Zend\\ServiceManager\\ServiceManager;\n\n\n\nNow add the following property to the test class:\n\n\nprotected $albumTable;\n\n\n\nNext, we'll create three new methods that we'll invoke during setup:\n\n\nprotected function configureServiceManager(ServiceManager $services)\n{\n    $services->setAllowOverride(true);\n\n    $services->setService('config', $this->updateConfig($services->get('config')));\n    $services->setService(AlbumTable::class, $this->mockAlbumTable()->reveal());\n\n    $services->setAllowOverride(false);\n}\n\nprotected function updateConfig($config)\n{\n    $config['db'] = [];\n    return $config;\n}\n\nprotected function mockAlbumTable()\n{\n    $this->albumTable = $this->prophesize(AlbumTable::class);\n    return $this->albumTable;\n}\n\n\n\nBy default, the \nServiceManager\n does not allow us to replace existing services.\n\nconfigureServiceManager()\n calls a special method on the instance to enable\noverriding services, and then we inject specific overrides we wish to use.\nWhen done, we disable overrides to ensure that if, during dispatch, any code\nattempts to override a service, an exception will be raised.\n\n\nThe last method above creates a mock instance of our \nAlbumTable\n using\n\nProphecy\n, an object mocking framework\nthat's bundled and integrated in PHPUnit. The instance returned by\n\nprophesize()\n is a scaffold object; calling \nreveal()\n on it, as done in the\n\nconfigureServiceManager()\n method above, provides the underlying mock object\nthat will then be asserted against.\n\n\nWith this in place, we can update our \nsetUp()\n method to read as follows:\n\n\npublic function setUp()\n{\n    // The module configuration should still be applicable for tests.\n    // You can override configuration here with test case specific values,\n    // such as sample view templates, path stacks, module_listener_options,\n    // etc.\n    $configOverrides = [];\n\n    $this->setApplicationConfig(ArrayUtils::merge(\n        include __DIR__ . '/../../../../config/application.config.php',\n        $configOverrides\n    ));\n\n    parent::setUp();\n\n    $this->configureServiceManager($this->getApplicationServiceLocator());\n}\n\n\n\nNow update the \ntestIndexActionCanBeAccessed()\n method to add a line asserting\nthe \nAlbumTable\n's \nfetchAll()\n method will be called, and return an array:\n\n\npublic function testIndexActionCanBeAccessed()\n{\n    $this->albumTable->fetchAll()->willReturn([]);\n\n    $this->dispatch('/album');\n    $this->assertResponseStatusCode(200);\n    $this->assertModuleName('Album');\n    $this->assertControllerName(AlbumController::class);\n    $this->assertControllerClass('AlbumController');\n    $this->assertMatchedRouteName('album');\n}\n\n\n\nRunning \nphpunit\n at this point, we will get the following output as the tests\nnow pass:\n\n\n$ ./vendor/bin/phpunit --testsuite Album\nPHPUnit 5.4.6 by Sebastian Bergmann and contributors.\n\n.                                                                   1 / 1 (100%)\n\nTime: 105 ms, Memory: 10.75MB\n\nOK (1 test, 5 assertions)\n\n\n\nTesting actions with POST\n\n\nA common scenario with controllers is processing POST data submitted via a form,\nas we do in the \nAlbumController::addAction()\n. Let's write a test for that.\n\n\npublic function testAddActionRedirectsAfterValidPost()\n{\n    $this->albumTable\n        ->saveAlbum(Argument::type(Album::class))\n        ->shouldBeCalled();\n\n    $postData = [\n        'title'  => 'Led Zeppelin III',\n        'artist' => 'Led Zeppelin',\n        'id'     => '',\n    ];\n    $this->dispatch('/album/add', 'POST', $postData);\n    $this->assertResponseStatusCode(302);\n    $this->assertRedirectTo('/album');\n}\n\n\n\nThis test case references two new classes that we need to import; add the\nfollowing import statements at the top of the class file:\n\n\nuse Album\\Model\\Album;\nuse Prophecy\\Argument;\n\n\n\nProphecy\\Argument\n allows us to perform assertions against the values passed as\narguments to mock objects. In this case, we want to assert that we received an\n\nAlbum\n instance. (We could have also done deeper assertions to ensure the\n\nAlbum\n instance contained expected data.)\n\n\nWhen we dispatch the application this time, we use the request method POST, and\npass data to it. This test case then asserts a 302 response status, and\nintroduces a new assertion against the location to which the response redirects.\n\n\nRunning \nphpunit\n gives us the following output:\n\n\n$ ./vendor/bin/phpunit --testsuite Album\nPHPUnit 5.4.6 by Sebastian Bergmann and contributors.\n\n..                                                                  2 / 2 (100%)\n\nTime: 1.49 seconds, Memory: 13.25MB\n\nOK (2 tests, 8 assertions)\n\n\n\nTesting the \neditAction()\n and \ndeleteAction()\n methods can be performed\nsimilarly; however, when testing the \neditAction()\n method, you will also need\nto assert against the \nAlbumTable::getAlbum()\n method:\n\n\n$this->albumTable->getAlbum($id)->willReturn(new Album());\n\n\n\nIdeally, you should test all the various paths through each method. For example:\n\n\n\n\nTest that a non-POST request to \naddAction()\n displays an empty form.\n\n\nTest that a invalid data provided to \naddAction()\n re-displays the form, but\n  with error messages.\n\n\nTest that absence of an identifier in the route parameters when invoking\n  either \neditAction()\n or \ndeleteAction()\n will redirect to the appropriate\n  location.\n\n\nTest that an invalid identifier passed to \neditAction()\n will redirect to the\n  album landing page.\n\n\nTest that non-POST requests to \neditAction()\n and \ndeleteAction()\n display\n  forms.\n\n\n\n\nand so on. Doing so will help you understand the paths through your application\nand controllers, as well as ensure that changes in behavior bubble up as test\nfailures.\n\n\nTesting model entities\n\n\nNow that we know how to test our controllers, let us move to an other important\npart of our application: the model entity.\n\n\nHere we want to test that the initial state of the entity is what we expect it\nto be, that we can convert the model's parameters to and from an array, and that\nit has all the input filters we need.\n\n\nCreate the file \nAlbumTest.php\n in \nmodule/Album/test/Model\n directory\nwith the following contents:\n\n\n<?php\nnamespace AlbumTest\\Model;\n\nuse Album\\Model\\Album;\nuse PHPUnit_Framework_TestCase as TestCase;\n\nclass AlbumTest extends TestCase\n{\n    public function testInitialAlbumValuesAreNull()\n    {\n        $album = new Album();\n\n        $this->assertNull($album->artist, '\"artist\" should be null by default');\n        $this->assertNull($album->id, '\"id\" should be null by default');\n        $this->assertNull($album->title, '\"title\" should be null by default');\n    }\n\n    public function testExchangeArraySetsPropertiesCorrectly()\n    {\n        $album = new Album();\n        $data  = [\n            'artist' => 'some artist',\n            'id'     => 123,\n            'title'  => 'some title'\n        ];\n\n        $album->exchangeArray($data);\n\n        $this->assertSame(\n            $data['artist'],\n            $album->artist,\n            '\"artist\" was not set correctly'\n        );\n\n        $this->assertSame(\n            $data['id'],\n            $album->id,\n            '\"id\" was not set correctly'\n        );\n\n        $this->assertSame(\n            $data['title'],\n            $album->title,\n            '\"title\" was not set correctly'\n        );\n    }\n\n    public function testExchangeArraySetsPropertiesToNullIfKeysAreNotPresent()\n    {\n        $album = new Album();\n\n        $album->exchangeArray([\n            'artist' => 'some artist',\n            'id'     => 123,\n            'title'  => 'some title',\n        ]);\n        $album->exchangeArray([]);\n\n        $this->assertNull($album->artist, '\"artist\" should default to null');\n        $this->assertNull($album->id, '\"id\" should default to null');\n        $this->assertNull($album->title, '\"title\" should default to null');\n    }\n\n    public function testGetArrayCopyReturnsAnArrayWithPropertyValues()\n    {\n        $album = new Album();\n        $data  = [\n            'artist' => 'some artist',\n            'id'     => 123,\n            'title'  => 'some title'\n        ];\n\n        $album->exchangeArray($data);\n        $copyArray = $album->getArrayCopy();\n\n        $this->assertSame($data['artist'], $copyArray['artist'], '\"artist\" was not set correctly');\n        $this->assertSame($data['id'], $copyArray['id'], '\"id\" was not set correctly');\n        $this->assertSame($data['title'], $copyArray['title'], '\"title\" was not set correctly');\n    }\n\n    public function testInputFiltersAreSetCorrectly()\n    {\n        $album = new Album();\n\n        $inputFilter = $album->getInputFilter();\n\n        $this->assertSame(3, $inputFilter->count());\n        $this->assertTrue($inputFilter->has('artist'));\n        $this->assertTrue($inputFilter->has('id'));\n        $this->assertTrue($inputFilter->has('title'));\n    }\n}\n\n\n\nWe are testing for 5 things:\n\n\n\n\nAre all of the \nAlbum\n's properties initially set to \nNULL\n?\n\n\nWill the \nAlbum\n's properties be set correctly when we call \nexchangeArray()\n?\n\n\nWill a default value of \nNULL\n be used for properties whose keys are not present in the \n$data\n array?\n\n\nCan we get an array copy of our model?\n\n\nDo all elements have input filters present?\n\n\n\n\nIf we run \nphpunit\n again, we will get the following output, confirming that our\nmodel is indeed correct:\n\n\n$ ./vendor/bin/phpunit --testsuite Album\nPHPUnit 5.4.6 by Sebastian Bergmann and contributors.\n\n.......                                                             7 / 7 (100%)\n\nTime: 186 ms, Memory: 13.75MB\n\nOK (7 tests, 24 assertions)\n\n\n\nTesting model tables\n\n\nThe final step in this unit testing tutorial for zend-mvc applications is\nwriting tests for our model tables.\n\n\nThis test assures that we can get a list of albums, or one album by its ID, and\nthat we can save and delete albums from the database.\n\n\nTo avoid actual interaction with the database itself, we will replace certain\nparts with mocks.\n\n\nCreate a file \nAlbumTableTest.php\n in \nmodule/Album/test/Model/\n with the\nfollowing contents:\n\n\n<?php\nnamespace AlbumTest\\Model;\n\nuse Album\\Model\\AlbumTable;\nuse Album\\Model\\Album;\nuse PHPUnit_Framework_TestCase as TestCase;\nuse RuntimeException;\nuse Zend\\Db\\ResultSet\\ResultSetInterface;\nuse Zend\\Db\\TableGateway\\TableGatewayInterface;\n\nclass AlbumTableTest extends TestCase\n{\n    protected function setUp()\n    {\n        $this->tableGateway = $this->prophesize(TableGatewayInterface::class);\n        $this->albumTable = new AlbumTable($this->tableGateway->reveal());\n    }\n\n    public function testFetchAllReturnsAllAlbums()\n    {\n        $resultSet = $this->prophesize(ResultSetInterface::class)->reveal();\n        $this->tableGateway->select()->willReturn($resultSet);\n\n        $this->assertSame($resultSet, $this->albumTable->fetchAll());\n    }\n}\n\n\n\nSince we are testing the \nAlbumTable\n here and not the \nTableGateway\n class\n(which has already been tested in zend-db), we only want to make sure\nthat our \nAlbumTable\n class is interacting with the \nTableGateway\n class the way\nthat we expect it to. Above, we're testing to see if the \nfetchAll()\n method of\n\nAlbumTable\n will call the \nselect()\n method of the \n$tableGateway\n property\nwith no parameters. If it does, it should return a \nResultSet\n instance. Finally,\nwe expect that this same \nResultSet\n object will be returned to the calling\nmethod. This test should run fine, so now we can add the rest of the test\nmethods:\n\n\npublic function testCanDeleteAnAlbumByItsId()\n{\n    $this->tableGateway->delete(['id' => 123])->shouldBeCalled();\n    $this->albumTable->deleteAlbum(123);\n}\n\npublic function testSaveAlbumWillInsertNewAlbumsIfTheyDontAlreadyHaveAnId()\n{\n    $albumData = [\n        'artist' => 'The Military Wives',\n        'title'  => 'In My Dreams'\n    ];\n    $album = new Album();\n    $album->exchangeArray($albumData);\n\n    $this->tableGateway->insert($albumData)->shouldBeCalled();\n    $this->albumTable->saveAlbum($album);\n}\n\npublic function testSaveAlbumWillUpdateExistingAlbumsIfTheyAlreadyHaveAnId()\n{\n    $albumData = [\n        'id'     => 123,\n        'artist' => 'The Military Wives',\n        'title'  => 'In My Dreams',\n    ];\n    $album = new Album();\n    $album->exchangeArray($albumData);\n\n    $resultSet = $this->prophesize(ResultSetInterface::class);\n    $resultSet->current()->willReturn($album);\n\n    $this->tableGateway\n        ->select(['id' => 123])\n        ->willReturn($resultSet->reveal());\n    $this->tableGateway\n        ->update(\n            array_filter($albumData, function ($key) {\n                return in_array($key, ['artist', 'title']);\n            }, ARRAY_FILTER_USE_KEY),\n            ['id' => 123]\n        )->shouldBeCalled();\n\n    $this->albumTable->saveAlbum($album);\n}\n\npublic function testExceptionIsThrownWhenGettingNonExistentAlbum()\n{\n    $resultSet = $this->prophesize(ResultSetInterface::class);\n    $resultSet->current()->willReturn(null);\n\n    $this->tableGateway\n        ->select(['id' => 123])\n        ->willReturn($resultSet->reveal());\n\n    $this->setExpectedException(\n        RuntimeException::class,\n        'Could not find row with identifier 123'\n    );\n    $this->albumTable->getAlbum(123);\n}\n\n\n\nThese tests are nothing complicated and should be self explanatory. In each\ntest, we add assertions to our mock table gateway, and then call and assert\nagainst methods in our \nAlbumTable\n.\n\n\nWe are testing that:\n\n\n\n\nWe can retrieve an individual album by its ID.\n\n\nWe can delete albums.\n\n\nWe can save a new album.\n\n\nWe can update existing albums.\n\n\nWe will encounter an exception if we're trying to retrieve an album that\n   doesn't exist.\n\n\n\n\nRunning \nphpunit\n one last time, we get the output as follows:\n\n\n$ ./vendor/bin/phpunit --testsuite Album\nPHPUnit 5.4.6 by Sebastian Bergmann and contributors.\n\n.............                                                     13 / 13 (100%)\n\nTime: 151 ms, Memory: 14.00MB\n\nOK (13 tests, 31 assertions)\n\n\n\nConclusion\n\n\nIn this short tutorial, we gave a few examples how different parts of a zend-mvc\napplication can be tested. We covered setting up the environment for testing,\nhow to test controllers and actions, how to approach failing test cases, how to\nconfigure the service manager, as well as how to test model entities and model\ntables.\n\n\nThis tutorial is by no means a definitive guide to writing unit tests, just a\nsmall stepping stone helping you develop applications of higher quality.",
            "title": "Realizando Testes Unit\u00e1rios em uma Aplica\u00e7\u00e3o zend-mvc"
        },
        {
            "location": "/unit-testing/#unit-testing-a-zend-mvc-application",
            "text": "A solid unit test suite is essential for ongoing development in large projects,\nespecially those with many people involved. Going back and manually testing\nevery individual component of an application after every change is impractical.\nYour unit tests will help alleviate that by automatically testing your\napplication's components and alerting you when something is not working the same\nway it was when you wrote your tests.  This tutorial is written in the hopes of showing how to test different parts of\na zend-mvc application. As such, this tutorial will use the application written\nin the  getting started user guide . It is in no way a\nguide to unit testing in general, but is here only to help overcome the initial\nhurdles in writing unit tests for zend-mvc applications.  It is recommended to have at least a basic understanding of unit tests,\nassertions and mocks.  zend-test , which provides testing\nintegration for zend-mvc, uses  PHPUnit ; this tutorial will\ncover using that library for testing your applications.",
            "title": "Unit Testing a zend-mvc application"
        },
        {
            "location": "/unit-testing/#installing-zend-test",
            "text": "zend-test  provides PHPUnit\nintegration for zend-mvc, including application scaffolding and custom\nassertions. You will need to install it:  $ composer require --dev zendframework/zend-test  The above command will update your  composer.json  file and perform an update\nfor you, which will also setup autoloading rules.",
            "title": "Installing zend-test"
        },
        {
            "location": "/unit-testing/#running-the-initial-tests",
            "text": "Out-of-the-box, the skeleton application provides several tests for the shipped Application\\Controller\\IndexController  class. Now that you have zend-test\ninstalled, you can run these:  $ ./vendor/bin/phpunit",
            "title": "Running the initial tests"
        },
        {
            "location": "/unit-testing/#phpunit-invocation-on-windows",
            "text": "On Windows, you need to wrap the command in double quotes:  $ \"vendor/bin/phpunit\"   You should see output similar to the following:  PHPUnit 5.4.6 by Sebastian Bergmann and contributors.\n\n...                                                                 3 / 3 (100%)\n\nTime: 116 ms, Memory: 11.00MB\n\nOK (3 tests, 7 assertions)  There might be 2 failing tests if you followed the getting started guide. This\nis because the  Application\\IndexController  is overridden by the AlbumController . This can be ignored for now.  Now it's time to write our own tests!",
            "title": "PHPUnit invocation on Windows"
        },
        {
            "location": "/unit-testing/#setting-up-the-tests-directory",
            "text": "As zend-mvc applications are built from modules that should be\nstandalone blocks of an application, we don't test the application in it's\nentirety, but module by module.  We will demonstrate setting up the minimum requirements to test a module, the Album  module we wrote in the user guide, which then can be used as a base\nfor testing any other module.  Start by creating a directory called  test  under  module/Album/  with\nthe following subdirectories:  module/\n    Album/\n        test/\n            Controller/  Additionally, add an  autoload-dev  rule in your  composer.json :  \"autoload-dev\": {\n    \"psr-4\": {\n        \"ApplicationTest\\\\\": \"module/Application/test/\",\n        \"AlbumTest\\\\\": \"module/Album/test/\"\n    }\n}  When done, run:  $ composer dump-autoload  The structure of the  test  directory matches exactly with that of the module's\nsource files, and it will allow you to keep your tests well-organized and easy\nto find.",
            "title": "Setting up the tests directory"
        },
        {
            "location": "/unit-testing/#bootstrapping-your-tests",
            "text": "Next, edit the  phpunit.xml.dist  file at the project root; we'll add a new\ntest suite to it. When done, it should read as follows:  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<phpunit colors=\"true\">\n    <testsuites>\n        <testsuite name=\"ZendSkeletonApplication Test Suite\">\n            <directory>./module/Application/test</directory>\n        </testsuite>\n        <testsuite name=\"Album\">\n            <directory>./module/Album/test</directory>\n        </testsuite>\n    </testsuites>\n</phpunit>  Now run your new Album test suite from the project root:  $ ./vendor/bin/phpunit --testsuite Album",
            "title": "Bootstrapping your tests"
        },
        {
            "location": "/unit-testing/#windows-and-phpunit",
            "text": "On Windows, don't forget to wrap the  phpunit  command in double quotes:  $ \"vendor/bin/phpunit\" --testsuite Album   You should get similar output to the following:  PHPUnit 5.4.6 by Sebastian Bergmann and contributors.\n\nTime: 0 seconds, Memory: 1.75Mb\n\nNo tests executed!  Let's write our first test!",
            "title": "Windows and PHPUnit"
        },
        {
            "location": "/unit-testing/#your-first-controller-test",
            "text": "Testing controllers is never an easy task, but the zend-test component makes\ntesting much less cumbersome.  First, create  AlbumControllerTest.php  under  module/Album/test/Controller/ \nwith the following contents:  <?php\nnamespace AlbumTest\\Controller;\n\nuse Album\\Controller\\AlbumController;\nuse Zend\\Stdlib\\ArrayUtils;\nuse Zend\\Test\\PHPUnit\\Controller\\AbstractHttpControllerTestCase;\n\nclass AlbumControllerTest extends AbstractHttpControllerTestCase\n{\n    protected $traceError = false;\n\n    public function setUp()\n    {\n        // The module configuration should still be applicable for tests.\n        // You can override configuration here with test case specific values,\n        // such as sample view templates, path stacks, module_listener_options,\n        // etc.\n        $configOverrides = [];\n\n        $this->setApplicationConfig(ArrayUtils::merge(\n            // Grabbing the full application configuration:\n            include __DIR__ . '/../../../../config/application.config.php',\n            $configOverrides\n        ));\n        parent::setUp();\n    }\n}  The  AbstractHttpControllerTestCase  class we extend here helps us setting up\nthe application itself, helps with dispatching and other tasks that happen\nduring a request, and offers methods for asserting request params, response\nheaders, redirects, and more. See the  zend-test \ndocumentation for more information.  The principal requirement for any zend-test test case is to set the application\nconfig with the  setApplicationConfig()  method. For now, we assume the default\napplication configuration will be appropriate; however, we can override values\nlocally within the test using the  $configOverrides  variable.  Now, add the following method to the  AlbumControllerTest  class:  public function testIndexActionCanBeAccessed()\n{\n    $this->dispatch('/album');\n    $this->assertResponseStatusCode(200);\n    $this->assertModuleName('Album');\n    $this->assertControllerName(AlbumController::class);\n    $this->assertControllerClass('AlbumController');\n    $this->assertMatchedRouteName('album');\n}  This test case dispatches the  /album  URL, asserts that the response code is\n200, and that we ended up in the desired module and controller.",
            "title": "Your first controller test"
        },
        {
            "location": "/unit-testing/#assert-against-controller-service-names",
            "text": "For asserting the  controller name  we are using the controller name we\ndefined in our  routing configuration for the Album module. In our example\nthis should be defined on line 16 of the  module.config.php  file in the Album\nmodule.   If you run:  $ ./vendor/bin/phpunit --testsuite Album  again, you should see something like the following:  PHPUnit 5.4.6 by Sebastian Bergmann and contributors.\n\n.                                                                   1 / 1 (100%)\n\nTime: 124 ms, Memory: 11.50MB\n\nOK (1 test, 5 assertions)  A successful first test!",
            "title": "Assert against controller service names"
        },
        {
            "location": "/unit-testing/#a-failing-test-case",
            "text": "We likely don't want to hit the same database during testing as we use for our\nweb property. Let's add some configuration to the test case to remove the\ndatabase configuration. In your  AlbumControllerTest::setUp()  method, add the\nfollowing lines right after the call to  parent::setUp(); :  $services = $this->getApplicationServiceLocator();\n$config = $services->get('config');\nunset($config['db']);\n$services->setAllowOverride(true);\n$services->setService('config', $config);\n$services->setAllowOverride(false);  The above removes the 'db' configuration entirely; we'll be replacing it with\nsomething else before long.  When we run the tests now:  $ ./vendor/bin/phpunit --testsuite Album\nPHPUnit 5.4.6 by Sebastian Bergmann and contributors.\n\nF\n\nTime: 0 seconds, Memory: 8.50Mb\n\nThere was 1 failure:\n\n1) AlbumTest\\Controller\\AlbumControllerTest::testIndexActionCanBeAccessed\nFailed asserting response code \"200\", actual status code is \"500\"\n\n{projectPath}/vendor/zendframework/zend-test/src/PHPUnit/Controller/AbstractControllerTestCase.php:{lineNumber}\n{projectPath}/module/Album/test/AlbumTest/Controller/AlbumControllerTest.php:{lineNumber}\n\nFAILURES!\nTests: 1, Assertions: 0, Failures: 1.  The failure message doesn't tell us much, apart from that the expected status\ncode is not 200, but 500. To get a bit more information when something goes\nwrong in a test case, we set the protected  $traceError  member to  true  (which\nis the default; we set it to  false  to demonstrate this capability). Modify the\nfollowing line from just above the  setUp  method in our  AlbumControllerTest  class:  protected $traceError = true;  Running the  phpunit  command again and we should see some more information\nabout what went wrong in our test. You'll get a list of the exceptions raised,\nalong with their messages, the filename, and line number:  1) AlbumTest\\Controller\\AlbumControllerTest::testIndexActionCanBeAccessed\nFailed asserting response code \"200\", actual status code is \"500\"\n\nExceptions raised:\nException 'Zend\\ServiceManager\\Exception\\ServiceNotCreatedException' with message 'Service with name \"Zend\\Db\\Adapter\\AdapterInterface\" could not be created. Reason: createDriver expects a \"driver\" key to be present inside the parameters' in {projectPath}/vendor/zendframework/zend-servicemanager/src/ServiceManager.php:{lineNumber}\n\nException 'Zend\\Db\\Adapter\\Exception\\InvalidArgumentException' with message 'createDriver expects a \"driver\" key to be present inside the parameters' in {projectPath}/vendor/zendframework/zend-db/src/Adapter/Adapter.php:{lineNumber}  Based on the exception messages, it appears we are unable to create a zend-db\nadapter instance, due to missing configuration!",
            "title": "A failing test case"
        },
        {
            "location": "/unit-testing/#configuring-the-service-manager-for-the-tests",
            "text": "The error says that the service manager can not create an instance of a database\nadapter for us. The database adapter is indirectly used by our Album\\Model\\AlbumTable  to fetch the list of albums from the database.  The first thought would be to create an instance of an adapter, pass it to the\nservice manager, and let the code run from there as is. The problem with this\napproach is that we would end up with our test cases actually doing queries\nagainst the database. To keep our tests fast, and to reduce the number of\npossible failure points in our tests, this should be avoided.  The second thought would be then to create a mock of the database adapter, and\nprevent the actual database calls by mocking them out. This is a much better\napproach, but creating the adapter mock is tedious (but no doubt we will have to\ncreate it at some point).  The best thing to do would be to mock out our  Album\\Model\\AlbumTable  class\nwhich retrieves the list of albums from the database. Remember, we are now\ntesting our controller, so we can mock out the actual call to  fetchAll  and\nreplace the return values with dummy values. At this point, we are not\ninterested in how  fetchAll()  retrieves the albums, but only that it gets called\nand that it returns an array of albums; these facts allow us to provide mock\ninstances. When we test  AlbumTable  itself, we can write the actual tests for\nthe  fetchAll  method.  First, let's do some setup.  Add import statements to the top of the test class file for each of the AlbumTable  and  ServiceManager  classes:  use Album\\Model\\AlbumTable;\nuse Zend\\ServiceManager\\ServiceManager;  Now add the following property to the test class:  protected $albumTable;  Next, we'll create three new methods that we'll invoke during setup:  protected function configureServiceManager(ServiceManager $services)\n{\n    $services->setAllowOverride(true);\n\n    $services->setService('config', $this->updateConfig($services->get('config')));\n    $services->setService(AlbumTable::class, $this->mockAlbumTable()->reveal());\n\n    $services->setAllowOverride(false);\n}\n\nprotected function updateConfig($config)\n{\n    $config['db'] = [];\n    return $config;\n}\n\nprotected function mockAlbumTable()\n{\n    $this->albumTable = $this->prophesize(AlbumTable::class);\n    return $this->albumTable;\n}  By default, the  ServiceManager  does not allow us to replace existing services. configureServiceManager()  calls a special method on the instance to enable\noverriding services, and then we inject specific overrides we wish to use.\nWhen done, we disable overrides to ensure that if, during dispatch, any code\nattempts to override a service, an exception will be raised.  The last method above creates a mock instance of our  AlbumTable  using Prophecy , an object mocking framework\nthat's bundled and integrated in PHPUnit. The instance returned by prophesize()  is a scaffold object; calling  reveal()  on it, as done in the configureServiceManager()  method above, provides the underlying mock object\nthat will then be asserted against.  With this in place, we can update our  setUp()  method to read as follows:  public function setUp()\n{\n    // The module configuration should still be applicable for tests.\n    // You can override configuration here with test case specific values,\n    // such as sample view templates, path stacks, module_listener_options,\n    // etc.\n    $configOverrides = [];\n\n    $this->setApplicationConfig(ArrayUtils::merge(\n        include __DIR__ . '/../../../../config/application.config.php',\n        $configOverrides\n    ));\n\n    parent::setUp();\n\n    $this->configureServiceManager($this->getApplicationServiceLocator());\n}  Now update the  testIndexActionCanBeAccessed()  method to add a line asserting\nthe  AlbumTable 's  fetchAll()  method will be called, and return an array:  public function testIndexActionCanBeAccessed()\n{\n    $this->albumTable->fetchAll()->willReturn([]);\n\n    $this->dispatch('/album');\n    $this->assertResponseStatusCode(200);\n    $this->assertModuleName('Album');\n    $this->assertControllerName(AlbumController::class);\n    $this->assertControllerClass('AlbumController');\n    $this->assertMatchedRouteName('album');\n}  Running  phpunit  at this point, we will get the following output as the tests\nnow pass:  $ ./vendor/bin/phpunit --testsuite Album\nPHPUnit 5.4.6 by Sebastian Bergmann and contributors.\n\n.                                                                   1 / 1 (100%)\n\nTime: 105 ms, Memory: 10.75MB\n\nOK (1 test, 5 assertions)",
            "title": "Configuring the service manager for the tests"
        },
        {
            "location": "/unit-testing/#testing-actions-with-post",
            "text": "A common scenario with controllers is processing POST data submitted via a form,\nas we do in the  AlbumController::addAction() . Let's write a test for that.  public function testAddActionRedirectsAfterValidPost()\n{\n    $this->albumTable\n        ->saveAlbum(Argument::type(Album::class))\n        ->shouldBeCalled();\n\n    $postData = [\n        'title'  => 'Led Zeppelin III',\n        'artist' => 'Led Zeppelin',\n        'id'     => '',\n    ];\n    $this->dispatch('/album/add', 'POST', $postData);\n    $this->assertResponseStatusCode(302);\n    $this->assertRedirectTo('/album');\n}  This test case references two new classes that we need to import; add the\nfollowing import statements at the top of the class file:  use Album\\Model\\Album;\nuse Prophecy\\Argument;  Prophecy\\Argument  allows us to perform assertions against the values passed as\narguments to mock objects. In this case, we want to assert that we received an Album  instance. (We could have also done deeper assertions to ensure the Album  instance contained expected data.)  When we dispatch the application this time, we use the request method POST, and\npass data to it. This test case then asserts a 302 response status, and\nintroduces a new assertion against the location to which the response redirects.  Running  phpunit  gives us the following output:  $ ./vendor/bin/phpunit --testsuite Album\nPHPUnit 5.4.6 by Sebastian Bergmann and contributors.\n\n..                                                                  2 / 2 (100%)\n\nTime: 1.49 seconds, Memory: 13.25MB\n\nOK (2 tests, 8 assertions)  Testing the  editAction()  and  deleteAction()  methods can be performed\nsimilarly; however, when testing the  editAction()  method, you will also need\nto assert against the  AlbumTable::getAlbum()  method:  $this->albumTable->getAlbum($id)->willReturn(new Album());  Ideally, you should test all the various paths through each method. For example:   Test that a non-POST request to  addAction()  displays an empty form.  Test that a invalid data provided to  addAction()  re-displays the form, but\n  with error messages.  Test that absence of an identifier in the route parameters when invoking\n  either  editAction()  or  deleteAction()  will redirect to the appropriate\n  location.  Test that an invalid identifier passed to  editAction()  will redirect to the\n  album landing page.  Test that non-POST requests to  editAction()  and  deleteAction()  display\n  forms.   and so on. Doing so will help you understand the paths through your application\nand controllers, as well as ensure that changes in behavior bubble up as test\nfailures.",
            "title": "Testing actions with POST"
        },
        {
            "location": "/unit-testing/#testing-model-entities",
            "text": "Now that we know how to test our controllers, let us move to an other important\npart of our application: the model entity.  Here we want to test that the initial state of the entity is what we expect it\nto be, that we can convert the model's parameters to and from an array, and that\nit has all the input filters we need.  Create the file  AlbumTest.php  in  module/Album/test/Model  directory\nwith the following contents:  <?php\nnamespace AlbumTest\\Model;\n\nuse Album\\Model\\Album;\nuse PHPUnit_Framework_TestCase as TestCase;\n\nclass AlbumTest extends TestCase\n{\n    public function testInitialAlbumValuesAreNull()\n    {\n        $album = new Album();\n\n        $this->assertNull($album->artist, '\"artist\" should be null by default');\n        $this->assertNull($album->id, '\"id\" should be null by default');\n        $this->assertNull($album->title, '\"title\" should be null by default');\n    }\n\n    public function testExchangeArraySetsPropertiesCorrectly()\n    {\n        $album = new Album();\n        $data  = [\n            'artist' => 'some artist',\n            'id'     => 123,\n            'title'  => 'some title'\n        ];\n\n        $album->exchangeArray($data);\n\n        $this->assertSame(\n            $data['artist'],\n            $album->artist,\n            '\"artist\" was not set correctly'\n        );\n\n        $this->assertSame(\n            $data['id'],\n            $album->id,\n            '\"id\" was not set correctly'\n        );\n\n        $this->assertSame(\n            $data['title'],\n            $album->title,\n            '\"title\" was not set correctly'\n        );\n    }\n\n    public function testExchangeArraySetsPropertiesToNullIfKeysAreNotPresent()\n    {\n        $album = new Album();\n\n        $album->exchangeArray([\n            'artist' => 'some artist',\n            'id'     => 123,\n            'title'  => 'some title',\n        ]);\n        $album->exchangeArray([]);\n\n        $this->assertNull($album->artist, '\"artist\" should default to null');\n        $this->assertNull($album->id, '\"id\" should default to null');\n        $this->assertNull($album->title, '\"title\" should default to null');\n    }\n\n    public function testGetArrayCopyReturnsAnArrayWithPropertyValues()\n    {\n        $album = new Album();\n        $data  = [\n            'artist' => 'some artist',\n            'id'     => 123,\n            'title'  => 'some title'\n        ];\n\n        $album->exchangeArray($data);\n        $copyArray = $album->getArrayCopy();\n\n        $this->assertSame($data['artist'], $copyArray['artist'], '\"artist\" was not set correctly');\n        $this->assertSame($data['id'], $copyArray['id'], '\"id\" was not set correctly');\n        $this->assertSame($data['title'], $copyArray['title'], '\"title\" was not set correctly');\n    }\n\n    public function testInputFiltersAreSetCorrectly()\n    {\n        $album = new Album();\n\n        $inputFilter = $album->getInputFilter();\n\n        $this->assertSame(3, $inputFilter->count());\n        $this->assertTrue($inputFilter->has('artist'));\n        $this->assertTrue($inputFilter->has('id'));\n        $this->assertTrue($inputFilter->has('title'));\n    }\n}  We are testing for 5 things:   Are all of the  Album 's properties initially set to  NULL ?  Will the  Album 's properties be set correctly when we call  exchangeArray() ?  Will a default value of  NULL  be used for properties whose keys are not present in the  $data  array?  Can we get an array copy of our model?  Do all elements have input filters present?   If we run  phpunit  again, we will get the following output, confirming that our\nmodel is indeed correct:  $ ./vendor/bin/phpunit --testsuite Album\nPHPUnit 5.4.6 by Sebastian Bergmann and contributors.\n\n.......                                                             7 / 7 (100%)\n\nTime: 186 ms, Memory: 13.75MB\n\nOK (7 tests, 24 assertions)",
            "title": "Testing model entities"
        },
        {
            "location": "/unit-testing/#testing-model-tables",
            "text": "The final step in this unit testing tutorial for zend-mvc applications is\nwriting tests for our model tables.  This test assures that we can get a list of albums, or one album by its ID, and\nthat we can save and delete albums from the database.  To avoid actual interaction with the database itself, we will replace certain\nparts with mocks.  Create a file  AlbumTableTest.php  in  module/Album/test/Model/  with the\nfollowing contents:  <?php\nnamespace AlbumTest\\Model;\n\nuse Album\\Model\\AlbumTable;\nuse Album\\Model\\Album;\nuse PHPUnit_Framework_TestCase as TestCase;\nuse RuntimeException;\nuse Zend\\Db\\ResultSet\\ResultSetInterface;\nuse Zend\\Db\\TableGateway\\TableGatewayInterface;\n\nclass AlbumTableTest extends TestCase\n{\n    protected function setUp()\n    {\n        $this->tableGateway = $this->prophesize(TableGatewayInterface::class);\n        $this->albumTable = new AlbumTable($this->tableGateway->reveal());\n    }\n\n    public function testFetchAllReturnsAllAlbums()\n    {\n        $resultSet = $this->prophesize(ResultSetInterface::class)->reveal();\n        $this->tableGateway->select()->willReturn($resultSet);\n\n        $this->assertSame($resultSet, $this->albumTable->fetchAll());\n    }\n}  Since we are testing the  AlbumTable  here and not the  TableGateway  class\n(which has already been tested in zend-db), we only want to make sure\nthat our  AlbumTable  class is interacting with the  TableGateway  class the way\nthat we expect it to. Above, we're testing to see if the  fetchAll()  method of AlbumTable  will call the  select()  method of the  $tableGateway  property\nwith no parameters. If it does, it should return a  ResultSet  instance. Finally,\nwe expect that this same  ResultSet  object will be returned to the calling\nmethod. This test should run fine, so now we can add the rest of the test\nmethods:  public function testCanDeleteAnAlbumByItsId()\n{\n    $this->tableGateway->delete(['id' => 123])->shouldBeCalled();\n    $this->albumTable->deleteAlbum(123);\n}\n\npublic function testSaveAlbumWillInsertNewAlbumsIfTheyDontAlreadyHaveAnId()\n{\n    $albumData = [\n        'artist' => 'The Military Wives',\n        'title'  => 'In My Dreams'\n    ];\n    $album = new Album();\n    $album->exchangeArray($albumData);\n\n    $this->tableGateway->insert($albumData)->shouldBeCalled();\n    $this->albumTable->saveAlbum($album);\n}\n\npublic function testSaveAlbumWillUpdateExistingAlbumsIfTheyAlreadyHaveAnId()\n{\n    $albumData = [\n        'id'     => 123,\n        'artist' => 'The Military Wives',\n        'title'  => 'In My Dreams',\n    ];\n    $album = new Album();\n    $album->exchangeArray($albumData);\n\n    $resultSet = $this->prophesize(ResultSetInterface::class);\n    $resultSet->current()->willReturn($album);\n\n    $this->tableGateway\n        ->select(['id' => 123])\n        ->willReturn($resultSet->reveal());\n    $this->tableGateway\n        ->update(\n            array_filter($albumData, function ($key) {\n                return in_array($key, ['artist', 'title']);\n            }, ARRAY_FILTER_USE_KEY),\n            ['id' => 123]\n        )->shouldBeCalled();\n\n    $this->albumTable->saveAlbum($album);\n}\n\npublic function testExceptionIsThrownWhenGettingNonExistentAlbum()\n{\n    $resultSet = $this->prophesize(ResultSetInterface::class);\n    $resultSet->current()->willReturn(null);\n\n    $this->tableGateway\n        ->select(['id' => 123])\n        ->willReturn($resultSet->reveal());\n\n    $this->setExpectedException(\n        RuntimeException::class,\n        'Could not find row with identifier 123'\n    );\n    $this->albumTable->getAlbum(123);\n}  These tests are nothing complicated and should be self explanatory. In each\ntest, we add assertions to our mock table gateway, and then call and assert\nagainst methods in our  AlbumTable .  We are testing that:   We can retrieve an individual album by its ID.  We can delete albums.  We can save a new album.  We can update existing albums.  We will encounter an exception if we're trying to retrieve an album that\n   doesn't exist.   Running  phpunit  one last time, we get the output as follows:  $ ./vendor/bin/phpunit --testsuite Album\nPHPUnit 5.4.6 by Sebastian Bergmann and contributors.\n\n.............                                                     13 / 13 (100%)\n\nTime: 151 ms, Memory: 14.00MB\n\nOK (13 tests, 31 assertions)",
            "title": "Testing model tables"
        },
        {
            "location": "/unit-testing/#conclusion",
            "text": "In this short tutorial, we gave a few examples how different parts of a zend-mvc\napplication can be tested. We covered setting up the environment for testing,\nhow to test controllers and actions, how to approach failing test cases, how to\nconfigure the service manager, as well as how to test model entities and model\ntables.  This tutorial is by no means a definitive guide to writing unit tests, just a\nsmall stepping stone helping you develop applications of higher quality.",
            "title": "Conclusion"
        },
        {
            "location": "/navigation/",
            "text": "Using zend-navigation in your Album Module\n\n\nIn this tutorial we will use the \nzend-navigation component\n\nto add a navigation menu to the black bar at the top of the screen, and add\nbreadcrumbs above the main site content.\n\n\nPreparation\n\n\nIn a real world application, the album browser would be only a portion of a\nworking website. Usually the user would land on a homepage first, and be able to\nview albums by using a standard navigation menu. So that we have a site that is\nmore realistic than just the albums feature, lets make the standard skeleton\nwelcome page our homepage, with the \n/album\n route still showing our album module.\nIn order to make this change, we need to undo some work we did earlier.\nCurrently, navigating to the root of your app (\n/\n) routes you to the\n\nAlbumController\n's default action. Let's undo this route change so we have two\ndiscrete entry points to the app, a home page, and an albums area.\n\n\n// In module/Application/config/module.config.php:\n'home' => [\n   'type' => Literal::class,\n    'options' => [\n        'route'    => '/',\n        'defaults' => [\n            'controller' => Controller\\IndexController::class, // <-- change back here\n            'action'     => 'index',\n        ],\n    ],\n],\n\n\n\n(You can also now remove the import for the \nAlbum\\Controller\\AlbumController\n\nclass.)\n\n\nThis change means that if you go to the home page of your application\n(\nhttp://localhost:8080/\n or \nhttp://zf-tutorial.localhost/\n), you see the\ndefault skeleton application introduction. Your list of albums is still\navailable at the \n/album\n route.\n\n\nSetting Up zend-navigation\n\n\nFirst, we need to install zend-navigation. From your root directory, execute the\nfollowing:\n\n\n$ composer require zendframework/zend-navigation\n\n\n\nAssuming you followed the \nGetting Started tutorial\n,\nyou will be prompted by the \nzend-component-installer\n\nplugin to inject \nZend\\Navigation\n; be sure to select the option for either\n\nconfig/application.config.php\n or \nconfig/modules.config.php\n; since it is the\nonly package you are installing, you can answer either \"y\" or \"n\" to the \"Remember this\noption for other packages of the same type\" prompt.\n\n\n\n\nManual configuration\n\n\nIf you are not using zend-component-installer, you will need to setup\nconfiguration manually. You can do this in one of two ways:\n\n\n\n\nRegister the \nZend\\Navigation\n module in either\n  \nconfig/application.config.php\n or \nconfig/modules.config.php\n. Make sure\n  you put it towards the top of the module list, before any modules you have\n  defined or third party modules you are using.\n\n\nAlternately, add a new file, \nconfig/autoload/navigation.global.php\n, with\n  the following contents:\n\n\n\n\n<?php\nuse Zend\\Navigation\\ConfigProvider;\n\nreturn [\n    'service_manager' => (new ConfigProvider())->getDependencyConfig(),\n];\n\n\n\n\n\nOnce installed, our application is now aware of zend-navigation, and even has\nsome default factories in place, which we will now make use of.\n\n\nConfiguring our Site Map\n\n\nNext up, we need zend-navigation to understand the hierarchy of our site.\nTo do this, we can add a \nnavigation\n key to our configuration, with the site\nstructure details. We'll do that in the \nApplication\n module configuration:\n\n\n// in module/Application/config/module.config.php:\nreturn [\n    /* ... */\n\n    'navigation' => [\n        'default' => [\n            [\n                'label' => 'Home',\n                'route' => 'home',\n            ],\n            [\n                'label' => 'Album',\n                'route' => 'album',\n                'pages' => [\n                    [\n                        'label'  => 'Add',\n                        'route'  => 'album',\n                        'action' => 'add',\n                    ],\n                    [\n                        'label'  => 'Edit',\n                        'route'  => 'album',\n                        'action' => 'edit',\n                    ],\n                    [\n                        'label'  => 'Delete',\n                        'route'  => 'album',\n                        'action' => 'delete',\n                    ],\n                ],\n            ],\n        ],\n    ],\n\n    /* ... */\n];\n\n\n\nThis configuration maps out the pages we've defined in our Album module, with\nlabels linking to the given route names and actions. You can define highly complex\nhierarchical sites here with pages and sub-pages linking to route names,\ncontroller/action pairs, or external uris. For more information, see the\n\nzend-navigation quick start\n.\n\n\nAdding the Menu View Helper\n\n\nNow that we have the navigation helper configured by our service manager and\nmerged config, we can add the menu to the title bar to our layout by\nusing the \nmenu view helper\n:\n\n\n<?php // in module/Application/view/layout/layout.phtml: ?>\n<div class=\"collapse navbar-collapse\">\n    <?php // add this: ?>\n    <?= $this->navigation('navigation')->menu() ?>\n</div>\n\n\n\nThe navigation helper is provided by default with zend-view, and uses the service\nmanager configuration we've already defined to configure itself automatically.\nRefreshing your application, you will see a working menu; with just a few tweaks\nhowever, we can make it look even better:\n\n\n<?php // in module/Application/view/layout/layout.phtml: ?>\n<div class=\"collapse navbar-collapse\">\n    <?php // update to: ?>\n    <?= $this->navigation('navigation')\n        ->menu()\n        ->setMinDepth(0)\n        ->setMaxDepth(0)\n        ->setUlClass('nav navbar-nav') ?>\n</div>\n\n\n\nHere we tell the renderer to give the root \n<ul>\n the class of \nnav\n (so that\nBootstrap styles the menu correctly), and only render the first level of any\ngiven page. If you view your application in your browser, you will now see a\nnicely styled menu appear in the title bar.\n\n\nThe great thing about zend-navigation is that it integrates with zend-router in\norder to highlight the currently viewed page. Because of this, it sets the\nactive page to have a class of \nactive\n in the menu; Bootstrap uses this to\nhighlight your current page accordingly.\n\n\nAdding Breadcrumbs\n\n\nAdding breadcrumbs follows the same process. In our \nlayout.phtml\n we want to\nadd breadcrumbs above the main content pane, so our users know exactly\nwhere they are in our website. Inside the container \n<div>\n, before we\noutput the content from the view, let's add a breadcrumb by using the\n\nbreadcrumbs view helper\n.\n\n\n<?php // module/Application/view/layout/layout.phtml: ?>\n<div class=\"container\">\n    <?php // add the following line: ?>\n    <?= $this->navigation('navigation')->breadcrumbs()->setMinDepth(0) ?>\n    <?= $this->content ?>\n</div>\n\n\n\nThis adds a simple but functional breadcrumb to every page (we tell it to render\nfrom a depth of 0 so we see all page levels), but we can do better than that!\nBecause Bootstrap has a styled breadcrumb as part of its base CSS, let's add\na partial that outputs the \n<ul>\n using Bootstrap styles. We'll create it in the\n\nview\n directory of the \nApplication\n module (this partial is application wide,\nrather than album specific):\n\n\n<?php // in module/Application/view/partial/breadcrumb.phtml: ?>\n<ul class=\"breadcrumb\">\n    <?php\n    // iterate through the pages\n    foreach ($this->pages as $key => $page):\n    ?>\n        <li>\n            <?php\n            // if this isn't the last page, add a link and the separator:\n            if ($key < count($this->pages) - 1):\n            ?>\n                <a href=\"<?= $page->getHref() ?>\"><?= $page->getLabel() ?></a>\n            <?php\n            // otherwise, output the name only:\n            else:\n            ?>\n                <?= $page->getLabel() ?>\n            <?php endif; ?>\n        </li>\n    <?php endforeach; ?>\n</ul>\n\n\n\nNotice how the partial is passed a \nZend\\View\\Model\\ViewModel\n instance with the\n\npages\n property set to an array of pages to render.\n\n\nNow we need to tell the breadcrumb helper to use the partial we have just\nwritten:\n\n\n<?php // in module/Application/view/layout/layout.phtml: ?>\n<div class=\"container\">\n    <?php // Update to: ?>\n    <?= $this->navigation('navigation')\n            ->breadcrumbs()\n            ->setMinDepth(0)\n            ->setPartial('partial/breadcrumb') ?>\n    <?= $this->content ?>\n</div>\n\n\n\nRefreshing the page now gives us a styled set of breadcrumbs on each page.",
            "title": "Adicionando zend-navigation ao M\u00f3dulo Album"
        },
        {
            "location": "/navigation/#using-zend-navigation-in-your-album-module",
            "text": "In this tutorial we will use the  zend-navigation component \nto add a navigation menu to the black bar at the top of the screen, and add\nbreadcrumbs above the main site content.",
            "title": "Using zend-navigation in your Album Module"
        },
        {
            "location": "/navigation/#preparation",
            "text": "In a real world application, the album browser would be only a portion of a\nworking website. Usually the user would land on a homepage first, and be able to\nview albums by using a standard navigation menu. So that we have a site that is\nmore realistic than just the albums feature, lets make the standard skeleton\nwelcome page our homepage, with the  /album  route still showing our album module.\nIn order to make this change, we need to undo some work we did earlier.\nCurrently, navigating to the root of your app ( / ) routes you to the AlbumController 's default action. Let's undo this route change so we have two\ndiscrete entry points to the app, a home page, and an albums area.  // In module/Application/config/module.config.php:\n'home' => [\n   'type' => Literal::class,\n    'options' => [\n        'route'    => '/',\n        'defaults' => [\n            'controller' => Controller\\IndexController::class, // <-- change back here\n            'action'     => 'index',\n        ],\n    ],\n],  (You can also now remove the import for the  Album\\Controller\\AlbumController \nclass.)  This change means that if you go to the home page of your application\n( http://localhost:8080/  or  http://zf-tutorial.localhost/ ), you see the\ndefault skeleton application introduction. Your list of albums is still\navailable at the  /album  route.",
            "title": "Preparation"
        },
        {
            "location": "/navigation/#setting-up-zend-navigation",
            "text": "First, we need to install zend-navigation. From your root directory, execute the\nfollowing:  $ composer require zendframework/zend-navigation  Assuming you followed the  Getting Started tutorial ,\nyou will be prompted by the  zend-component-installer \nplugin to inject  Zend\\Navigation ; be sure to select the option for either config/application.config.php  or  config/modules.config.php ; since it is the\nonly package you are installing, you can answer either \"y\" or \"n\" to the \"Remember this\noption for other packages of the same type\" prompt.",
            "title": "Setting Up zend-navigation"
        },
        {
            "location": "/navigation/#manual-configuration",
            "text": "If you are not using zend-component-installer, you will need to setup\nconfiguration manually. You can do this in one of two ways:   Register the  Zend\\Navigation  module in either\n   config/application.config.php  or  config/modules.config.php . Make sure\n  you put it towards the top of the module list, before any modules you have\n  defined or third party modules you are using.  Alternately, add a new file,  config/autoload/navigation.global.php , with\n  the following contents:   <?php\nuse Zend\\Navigation\\ConfigProvider;\n\nreturn [\n    'service_manager' => (new ConfigProvider())->getDependencyConfig(),\n];   Once installed, our application is now aware of zend-navigation, and even has\nsome default factories in place, which we will now make use of.",
            "title": "Manual configuration"
        },
        {
            "location": "/navigation/#configuring-our-site-map",
            "text": "Next up, we need zend-navigation to understand the hierarchy of our site.\nTo do this, we can add a  navigation  key to our configuration, with the site\nstructure details. We'll do that in the  Application  module configuration:  // in module/Application/config/module.config.php:\nreturn [\n    /* ... */\n\n    'navigation' => [\n        'default' => [\n            [\n                'label' => 'Home',\n                'route' => 'home',\n            ],\n            [\n                'label' => 'Album',\n                'route' => 'album',\n                'pages' => [\n                    [\n                        'label'  => 'Add',\n                        'route'  => 'album',\n                        'action' => 'add',\n                    ],\n                    [\n                        'label'  => 'Edit',\n                        'route'  => 'album',\n                        'action' => 'edit',\n                    ],\n                    [\n                        'label'  => 'Delete',\n                        'route'  => 'album',\n                        'action' => 'delete',\n                    ],\n                ],\n            ],\n        ],\n    ],\n\n    /* ... */\n];  This configuration maps out the pages we've defined in our Album module, with\nlabels linking to the given route names and actions. You can define highly complex\nhierarchical sites here with pages and sub-pages linking to route names,\ncontroller/action pairs, or external uris. For more information, see the zend-navigation quick start .",
            "title": "Configuring our Site Map"
        },
        {
            "location": "/navigation/#adding-the-menu-view-helper",
            "text": "Now that we have the navigation helper configured by our service manager and\nmerged config, we can add the menu to the title bar to our layout by\nusing the  menu view helper :  <?php // in module/Application/view/layout/layout.phtml: ?>\n<div class=\"collapse navbar-collapse\">\n    <?php // add this: ?>\n    <?= $this->navigation('navigation')->menu() ?>\n</div>  The navigation helper is provided by default with zend-view, and uses the service\nmanager configuration we've already defined to configure itself automatically.\nRefreshing your application, you will see a working menu; with just a few tweaks\nhowever, we can make it look even better:  <?php // in module/Application/view/layout/layout.phtml: ?>\n<div class=\"collapse navbar-collapse\">\n    <?php // update to: ?>\n    <?= $this->navigation('navigation')\n        ->menu()\n        ->setMinDepth(0)\n        ->setMaxDepth(0)\n        ->setUlClass('nav navbar-nav') ?>\n</div>  Here we tell the renderer to give the root  <ul>  the class of  nav  (so that\nBootstrap styles the menu correctly), and only render the first level of any\ngiven page. If you view your application in your browser, you will now see a\nnicely styled menu appear in the title bar.  The great thing about zend-navigation is that it integrates with zend-router in\norder to highlight the currently viewed page. Because of this, it sets the\nactive page to have a class of  active  in the menu; Bootstrap uses this to\nhighlight your current page accordingly.",
            "title": "Adding the Menu View Helper"
        },
        {
            "location": "/navigation/#adding-breadcrumbs",
            "text": "Adding breadcrumbs follows the same process. In our  layout.phtml  we want to\nadd breadcrumbs above the main content pane, so our users know exactly\nwhere they are in our website. Inside the container  <div> , before we\noutput the content from the view, let's add a breadcrumb by using the breadcrumbs view helper .  <?php // module/Application/view/layout/layout.phtml: ?>\n<div class=\"container\">\n    <?php // add the following line: ?>\n    <?= $this->navigation('navigation')->breadcrumbs()->setMinDepth(0) ?>\n    <?= $this->content ?>\n</div>  This adds a simple but functional breadcrumb to every page (we tell it to render\nfrom a depth of 0 so we see all page levels), but we can do better than that!\nBecause Bootstrap has a styled breadcrumb as part of its base CSS, let's add\na partial that outputs the  <ul>  using Bootstrap styles. We'll create it in the view  directory of the  Application  module (this partial is application wide,\nrather than album specific):  <?php // in module/Application/view/partial/breadcrumb.phtml: ?>\n<ul class=\"breadcrumb\">\n    <?php\n    // iterate through the pages\n    foreach ($this->pages as $key => $page):\n    ?>\n        <li>\n            <?php\n            // if this isn't the last page, add a link and the separator:\n            if ($key < count($this->pages) - 1):\n            ?>\n                <a href=\"<?= $page->getHref() ?>\"><?= $page->getLabel() ?></a>\n            <?php\n            // otherwise, output the name only:\n            else:\n            ?>\n                <?= $page->getLabel() ?>\n            <?php endif; ?>\n        </li>\n    <?php endforeach; ?>\n</ul>  Notice how the partial is passed a  Zend\\View\\Model\\ViewModel  instance with the pages  property set to an array of pages to render.  Now we need to tell the breadcrumb helper to use the partial we have just\nwritten:  <?php // in module/Application/view/layout/layout.phtml: ?>\n<div class=\"container\">\n    <?php // Update to: ?>\n    <?= $this->navigation('navigation')\n            ->breadcrumbs()\n            ->setMinDepth(0)\n            ->setPartial('partial/breadcrumb') ?>\n    <?= $this->content ?>\n</div>  Refreshing the page now gives us a styled set of breadcrumbs on each page.",
            "title": "Adding Breadcrumbs"
        },
        {
            "location": "/pagination/",
            "text": "Using zend-paginator in your Album Module\n\n\nIn this tutorial, we will use the \nzend-paginator component\n\nto add a handy pagination controller to the bottom of the album list.\n\n\nCurrently, we only have a handful of albums to display, so showing everything on\none page is not a problem. However, how will the album list look when we have\n100 albums or more in our database? The standard solution to this problem is to\nsplit the data up into a number of pages, and allow the user to navigate around\nthese pages using a pagination control. Just type \"Zend Framework\" into Google,\nand you can see their pagination control at the bottom of the page:\n\n\n\n\nPreparation\n\n\nAs before, we are going to use sqlite, via PHP's PDO driver. Create a text file\n\ndata/album-fixtures.sql\n with the following contents:\n\n\nINSERT INTO \"album\" (\"artist\", \"title\")\nVALUES\n    (\"David Bowie\", \"The Next Day (Deluxe Version)\"),\n    (\"Bastille\", \"Bad Blood\"),\n    (\"Bruno Mars\", \"Unorthodox Jukebox\"),\n    (\"Emeli Sand\u00e9\", \"Our Version of Events (Special Edition)\"),\n    (\"Bon Jovi\", \"What About Now (Deluxe Version)\"),\n    (\"Justin Timberlake\", \"The 20/20 Experience (Deluxe Version)\"),\n    (\"Bastille\", \"Bad Blood (The Extended Cut)\"),\n    (\"P!nk\", \"The Truth About Love\"),\n    (\"Sound City - Real to Reel\", \"Sound City - Real to Reel\"),\n    (\"Jake Bugg\", \"Jake Bugg\"),\n    (\"Various Artists\", \"The Trevor Nelson Collection\"),\n    (\"David Bowie\", \"The Next Day\"),\n    (\"Mumford & Sons\", \"Babel\"),\n    (\"The Lumineers\", \"The Lumineers\"),\n    (\"Various Artists\", \"Get Ur Freak On - R&B Anthems\"),\n    (\"The 1975\", \"Music For Cars EP\"),\n    (\"Various Artists\", \"Saturday Night Club Classics - Ministry of Sound\"),\n    (\"Hurts\", \"Exile (Deluxe)\"),\n    (\"Various Artists\", \"Mixmag - The Greatest Dance Tracks of All Time\"),\n    (\"Ben Howard\", \"Every Kingdom\"),\n    (\"Stereophonics\", \"Graffiti On the Train\"),\n    (\"The Script\", \"#3\"),\n    (\"Stornoway\", \"Tales from Terra Firma\"),\n    (\"David Bowie\", \"Hunky Dory (Remastered)\"),\n    (\"Worship Central\", \"Let It Be Known (Live)\"),\n    (\"Ellie Goulding\", \"Halcyon\"),\n    (\"Various Artists\", \"Dermot O'Leary Presents the Saturday Sessions 2013\"),\n    (\"Stereophonics\", \"Graffiti On the Train (Deluxe Version)\"),\n    (\"Dido\", \"Girl Who Got Away (Deluxe)\"),\n    (\"Hurts\", \"Exile\"),\n    (\"Bruno Mars\", \"Doo-Wops & Hooligans\"),\n    (\"Calvin Harris\", \"18 Months\"),\n    (\"Olly Murs\", \"Right Place Right Time\"),\n    (\"Alt-J (?)\", \"An Awesome Wave\"),\n    (\"One Direction\", \"Take Me Home\"),\n    (\"Various Artists\", \"Pop Stars\"),\n    (\"Various Artists\", \"Now That's What I Call Music! 83\"),\n    (\"John Grant\", \"Pale Green Ghosts\"),\n    (\"Paloma Faith\", \"Fall to Grace\"),\n    (\"Laura Mvula\", \"Sing To the Moon (Deluxe)\"),\n    (\"Duke Dumont\", \"Need U (100%) [feat. A*M*E] - EP\"),\n    (\"Watsky\", \"Cardboard Castles\"),\n    (\"Blondie\", \"Blondie: Greatest Hits\"),\n    (\"Foals\", \"Holy Fire\"),\n    (\"Maroon 5\", \"Overexposed\"),\n    (\"Bastille\", \"Pompeii (Remixes) - EP\"),\n    (\"Imagine Dragons\", \"Hear Me - EP\"),\n    (\"Various Artists\", \"100 Hits: 80s Classics\"),\n    (\"Various Artists\", \"Les Mis\u00e9rables (Highlights From the Motion Picture Soundtrack)\"),\n    (\"Mumford & Sons\", \"Sigh No More\"),\n    (\"Frank Ocean\", \"Channel ORANGE\"),\n    (\"Bon Jovi\", \"What About Now\"),\n    (\"Various Artists\", \"BRIT Awards 2013\"),\n    (\"Taylor Swift\", \"Red\"),\n    (\"Fleetwood Mac\", \"Fleetwood Mac: Greatest Hits\"),\n    (\"David Guetta\", \"Nothing But the Beat Ultimate\"),\n    (\"Various Artists\", \"Clubbers Guide 2013 (Mixed By Danny Howard) - Ministry of Sound\"),\n    (\"David Bowie\", \"Best of Bowie\"),\n    (\"Laura Mvula\", \"Sing To the Moon\"),\n    (\"ADELE\", \"21\"),\n    (\"Of Monsters and Men\", \"My Head Is an Animal\"),\n    (\"Rihanna\", \"Unapologetic\"),\n    (\"Various Artists\", \"BBC Radio 1's Live Lounge - 2012\"),\n    (\"Avicii & Nicky Romero\", \"I Could Be the One (Avicii vs. Nicky Romero)\"),\n    (\"The Streets\", \"A Grand Don't Come for Free\"),\n    (\"Tim McGraw\", \"Two Lanes of Freedom\"),\n    (\"Foo Fighters\", \"Foo Fighters: Greatest Hits\"),\n    (\"Various Artists\", \"Now That's What I Call Running!\"),\n    (\"Swedish House Mafia\", \"Until Now\"),\n    (\"The xx\", \"Coexist\"),\n    (\"Five\", \"Five: Greatest Hits\"),\n    (\"Jimi Hendrix\", \"People, Hell & Angels\"),\n    (\"Biffy Clyro\", \"Opposites (Deluxe)\"),\n    (\"The Smiths\", \"The Sound of the Smiths\"),\n    (\"The Saturdays\", \"What About Us - EP\"),\n    (\"Fleetwood Mac\", \"Rumours\"),\n    (\"Various Artists\", \"The Big Reunion\"),\n    (\"Various Artists\", \"Anthems 90s - Ministry of Sound\"),\n    (\"The Vaccines\", \"Come of Age\"),\n    (\"Nicole Scherzinger\", \"Boomerang (Remixes) - EP\"),\n    (\"Bob Marley\", \"Legend (Bonus Track Version)\"),\n    (\"Josh Groban\", \"All That Echoes\"),\n    (\"Blue\", \"Best of Blue\"),\n    (\"Ed Sheeran\", \"+\"),\n    (\"Olly Murs\", \"In Case You Didn't Know (Deluxe Edition)\"),\n    (\"Macklemore & Ryan Lewis\", \"The Heist (Deluxe Edition)\"),\n    (\"Various Artists\", \"Defected Presents Most Rated Miami 2013\"),\n    (\"Gorgon City\", \"Real EP\"),\n    (\"Mumford & Sons\", \"Babel (Deluxe Version)\"),\n    (\"Various Artists\", \"The Music of Nashville: Season 1, Vol. 1 (Original Soundtrack)\"),\n    (\"Various Artists\", \"The Twilight Saga: Breaking Dawn, Pt. 2 (Original Motion Picture Soundtrack)\"),\n    (\"Various Artists\", \"Mum - The Ultimate Mothers Day Collection\"),\n    (\"One Direction\", \"Up All Night\"),\n    (\"Bon Jovi\", \"Bon Jovi Greatest Hits\"),\n    (\"Agnetha F\u00e4ltskog\", \"A\"),\n    (\"Fun.\", \"Some Nights\"),\n    (\"Justin Bieber\", \"Believe Acoustic\"),\n    (\"Atoms for Peace\", \"Amok\"),\n    (\"Justin Timberlake\", \"Justified\"),\n    (\"Passenger\", \"All the Little Lights\"),\n    (\"Kodaline\", \"The High Hopes EP\"),\n    (\"Lana Del Rey\", \"Born to Die\"),\n    (\"JAY Z & Kanye West\", \"Watch the Throne (Deluxe Version)\"),\n    (\"Biffy Clyro\", \"Opposites\"),\n    (\"Various Artists\", \"Return of the 90s\"),\n    (\"Gabrielle Aplin\", \"Please Don't Say You Love Me - EP\"),\n    (\"Various Artists\", \"100 Hits - Driving Rock\"),\n    (\"Jimi Hendrix\", \"Experience Hendrix - The Best of Jimi Hendrix\"),\n    (\"Various Artists\", \"The Workout Mix 2013\"),\n    (\"The 1975\", \"Sex\"),\n    (\"Chase & Status\", \"No More Idols\"),\n    (\"Rihanna\", \"Unapologetic (Deluxe Version)\"),\n    (\"The Killers\", \"Battle Born\"),\n    (\"Olly Murs\", \"Right Place Right Time (Deluxe Edition)\"),\n    (\"A$AP Rocky\", \"LONG.LIVE.A$AP (Deluxe Version)\"),\n    (\"Various Artists\", \"Cooking Songs\"),\n    (\"Haim\", \"Forever - EP\"),\n    (\"Lianne La Havas\", \"Is Your Love Big Enough?\"),\n    (\"Michael Bubl\u00e9\", \"To Be Loved\"),\n    (\"Daughter\", \"If You Leave\"),\n    (\"The xx\", \"xx\"),\n    (\"Eminem\", \"Curtain Call\"),\n    (\"Kendrick Lamar\", \"good kid, m.A.A.d city (Deluxe)\"),\n    (\"Disclosure\", \"The Face - EP\"),\n    (\"Palma Violets\", \"180\"),\n    (\"Cody Simpson\", \"Paradise\"),\n    (\"Ed Sheeran\", \"+ (Deluxe Version)\"),\n    (\"Michael Bubl\u00e9\", \"Crazy Love (Hollywood Edition)\"),\n    (\"Bon Jovi\", \"Bon Jovi Greatest Hits - The Ultimate Collection\"),\n    (\"Rita Ora\", \"Ora\"),\n    (\"g33k\", \"Spabby\"),\n    (\"Various Artists\", \"Annie Mac Presents 2012\"),\n    (\"David Bowie\", \"The Platinum Collection\"),\n    (\"Bridgit Mendler\", \"Ready or Not (Remixes) - EP\"),\n    (\"Dido\", \"Girl Who Got Away\"),\n    (\"Various Artists\", \"Now That's What I Call Disney\"),\n    (\"The 1975\", \"Facedown - EP\"),\n    (\"Kodaline\", \"The Kodaline - EP\"),\n    (\"Various Artists\", \"100 Hits: Super 70s\"),\n    (\"Fred V & Grafix\", \"Goggles - EP\"),\n    (\"Biffy Clyro\", \"Only Revolutions (Deluxe Version)\"),\n    (\"Train\", \"California 37\"),\n    (\"Ben Howard\", \"Every Kingdom (Deluxe Edition)\"),\n    (\"Various Artists\", \"Motown Anthems\"),\n    (\"Courteeners\", \"ANNA\"),\n    (\"Johnny Marr\", \"The Messenger\"),\n    (\"Rodriguez\", \"Searching for Sugar Man\"),\n    (\"Jessie Ware\", \"Devotion\"),\n    (\"Bruno Mars\", \"Unorthodox Jukebox\"),\n    (\"Various Artists\", \"Call the Midwife (Music From the TV Series)\"\n);\n\n\n\n(The test data chosen happens to be the current 150 top iTunes albums at the\ntime of writing!)\n\n\nNow create the database using the following:\n\n\n$ sqlite data/zftutorial.db < data/album-fixtures.sql\n\n\n\nSome systems, including Ubuntu, use the command \nsqlite3\n; check to see which\none to use on your system.\n\n\n\n\nUsing PHP to create the database\n\n\nIf you do not have Sqlite installed on your system, you can use PHP to load\nthe database using the same SQL schema file created earlier. Create the file\n\ndata/load_album_fixtures.php\n with the following contents:\n\n\n<?php\n$db = new PDO('sqlite:' . realpath(__DIR__) . '/zftutorial.db');\n$fh = fopen(__DIR__ . '/album-fixtures.sql', 'r');\nwhile ($line = fread($fh, 4096)) {\n    $db->exec($line);\n}\nfclose($fh);\n\n\n\nOnce created, execute it:\n\n\n$ php data/load_album_fixtures.php\n\n\n\n\n\nThis gives us a handy extra 150 rows to play with. If you now visit your album\nlist at \n/album\n, you'll see a huge long list of 150+ albums; it's ugly.\n\n\nInstall zend-paginator\n\n\nzend-paginator is not installed or configured by default, so we will need to do\nthat. Run the following from the application root:\n\n\n$ composer require zendframework/zend-paginator\n\n\n\nAssuming you followed the \nGetting Started tutorial\n,\nyou will be prompted by the \nzend-component-installer\n\nplugin to inject \nZend\\Paginator\n; be sure to select the option for either\n\nconfig/application.config.php\n or \nconfig/modules.config.php\n; since it is the\nonly package you are installing, you can answer either \"y\" or \"n\" to the \"Remember this\noption for other packages of the same type\" prompt.\n\n\n\n\nManual configuration\n\n\nIf you are not using zend-component-installer, you will need to setup\nconfiguration manually. You can do this in one of two ways:\n\n\n\n\nRegister the \nZend\\Paginator\n module in either\n  \nconfig/application.config.php\n or \nconfig/modules.config.php\n. Make sure\n  you put it towards the top of the module list, before any modules you have\n  defined or third party modules you are using.\n\n\nAlternately, add a new file, \nconfig/autoload/paginator.global.php\n, with\n  the following contents:\n\n\n\n\n<?php\nuse Zend\\Paginator\\ConfigProvider;\n\nreturn [\n    'service_manager' => (new ConfigProvider())->getDependencyConfig(),\n];\n\n\n\n\n\nOnce installed, our application is now aware of zend-paginator, and even has\nsome default factories in place, which we will now make use of.\n\n\nModifying the AlbumTable\n\n\nIn order to let zend-paginator handle our database queries automatically for us,\nwe will be using the \nDbSelect pagination adapter\n\nThis will automatically manipulate and run a \nZend\\Db\\Sql\\Select\n object to\ninclude the correct \nLIMIT\n and \nWHERE\n clauses so that it returns only the\nconfigured amount of data for the given page. Let's modify the \nfetchAll\n method\nof the \nAlbumTable\n model, so that it can optionally return a paginator object:\n\n\n// in module/Album/src/Model/AlbumTable.php:\nnamespace Album\\Model;\n\nuse RuntimeException;\nuse Zend\\Db\\ResultSet\\ResultSet;\nuse Zend\\Db\\Sql\\Select;\nuse Zend\\Db\\TableGateway\\TableGatewayInterface;\nuse Zend\\Paginator\\Adapter\\DbSelect;\nuse Zend\\Paginator\\Paginator;\n\nclass AlbumTable\n{\n    /* ... */\n\n    public function fetchAll($paginated = false)\n    {\n        if ($paginated) {\n            return $this->fetchPaginatedResults();\n        }\n\n        return $this->tableGateway->select();\n    }\n\n    private function fetchPaginatedResults()\n    {\n        // Create a new Select object for the table:\n        $select = new Select($this->tableGateway->getTable());\n\n        // Create a new result set based on the Album entity:\n        $resultSetPrototype = new ResultSet();\n        $resultSetPrototype->setArrayObjectPrototype(new Album());\n\n        // Create a new pagination adapter object:\n        $paginatorAdapter = new DbSelect(\n            // our configured select object:\n            $select,\n            // the adapter to run it against:\n            $this->tableGateway->getAdapter(),\n            // the result set to hydrate:\n            $resultSetPrototype\n        );\n\n        $paginator = new Paginator($paginatorAdapter);\n        return $paginator;\n    }\n\n    /* ... */\n}\n\n\n\nThis will return a fully configured \nPaginator\n instance. We've already told the\n\nDbSelect\n adapter to use our created \nSelect\n object, to use the adapter that\nthe \nTableGateway\n object uses, and also how to hydrate the result into a\n\nAlbum\n entity in the same fashion as the \nTableGateway\n does. This means that\nour executed and returned paginator results will return \nAlbum\n objects in\nexactly the same fashion as the non-paginated results.\n\n\nModifying the AlbumController\n\n\nNext, we need to tell the album controller to provide the view with a\n\nPagination\n object instead of a \nResultSet\n. Both these objects can by iterated\nover to return hydrated \nAlbum\n objects, so we won't need to make many changes\nto the view script:\n\n\n// in module/Album/src/Controller/AlbumController.php:\n\n/* ... */\n\npublic function indexAction()\n{\n    // Grab the paginator from the AlbumTable:\n    $paginator = $this->table->fetchAll(true);\n\n    // Set the current page to what has been passed in query string,\n    // or to 1 if none is set, or the page is invalid:\n    $page = (int) $this->params()->fromQuery('page', 1);\n    $page = ($page < 1) ? 1 : $page;\n    $paginator->setCurrentPageNumber($page);\n\n    // Set the number of items per page to 10:\n    $paginator->setItemCountPerPage(10);\n\n    return new ViewModel(['paginator' => $paginator]);\n}\n\n/* ... */\n\n\n\nHere we are getting the configured \nPaginator\n object from the \nAlbumTable\n, and\nthen telling it to use the page that is optionally passed in the querystring\n\npage\n parameter (after first validating it). We are also telling the paginator\nwe want to display 10 albums per page.\n\n\nUpdating the View Script\n\n\nNow, tell the view script to iterate over the \npagination\n view variable, rather\nthan the \nalbums\n variable:\n\n\n<?php // in module/Album/view/album/album/index.phtml:\n$title = 'My albums';\n$this->headTitle($title);\n?>\n<h1><?= $this->escapeHtml($title); ?></h1>\n<p>\n    <a href=\"<?= $this->url('album', ['action' => 'add']) ?>\">Add new album</a>\n</p>\n\n<table class=\"table\">\n    <tr>\n        <th>Title</th>\n        <th>Artist</th>\n        <th>&nbsp;</th>\n    </tr>\n    <?php foreach ($this->paginator as $album) : // <-- change here! ?>\n        <tr>\n            <td><?= $this->escapeHtml($album->title) ?></td>\n            <td><?= $this->escapeHtml($album->artist) ?></td>\n            <td>\n                <a href=\"<?= $this->url('album', ['action' => 'edit', 'id' => $album->id]) ?>\">Edit</a>\n                <a href=\"<?= $this->url('album', ['action' => 'delete', 'id' => $album->id]) ?>\">Delete</a>\n            </td>\n        </tr>\n    <?php endforeach; ?>\n</table>\n\n\n\nChecking the \n/album\n route on your website should now give you a list of just\n10 albums, but with no method to navigate through the pages. Let's correct that\nnow.\n\n\nCreating the Pagination Control Partial\n\n\nMuch like we created a custom breadcrumbs partial to render our breadcrumb in\nthe \nnavigation tutorial\n, we need to create a\ncustom pagination control partial to render our pagination control just the way\nwe want it. Again, because we are using Bootstrap, this will primarily involve\noutputting correctly formatted HTML. Let's create the partial in the\n\nmodule/Application/view/partial/\n folder, so that we can use the control in all\nour modules:\n\n\n<?php // in module/Application/view/partial/paginator.phtml: ?>\n<?php if ($this->pageCount): ?>\n<div>\n  <ul class=\"pagination\">\n  <!-- Previous page link -->\n  <?php if (isset($this->previous)): ?>\n    <li>\n      <a href=\"<?= $this->url($this->route, [], ['query' => ['page' => $this->previous]]) ?>\">\n        &lt;&lt;\n      </a>\n    </li>\n  <?php else: ?>\n    <li class=\"disabled\">\n      <a href=\"#\">\n        &lt;&lt;\n      </a>\n    </li>\n  <?php endif ?>\n\n  <!-- Numbered page links -->\n  <?php foreach ($this->pagesInRange as $page): ?>\n    <?php if ($page !== $this->current): ?>\n      <li>\n        <a href=\"<?= $this->url($this->route, [], ['query' => ['page' => $page]]) ?>\">\n          <?= $page ?>\n        </a>\n      </li>\n    <?php else: ?>\n      <li class=\"active\">\n        <a href=\"#\"><?= $page ?></a>\n      </li>\n    <?php endif ?>\n  <?php endforeach ?>\n\n  <!-- Next page link -->\n  <?php if (isset($this->next)): ?>\n    <li>\n      <a href=\"<?= $this->url($this->route, [], ['query' => ['page' => $this->next]]) ?>\">\n        &gt;&gt;\n      </a>\n    </li>\n  <?php else: ?>\n    <li class=\"disabled\">\n      <a href=\"#\">\n        &gt;&gt;\n      </a>\n    </li>\n  <?php endif ?>\n  </ul>\n</div>\n<?php endif ?>\n\n\n\nThis partial creates a pagination control with links to the correct pages (if\nthere is more than one page in the pagination object). It will render a previous\npage link (and mark it disabled if you are at the first page), then render a\nlist of intermediate pages (that are passed to the partial based on the\nrendering style; we'll pass that to the view helper in the next step). Finally,\nit will create a next page link (and disable it if you're at the end). Notice\nhow we pass the page number via the \npage\n querystring parameter which we have\nalready told our controller to use to display the current page.\n\n\nUsing the PaginationControl View Helper\n\n\nTo page through the albums, we need to invoke the\n\npaginationControl view helper\n\nto display our pagination control:\n\n\n<?php\n// In module/Album/view/album/album/index.phtml:\n// Add at the end of the file after the table:\n?>\n<?= $this->paginationControl(\n    // The paginator object:\n    $this->paginator,\n    // The scrolling style:\n    'sliding',\n    // The partial to use to render the control:\n    'partial/paginator',\n    // The route to link to when a user clicks a control link:\n    ['route' => 'album']\n) ?>\n\n\n\nThe above echoes the \npaginationControl\n helper, and tells it to use our\npaginator instance, the \nsliding scrolling style\n,\nour paginator partial, and which route to use for generating links. Refreshing\nyour application now should give you Bootstrap-styled pagination controls!",
            "title": "Adicionando zend-paginator ao M\u00f3dulo Album"
        },
        {
            "location": "/pagination/#using-zend-paginator-in-your-album-module",
            "text": "In this tutorial, we will use the  zend-paginator component \nto add a handy pagination controller to the bottom of the album list.  Currently, we only have a handful of albums to display, so showing everything on\none page is not a problem. However, how will the album list look when we have\n100 albums or more in our database? The standard solution to this problem is to\nsplit the data up into a number of pages, and allow the user to navigate around\nthese pages using a pagination control. Just type \"Zend Framework\" into Google,\nand you can see their pagination control at the bottom of the page:",
            "title": "Using zend-paginator in your Album Module"
        },
        {
            "location": "/pagination/#preparation",
            "text": "As before, we are going to use sqlite, via PHP's PDO driver. Create a text file data/album-fixtures.sql  with the following contents:  INSERT INTO \"album\" (\"artist\", \"title\")\nVALUES\n    (\"David Bowie\", \"The Next Day (Deluxe Version)\"),\n    (\"Bastille\", \"Bad Blood\"),\n    (\"Bruno Mars\", \"Unorthodox Jukebox\"),\n    (\"Emeli Sand\u00e9\", \"Our Version of Events (Special Edition)\"),\n    (\"Bon Jovi\", \"What About Now (Deluxe Version)\"),\n    (\"Justin Timberlake\", \"The 20/20 Experience (Deluxe Version)\"),\n    (\"Bastille\", \"Bad Blood (The Extended Cut)\"),\n    (\"P!nk\", \"The Truth About Love\"),\n    (\"Sound City - Real to Reel\", \"Sound City - Real to Reel\"),\n    (\"Jake Bugg\", \"Jake Bugg\"),\n    (\"Various Artists\", \"The Trevor Nelson Collection\"),\n    (\"David Bowie\", \"The Next Day\"),\n    (\"Mumford & Sons\", \"Babel\"),\n    (\"The Lumineers\", \"The Lumineers\"),\n    (\"Various Artists\", \"Get Ur Freak On - R&B Anthems\"),\n    (\"The 1975\", \"Music For Cars EP\"),\n    (\"Various Artists\", \"Saturday Night Club Classics - Ministry of Sound\"),\n    (\"Hurts\", \"Exile (Deluxe)\"),\n    (\"Various Artists\", \"Mixmag - The Greatest Dance Tracks of All Time\"),\n    (\"Ben Howard\", \"Every Kingdom\"),\n    (\"Stereophonics\", \"Graffiti On the Train\"),\n    (\"The Script\", \"#3\"),\n    (\"Stornoway\", \"Tales from Terra Firma\"),\n    (\"David Bowie\", \"Hunky Dory (Remastered)\"),\n    (\"Worship Central\", \"Let It Be Known (Live)\"),\n    (\"Ellie Goulding\", \"Halcyon\"),\n    (\"Various Artists\", \"Dermot O'Leary Presents the Saturday Sessions 2013\"),\n    (\"Stereophonics\", \"Graffiti On the Train (Deluxe Version)\"),\n    (\"Dido\", \"Girl Who Got Away (Deluxe)\"),\n    (\"Hurts\", \"Exile\"),\n    (\"Bruno Mars\", \"Doo-Wops & Hooligans\"),\n    (\"Calvin Harris\", \"18 Months\"),\n    (\"Olly Murs\", \"Right Place Right Time\"),\n    (\"Alt-J (?)\", \"An Awesome Wave\"),\n    (\"One Direction\", \"Take Me Home\"),\n    (\"Various Artists\", \"Pop Stars\"),\n    (\"Various Artists\", \"Now That's What I Call Music! 83\"),\n    (\"John Grant\", \"Pale Green Ghosts\"),\n    (\"Paloma Faith\", \"Fall to Grace\"),\n    (\"Laura Mvula\", \"Sing To the Moon (Deluxe)\"),\n    (\"Duke Dumont\", \"Need U (100%) [feat. A*M*E] - EP\"),\n    (\"Watsky\", \"Cardboard Castles\"),\n    (\"Blondie\", \"Blondie: Greatest Hits\"),\n    (\"Foals\", \"Holy Fire\"),\n    (\"Maroon 5\", \"Overexposed\"),\n    (\"Bastille\", \"Pompeii (Remixes) - EP\"),\n    (\"Imagine Dragons\", \"Hear Me - EP\"),\n    (\"Various Artists\", \"100 Hits: 80s Classics\"),\n    (\"Various Artists\", \"Les Mis\u00e9rables (Highlights From the Motion Picture Soundtrack)\"),\n    (\"Mumford & Sons\", \"Sigh No More\"),\n    (\"Frank Ocean\", \"Channel ORANGE\"),\n    (\"Bon Jovi\", \"What About Now\"),\n    (\"Various Artists\", \"BRIT Awards 2013\"),\n    (\"Taylor Swift\", \"Red\"),\n    (\"Fleetwood Mac\", \"Fleetwood Mac: Greatest Hits\"),\n    (\"David Guetta\", \"Nothing But the Beat Ultimate\"),\n    (\"Various Artists\", \"Clubbers Guide 2013 (Mixed By Danny Howard) - Ministry of Sound\"),\n    (\"David Bowie\", \"Best of Bowie\"),\n    (\"Laura Mvula\", \"Sing To the Moon\"),\n    (\"ADELE\", \"21\"),\n    (\"Of Monsters and Men\", \"My Head Is an Animal\"),\n    (\"Rihanna\", \"Unapologetic\"),\n    (\"Various Artists\", \"BBC Radio 1's Live Lounge - 2012\"),\n    (\"Avicii & Nicky Romero\", \"I Could Be the One (Avicii vs. Nicky Romero)\"),\n    (\"The Streets\", \"A Grand Don't Come for Free\"),\n    (\"Tim McGraw\", \"Two Lanes of Freedom\"),\n    (\"Foo Fighters\", \"Foo Fighters: Greatest Hits\"),\n    (\"Various Artists\", \"Now That's What I Call Running!\"),\n    (\"Swedish House Mafia\", \"Until Now\"),\n    (\"The xx\", \"Coexist\"),\n    (\"Five\", \"Five: Greatest Hits\"),\n    (\"Jimi Hendrix\", \"People, Hell & Angels\"),\n    (\"Biffy Clyro\", \"Opposites (Deluxe)\"),\n    (\"The Smiths\", \"The Sound of the Smiths\"),\n    (\"The Saturdays\", \"What About Us - EP\"),\n    (\"Fleetwood Mac\", \"Rumours\"),\n    (\"Various Artists\", \"The Big Reunion\"),\n    (\"Various Artists\", \"Anthems 90s - Ministry of Sound\"),\n    (\"The Vaccines\", \"Come of Age\"),\n    (\"Nicole Scherzinger\", \"Boomerang (Remixes) - EP\"),\n    (\"Bob Marley\", \"Legend (Bonus Track Version)\"),\n    (\"Josh Groban\", \"All That Echoes\"),\n    (\"Blue\", \"Best of Blue\"),\n    (\"Ed Sheeran\", \"+\"),\n    (\"Olly Murs\", \"In Case You Didn't Know (Deluxe Edition)\"),\n    (\"Macklemore & Ryan Lewis\", \"The Heist (Deluxe Edition)\"),\n    (\"Various Artists\", \"Defected Presents Most Rated Miami 2013\"),\n    (\"Gorgon City\", \"Real EP\"),\n    (\"Mumford & Sons\", \"Babel (Deluxe Version)\"),\n    (\"Various Artists\", \"The Music of Nashville: Season 1, Vol. 1 (Original Soundtrack)\"),\n    (\"Various Artists\", \"The Twilight Saga: Breaking Dawn, Pt. 2 (Original Motion Picture Soundtrack)\"),\n    (\"Various Artists\", \"Mum - The Ultimate Mothers Day Collection\"),\n    (\"One Direction\", \"Up All Night\"),\n    (\"Bon Jovi\", \"Bon Jovi Greatest Hits\"),\n    (\"Agnetha F\u00e4ltskog\", \"A\"),\n    (\"Fun.\", \"Some Nights\"),\n    (\"Justin Bieber\", \"Believe Acoustic\"),\n    (\"Atoms for Peace\", \"Amok\"),\n    (\"Justin Timberlake\", \"Justified\"),\n    (\"Passenger\", \"All the Little Lights\"),\n    (\"Kodaline\", \"The High Hopes EP\"),\n    (\"Lana Del Rey\", \"Born to Die\"),\n    (\"JAY Z & Kanye West\", \"Watch the Throne (Deluxe Version)\"),\n    (\"Biffy Clyro\", \"Opposites\"),\n    (\"Various Artists\", \"Return of the 90s\"),\n    (\"Gabrielle Aplin\", \"Please Don't Say You Love Me - EP\"),\n    (\"Various Artists\", \"100 Hits - Driving Rock\"),\n    (\"Jimi Hendrix\", \"Experience Hendrix - The Best of Jimi Hendrix\"),\n    (\"Various Artists\", \"The Workout Mix 2013\"),\n    (\"The 1975\", \"Sex\"),\n    (\"Chase & Status\", \"No More Idols\"),\n    (\"Rihanna\", \"Unapologetic (Deluxe Version)\"),\n    (\"The Killers\", \"Battle Born\"),\n    (\"Olly Murs\", \"Right Place Right Time (Deluxe Edition)\"),\n    (\"A$AP Rocky\", \"LONG.LIVE.A$AP (Deluxe Version)\"),\n    (\"Various Artists\", \"Cooking Songs\"),\n    (\"Haim\", \"Forever - EP\"),\n    (\"Lianne La Havas\", \"Is Your Love Big Enough?\"),\n    (\"Michael Bubl\u00e9\", \"To Be Loved\"),\n    (\"Daughter\", \"If You Leave\"),\n    (\"The xx\", \"xx\"),\n    (\"Eminem\", \"Curtain Call\"),\n    (\"Kendrick Lamar\", \"good kid, m.A.A.d city (Deluxe)\"),\n    (\"Disclosure\", \"The Face - EP\"),\n    (\"Palma Violets\", \"180\"),\n    (\"Cody Simpson\", \"Paradise\"),\n    (\"Ed Sheeran\", \"+ (Deluxe Version)\"),\n    (\"Michael Bubl\u00e9\", \"Crazy Love (Hollywood Edition)\"),\n    (\"Bon Jovi\", \"Bon Jovi Greatest Hits - The Ultimate Collection\"),\n    (\"Rita Ora\", \"Ora\"),\n    (\"g33k\", \"Spabby\"),\n    (\"Various Artists\", \"Annie Mac Presents 2012\"),\n    (\"David Bowie\", \"The Platinum Collection\"),\n    (\"Bridgit Mendler\", \"Ready or Not (Remixes) - EP\"),\n    (\"Dido\", \"Girl Who Got Away\"),\n    (\"Various Artists\", \"Now That's What I Call Disney\"),\n    (\"The 1975\", \"Facedown - EP\"),\n    (\"Kodaline\", \"The Kodaline - EP\"),\n    (\"Various Artists\", \"100 Hits: Super 70s\"),\n    (\"Fred V & Grafix\", \"Goggles - EP\"),\n    (\"Biffy Clyro\", \"Only Revolutions (Deluxe Version)\"),\n    (\"Train\", \"California 37\"),\n    (\"Ben Howard\", \"Every Kingdom (Deluxe Edition)\"),\n    (\"Various Artists\", \"Motown Anthems\"),\n    (\"Courteeners\", \"ANNA\"),\n    (\"Johnny Marr\", \"The Messenger\"),\n    (\"Rodriguez\", \"Searching for Sugar Man\"),\n    (\"Jessie Ware\", \"Devotion\"),\n    (\"Bruno Mars\", \"Unorthodox Jukebox\"),\n    (\"Various Artists\", \"Call the Midwife (Music From the TV Series)\"\n);  (The test data chosen happens to be the current 150 top iTunes albums at the\ntime of writing!)  Now create the database using the following:  $ sqlite data/zftutorial.db < data/album-fixtures.sql  Some systems, including Ubuntu, use the command  sqlite3 ; check to see which\none to use on your system.",
            "title": "Preparation"
        },
        {
            "location": "/pagination/#using-php-to-create-the-database",
            "text": "If you do not have Sqlite installed on your system, you can use PHP to load\nthe database using the same SQL schema file created earlier. Create the file data/load_album_fixtures.php  with the following contents:  <?php\n$db = new PDO('sqlite:' . realpath(__DIR__) . '/zftutorial.db');\n$fh = fopen(__DIR__ . '/album-fixtures.sql', 'r');\nwhile ($line = fread($fh, 4096)) {\n    $db->exec($line);\n}\nfclose($fh);  Once created, execute it:  $ php data/load_album_fixtures.php   This gives us a handy extra 150 rows to play with. If you now visit your album\nlist at  /album , you'll see a huge long list of 150+ albums; it's ugly.",
            "title": "Using PHP to create the database"
        },
        {
            "location": "/pagination/#install-zend-paginator",
            "text": "zend-paginator is not installed or configured by default, so we will need to do\nthat. Run the following from the application root:  $ composer require zendframework/zend-paginator  Assuming you followed the  Getting Started tutorial ,\nyou will be prompted by the  zend-component-installer \nplugin to inject  Zend\\Paginator ; be sure to select the option for either config/application.config.php  or  config/modules.config.php ; since it is the\nonly package you are installing, you can answer either \"y\" or \"n\" to the \"Remember this\noption for other packages of the same type\" prompt.",
            "title": "Install zend-paginator"
        },
        {
            "location": "/pagination/#manual-configuration",
            "text": "If you are not using zend-component-installer, you will need to setup\nconfiguration manually. You can do this in one of two ways:   Register the  Zend\\Paginator  module in either\n   config/application.config.php  or  config/modules.config.php . Make sure\n  you put it towards the top of the module list, before any modules you have\n  defined or third party modules you are using.  Alternately, add a new file,  config/autoload/paginator.global.php , with\n  the following contents:   <?php\nuse Zend\\Paginator\\ConfigProvider;\n\nreturn [\n    'service_manager' => (new ConfigProvider())->getDependencyConfig(),\n];   Once installed, our application is now aware of zend-paginator, and even has\nsome default factories in place, which we will now make use of.",
            "title": "Manual configuration"
        },
        {
            "location": "/pagination/#modifying-the-albumtable",
            "text": "In order to let zend-paginator handle our database queries automatically for us,\nwe will be using the  DbSelect pagination adapter \nThis will automatically manipulate and run a  Zend\\Db\\Sql\\Select  object to\ninclude the correct  LIMIT  and  WHERE  clauses so that it returns only the\nconfigured amount of data for the given page. Let's modify the  fetchAll  method\nof the  AlbumTable  model, so that it can optionally return a paginator object:  // in module/Album/src/Model/AlbumTable.php:\nnamespace Album\\Model;\n\nuse RuntimeException;\nuse Zend\\Db\\ResultSet\\ResultSet;\nuse Zend\\Db\\Sql\\Select;\nuse Zend\\Db\\TableGateway\\TableGatewayInterface;\nuse Zend\\Paginator\\Adapter\\DbSelect;\nuse Zend\\Paginator\\Paginator;\n\nclass AlbumTable\n{\n    /* ... */\n\n    public function fetchAll($paginated = false)\n    {\n        if ($paginated) {\n            return $this->fetchPaginatedResults();\n        }\n\n        return $this->tableGateway->select();\n    }\n\n    private function fetchPaginatedResults()\n    {\n        // Create a new Select object for the table:\n        $select = new Select($this->tableGateway->getTable());\n\n        // Create a new result set based on the Album entity:\n        $resultSetPrototype = new ResultSet();\n        $resultSetPrototype->setArrayObjectPrototype(new Album());\n\n        // Create a new pagination adapter object:\n        $paginatorAdapter = new DbSelect(\n            // our configured select object:\n            $select,\n            // the adapter to run it against:\n            $this->tableGateway->getAdapter(),\n            // the result set to hydrate:\n            $resultSetPrototype\n        );\n\n        $paginator = new Paginator($paginatorAdapter);\n        return $paginator;\n    }\n\n    /* ... */\n}  This will return a fully configured  Paginator  instance. We've already told the DbSelect  adapter to use our created  Select  object, to use the adapter that\nthe  TableGateway  object uses, and also how to hydrate the result into a Album  entity in the same fashion as the  TableGateway  does. This means that\nour executed and returned paginator results will return  Album  objects in\nexactly the same fashion as the non-paginated results.",
            "title": "Modifying the AlbumTable"
        },
        {
            "location": "/pagination/#modifying-the-albumcontroller",
            "text": "Next, we need to tell the album controller to provide the view with a Pagination  object instead of a  ResultSet . Both these objects can by iterated\nover to return hydrated  Album  objects, so we won't need to make many changes\nto the view script:  // in module/Album/src/Controller/AlbumController.php:\n\n/* ... */\n\npublic function indexAction()\n{\n    // Grab the paginator from the AlbumTable:\n    $paginator = $this->table->fetchAll(true);\n\n    // Set the current page to what has been passed in query string,\n    // or to 1 if none is set, or the page is invalid:\n    $page = (int) $this->params()->fromQuery('page', 1);\n    $page = ($page < 1) ? 1 : $page;\n    $paginator->setCurrentPageNumber($page);\n\n    // Set the number of items per page to 10:\n    $paginator->setItemCountPerPage(10);\n\n    return new ViewModel(['paginator' => $paginator]);\n}\n\n/* ... */  Here we are getting the configured  Paginator  object from the  AlbumTable , and\nthen telling it to use the page that is optionally passed in the querystring page  parameter (after first validating it). We are also telling the paginator\nwe want to display 10 albums per page.",
            "title": "Modifying the AlbumController"
        },
        {
            "location": "/pagination/#updating-the-view-script",
            "text": "Now, tell the view script to iterate over the  pagination  view variable, rather\nthan the  albums  variable:  <?php // in module/Album/view/album/album/index.phtml:\n$title = 'My albums';\n$this->headTitle($title);\n?>\n<h1><?= $this->escapeHtml($title); ?></h1>\n<p>\n    <a href=\"<?= $this->url('album', ['action' => 'add']) ?>\">Add new album</a>\n</p>\n\n<table class=\"table\">\n    <tr>\n        <th>Title</th>\n        <th>Artist</th>\n        <th>&nbsp;</th>\n    </tr>\n    <?php foreach ($this->paginator as $album) : // <-- change here! ?>\n        <tr>\n            <td><?= $this->escapeHtml($album->title) ?></td>\n            <td><?= $this->escapeHtml($album->artist) ?></td>\n            <td>\n                <a href=\"<?= $this->url('album', ['action' => 'edit', 'id' => $album->id]) ?>\">Edit</a>\n                <a href=\"<?= $this->url('album', ['action' => 'delete', 'id' => $album->id]) ?>\">Delete</a>\n            </td>\n        </tr>\n    <?php endforeach; ?>\n</table>  Checking the  /album  route on your website should now give you a list of just\n10 albums, but with no method to navigate through the pages. Let's correct that\nnow.",
            "title": "Updating the View Script"
        },
        {
            "location": "/pagination/#creating-the-pagination-control-partial",
            "text": "Much like we created a custom breadcrumbs partial to render our breadcrumb in\nthe  navigation tutorial , we need to create a\ncustom pagination control partial to render our pagination control just the way\nwe want it. Again, because we are using Bootstrap, this will primarily involve\noutputting correctly formatted HTML. Let's create the partial in the module/Application/view/partial/  folder, so that we can use the control in all\nour modules:  <?php // in module/Application/view/partial/paginator.phtml: ?>\n<?php if ($this->pageCount): ?>\n<div>\n  <ul class=\"pagination\">\n  <!-- Previous page link -->\n  <?php if (isset($this->previous)): ?>\n    <li>\n      <a href=\"<?= $this->url($this->route, [], ['query' => ['page' => $this->previous]]) ?>\">\n        &lt;&lt;\n      </a>\n    </li>\n  <?php else: ?>\n    <li class=\"disabled\">\n      <a href=\"#\">\n        &lt;&lt;\n      </a>\n    </li>\n  <?php endif ?>\n\n  <!-- Numbered page links -->\n  <?php foreach ($this->pagesInRange as $page): ?>\n    <?php if ($page !== $this->current): ?>\n      <li>\n        <a href=\"<?= $this->url($this->route, [], ['query' => ['page' => $page]]) ?>\">\n          <?= $page ?>\n        </a>\n      </li>\n    <?php else: ?>\n      <li class=\"active\">\n        <a href=\"#\"><?= $page ?></a>\n      </li>\n    <?php endif ?>\n  <?php endforeach ?>\n\n  <!-- Next page link -->\n  <?php if (isset($this->next)): ?>\n    <li>\n      <a href=\"<?= $this->url($this->route, [], ['query' => ['page' => $this->next]]) ?>\">\n        &gt;&gt;\n      </a>\n    </li>\n  <?php else: ?>\n    <li class=\"disabled\">\n      <a href=\"#\">\n        &gt;&gt;\n      </a>\n    </li>\n  <?php endif ?>\n  </ul>\n</div>\n<?php endif ?>  This partial creates a pagination control with links to the correct pages (if\nthere is more than one page in the pagination object). It will render a previous\npage link (and mark it disabled if you are at the first page), then render a\nlist of intermediate pages (that are passed to the partial based on the\nrendering style; we'll pass that to the view helper in the next step). Finally,\nit will create a next page link (and disable it if you're at the end). Notice\nhow we pass the page number via the  page  querystring parameter which we have\nalready told our controller to use to display the current page.",
            "title": "Creating the Pagination Control Partial"
        },
        {
            "location": "/pagination/#using-the-paginationcontrol-view-helper",
            "text": "To page through the albums, we need to invoke the paginationControl view helper \nto display our pagination control:  <?php\n// In module/Album/view/album/album/index.phtml:\n// Add at the end of the file after the table:\n?>\n<?= $this->paginationControl(\n    // The paginator object:\n    $this->paginator,\n    // The scrolling style:\n    'sliding',\n    // The partial to use to render the control:\n    'partial/paginator',\n    // The route to link to when a user clicks a control link:\n    ['route' => 'album']\n) ?>  The above echoes the  paginationControl  helper, and tells it to use our\npaginator instance, the  sliding scrolling style ,\nour paginator partial, and which route to use for generating links. Refreshing\nyour application now should give you Bootstrap-styled pagination controls!",
            "title": "Using the PaginationControl View Helper"
        },
        {
            "location": "/in-depth-guide/first-module/",
            "text": "Introducing the Blog Module\n\n\nNow that we know about the basics of the zend-mvc skeleton application,\nlet's continue and create our very own module. We will create a module named\n\"Blog\". This module will display a list of database entries that represent a\nsingle blog post. Each post will have three properties: \nid\n, \ntext\n, and\n\ntitle\n. We will create forms to enter new posts into our database and to edit\nexisting posts. Furthermore we will do so by using best-practices throughout the\nwhole tutorial.\n\n\nWriting a new Module\n\n\nLet's start by creating a new folder under the \n/module\n directory called\n\nBlog\n, with the following stucture:\n\n\nmodule/\n    Blog/\n        config/\n        src/\n        view/\n\n\n\nTo be recognized as a module by the \nModuleManager\n,\nwe need to do three things:\n\n\n\n\nTell Composer how to autoload classes from our new module.\n\n\nCreate a \nModule\n class in the \nBlog\n namespace.\n\n\nNotify the application of the new module.\n\n\n\n\nLet's tell Composer about our new module. Open the \ncomposer.json\n file in the\nproject root, and edit the \nautoload\n section to add a new PSR-4 entry for the\n\nBlog\n module; when you're done, it should read:\n\n\n\"autoload\": {\n   \"psr-4\": {\n        \"Application\\\\\": \"module/Application/src/\",\n        \"Album\\\\\": \"module/Album/src/\",\n        \"Blog\\\\\": \"module/Blog/src/\"\n   }\n}\n\n\n\nOnce you're done, tell Composer to update its autoloading definitions:\n\n\n$ composer dump-autoload\n\n\n\nNext, we will create a \nModule\n class under the \nBlog\n namespace. Create the\nfile \nmodule/Blog/src/Module.php\n with the following contents:\n\n\n<?php\nnamespace Blog;\n\nclass Module\n{\n}\n\n\n\nWe now have a module that can be detected by the\n\nModuleManager\n.\nLet's add this module to our application. Although our module doesn't do\nanything yet, just having the \nModule.php\n class allows it to be loaded by the\nModuleManager.  To do this, add an entry for \nBlog\n to the modules array inside\n\nconfig/modules.config.php\n:\n\n\n<?php\n// In config/modules.config.php:\n\nreturn [\n    /* ... */\n    'Application',\n    'Album',\n    'Blog',\n];\n\n\n\nIf you refresh your application you should see no change at all (but also no\nerrors).\n\n\nAt this point it's worth taking a step back to discuss what modules are for. In\nshort, a module is an encapsulated set of features for your application. A\nmodule might add features to the application that you can see, like our \nBlog\n\nmodule; or it might provide background functionality for other modules in the\napplication to use, such as interacting with a third party API.\n\n\nOrganizing your code into modules makes it easier for you to reuse functionality\nin other application, or to use modules written by the community.\n\n\nConfiguring the Module\n\n\nThe next thing we're going to do is add a route to our application so that our\nmodule can be accessed through the URL \nlocalhost:8080/blog\n. We do this by\nadding router configuration to our module, but first we need to let the\n\nModuleManager\n know that our module has configuration that it needs to load.\n\n\nThis is done by adding a \ngetConfig()\n method to the \nModule\n class that\nreturns the configuration. (This method is defined in the\n\nConfigProviderInterface\n, although explicitly implementing this interface in the\nmodule class is optional.) This method should return either an \narray\n or a\n\nTraversable\n object. Continue by editing \nmodule/Blog/src/Module.php\n:\n\n\n// In /module/Blog/Module.php:\nclass Module\n{\n    public function getConfig()\n    {\n        return [];\n    }\n}\n\n\n\nWith this, our module is now able to be configured. Configuration files can\nbecome quite big, though, and keeping everything inside the \ngetConfig()\n method\nwon't be optimal. To help keep our project organized, we're going to put our\narray configuration in a separate file. Go ahead and create this file at\n\nmodule/Blog/config/module.config.php\n:\n\n\n<?php\nreturn [];\n\n\n\nNow rewrite the \ngetConfig()\n function to include this newly created\nfile instead of directly returning the array:\n\n\n<?php\n// In /module/Blog/Module.php:\n\npublic function getConfig()\n{\n    return include __DIR__ . '/../config/module.config.php';\n}\n\n\n\nReload your application and you'll see that everything remains as it was. Next\nwe add the new route to our configuration file:\n\n\n// In /module/Blog/config/module.config.php:\nnamespace Blog;\n\nuse Zend\\Router\\Http\\Literal;\n\nreturn [\n    // This lines opens the configuration for the RouteManager\n    'router' => [\n        // Open configuration for all possible routes\n        'routes' => [\n            // Define a new route called \"blog\"\n            'blog' => [\n                // Define a \"literal\" route type:\n                'type' => Literal::class,\n                // Configure the route itself\n                'options' => [\n                    // Listen to \"/blog\" as uri:\n                    'route' => '/blog',\n                    // Define default controller and action to be called when\n                    // this route is matched\n                    'defaults' => [\n                        'controller' => Controller\\ListController::class,\n                        'action'     => 'index',\n                    ],\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\nWe've now created a route called \npost\n that listens to the URL\n\nlocalhost:8080/blog\n. Whenever someone accesses this route, the \nindexAction()\n\nfunction of the class \nBlog\\Controller\\ListController\n will be executed.\nHowever, this controller does not exist yet, so if you reload the page you will\nsee this error message:\n\n\nA 404 error occurred\nPage not found.\nThe requested controller could not be mapped by routing.\n\nController:\nBlog\\Controller\\ListController(resolves to invalid controller class or alias: Blog\\Controller\\ListController)\n\n\n\nWe now need to tell our module where to find this controller named\n\nBlog\\Controller\\ListController\n. To achieve this we have to add this key to the\n\ncontrollers\n configuration key inside your\n\nmodule/Blog/config/module.config.php\n.\n\n\nnamespace Blog;\n\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    'controllers' => [\n        'factories' => [\n            Controller\\ListController::class => InvokableFactory::class,\n        ],\n    ],\n    /* ... */\n];\n\n\n\nThis configuration defines a factory for the controller class\n\nBlog\\Controller\\ListController\n, using the zend-servicemanager\n\nInvokableFactory\n (which, internally, instantiates the class with no\narguments).  Reloading the page should then give you:\n\n\nFatal error: Class 'Blog\\Controller\\ListController' not found in {projectPath}/vendor/zendframework/zend-servicemanager/src/Factory/InvokableFactory.php on line 32\n\n\n\nThis error tells us that the application knows what class to load, but was not\nable to autoload it. In our case, we've already setup autoloading, but have not\nyet defined the controller class!\n\n\nCreate the file \nmodule/Blog/src/Controller/ListController.php\n with the\nfollowing contents:\n\n\n<?php\nnamespace Blog\\Controller;\n\nclass ListController\n{\n}\n\n\n\nReloading the page now will finally result into a new screen. The new error message looks like this:\n\n\nA 404 error occurred\nPage not found.\nThe requested controller was not dispatchable.\n\nController:\nBlog\\Controller\\List(resolves to invalid controller class or alias: Blog\\Controller\\List)\n\nAdditional information:\nZend\\ServiceManager\\Exception\\InvalidServiceException\n\nFile:\n{projectPath}/vendor/zendframework/zend-mvc/src/Controller/ControllerManager.php:{lineNumber}\n\nMessage:\nPlugin of type \"Blog\\Controller\\ListController\" is invalid; must implement Zend\\Stdlib\\DispatchableInterface\n\n\n\nThis happens because our controller must implement\n\nDispatchableInterface\n\nin order to be 'dispatched' (or run) by zend-mvc. zend-mvc provides a base\ncontroller implementation of it with\n\nAbstractActionController\n,\nwhich we are going to use. Let's modify our controller now:\n\n\n// In /module/Blog/src/Blog/Controller/ListController.php:\n\nnamespace Blog\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\n\nclass ListController extends AbstractActionController\n{\n}\n\n\n\nIt's now time for another refresh of the site. You should now see a new error message:\n\n\nAn error occurred\n\nAn error occurred during execution; please try again later.\n\nAdditional information:\n\nZend\\View\\Exception\\RuntimeException\n\nFile:\n{projectPath}/vendor/zendframework/zend-view/src/Renderer/PhpRenderer.php:{lineNumber}\n\nMessage:\nZend\\View\\Renderer\\PhpRenderer::render: Unable to render template \"blog/list/index\"; resolver could not resolve to a file\n\n\n\nNow the application tells you that a view template-file can not be rendered,\nwhich is to be expected as we've not created it yet. The application is\nexpecting it to be at \nmodule/Blog/view/blog/list/index.phtml\n. Create this\nfile and add some dummy content to it:\n\n\n<!-- Filename: module/Blog/view/blog/list/index.phtml -->\n<h1>Blog\\ListController::indexAction()</h1>\n\n\n\nBefore we continue let us quickly take a look at where we placed this file. Note\nthat view files are found within the \n/view\n subdirectory, not \n/src\n as they\nare not PHP class files, but template files for rendering HTML. The path,\nhowever, deserves some explanation. First we have the lowercased namespace,\nfollowed by the lowercased controller name (without the suffix 'controller'),\nand lastly comes the name of the action that we are accessing (again without the\nsuffix 'action'). As a templated string, you can think of it as:\n\nview/{namespace}/{controller}/{action}.phtml\n. This has become a community\nstandard but you have the freedom to specify custom paths if desired.\n\n\nHowever creating this file alone is not enough and this brings as to the final\ntopic of this part of the tutorial. We need to let the application know where\nto look for view files. We do this within our module's configuration file,\n\nmodule.config.php\n.\n\n\n// In module/Blog/config/module.config.php:\n\nreturn [\n    'controllers' => [ /** Controller Configuration */ ],\n    'router'      => [ /** Route Configuration */ ]\n    'view_manager' => [\n        'template_path_stack' => [\n            __DIR__ . '/../view',\n        ],\n    ],\n];\n\n\n\nThe above configuration tells the application that the folder\n\nmodule/Blog/view/\n has view files in it that match the above described default\nscheme. It is important to note that with this you can not only ship view files\nfor your module, but you can also overwrite view files from other modules.\n\n\nReload your site now. Finally we are at a point where we see something different\nthan an error being displayed! Congratulations, not only have you created a\nsimple \"Hello World\" style module, you also learned about many error messages\nand their causes. If we didn't exhaust you too much, continue with our\ntutorial, and let's create a module that actually does something.",
            "title": "Apresentando o M\u00f3dulo Blog"
        },
        {
            "location": "/in-depth-guide/first-module/#introducing-the-blog-module",
            "text": "Now that we know about the basics of the zend-mvc skeleton application,\nlet's continue and create our very own module. We will create a module named\n\"Blog\". This module will display a list of database entries that represent a\nsingle blog post. Each post will have three properties:  id ,  text , and title . We will create forms to enter new posts into our database and to edit\nexisting posts. Furthermore we will do so by using best-practices throughout the\nwhole tutorial.",
            "title": "Introducing the Blog Module"
        },
        {
            "location": "/in-depth-guide/first-module/#writing-a-new-module",
            "text": "Let's start by creating a new folder under the  /module  directory called Blog , with the following stucture:  module/\n    Blog/\n        config/\n        src/\n        view/  To be recognized as a module by the  ModuleManager ,\nwe need to do three things:   Tell Composer how to autoload classes from our new module.  Create a  Module  class in the  Blog  namespace.  Notify the application of the new module.   Let's tell Composer about our new module. Open the  composer.json  file in the\nproject root, and edit the  autoload  section to add a new PSR-4 entry for the Blog  module; when you're done, it should read:  \"autoload\": {\n   \"psr-4\": {\n        \"Application\\\\\": \"module/Application/src/\",\n        \"Album\\\\\": \"module/Album/src/\",\n        \"Blog\\\\\": \"module/Blog/src/\"\n   }\n}  Once you're done, tell Composer to update its autoloading definitions:  $ composer dump-autoload  Next, we will create a  Module  class under the  Blog  namespace. Create the\nfile  module/Blog/src/Module.php  with the following contents:  <?php\nnamespace Blog;\n\nclass Module\n{\n}  We now have a module that can be detected by the ModuleManager .\nLet's add this module to our application. Although our module doesn't do\nanything yet, just having the  Module.php  class allows it to be loaded by the\nModuleManager.  To do this, add an entry for  Blog  to the modules array inside config/modules.config.php :  <?php\n// In config/modules.config.php:\n\nreturn [\n    /* ... */\n    'Application',\n    'Album',\n    'Blog',\n];  If you refresh your application you should see no change at all (but also no\nerrors).  At this point it's worth taking a step back to discuss what modules are for. In\nshort, a module is an encapsulated set of features for your application. A\nmodule might add features to the application that you can see, like our  Blog \nmodule; or it might provide background functionality for other modules in the\napplication to use, such as interacting with a third party API.  Organizing your code into modules makes it easier for you to reuse functionality\nin other application, or to use modules written by the community.",
            "title": "Writing a new Module"
        },
        {
            "location": "/in-depth-guide/first-module/#configuring-the-module",
            "text": "The next thing we're going to do is add a route to our application so that our\nmodule can be accessed through the URL  localhost:8080/blog . We do this by\nadding router configuration to our module, but first we need to let the ModuleManager  know that our module has configuration that it needs to load.  This is done by adding a  getConfig()  method to the  Module  class that\nreturns the configuration. (This method is defined in the ConfigProviderInterface , although explicitly implementing this interface in the\nmodule class is optional.) This method should return either an  array  or a Traversable  object. Continue by editing  module/Blog/src/Module.php :  // In /module/Blog/Module.php:\nclass Module\n{\n    public function getConfig()\n    {\n        return [];\n    }\n}  With this, our module is now able to be configured. Configuration files can\nbecome quite big, though, and keeping everything inside the  getConfig()  method\nwon't be optimal. To help keep our project organized, we're going to put our\narray configuration in a separate file. Go ahead and create this file at module/Blog/config/module.config.php :  <?php\nreturn [];  Now rewrite the  getConfig()  function to include this newly created\nfile instead of directly returning the array:  <?php\n// In /module/Blog/Module.php:\n\npublic function getConfig()\n{\n    return include __DIR__ . '/../config/module.config.php';\n}  Reload your application and you'll see that everything remains as it was. Next\nwe add the new route to our configuration file:  // In /module/Blog/config/module.config.php:\nnamespace Blog;\n\nuse Zend\\Router\\Http\\Literal;\n\nreturn [\n    // This lines opens the configuration for the RouteManager\n    'router' => [\n        // Open configuration for all possible routes\n        'routes' => [\n            // Define a new route called \"blog\"\n            'blog' => [\n                // Define a \"literal\" route type:\n                'type' => Literal::class,\n                // Configure the route itself\n                'options' => [\n                    // Listen to \"/blog\" as uri:\n                    'route' => '/blog',\n                    // Define default controller and action to be called when\n                    // this route is matched\n                    'defaults' => [\n                        'controller' => Controller\\ListController::class,\n                        'action'     => 'index',\n                    ],\n                ],\n            ],\n        ],\n    ],\n];  We've now created a route called  post  that listens to the URL localhost:8080/blog . Whenever someone accesses this route, the  indexAction() \nfunction of the class  Blog\\Controller\\ListController  will be executed.\nHowever, this controller does not exist yet, so if you reload the page you will\nsee this error message:  A 404 error occurred\nPage not found.\nThe requested controller could not be mapped by routing.\n\nController:\nBlog\\Controller\\ListController(resolves to invalid controller class or alias: Blog\\Controller\\ListController)  We now need to tell our module where to find this controller named Blog\\Controller\\ListController . To achieve this we have to add this key to the controllers  configuration key inside your module/Blog/config/module.config.php .  namespace Blog;\n\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    'controllers' => [\n        'factories' => [\n            Controller\\ListController::class => InvokableFactory::class,\n        ],\n    ],\n    /* ... */\n];  This configuration defines a factory for the controller class Blog\\Controller\\ListController , using the zend-servicemanager InvokableFactory  (which, internally, instantiates the class with no\narguments).  Reloading the page should then give you:  Fatal error: Class 'Blog\\Controller\\ListController' not found in {projectPath}/vendor/zendframework/zend-servicemanager/src/Factory/InvokableFactory.php on line 32  This error tells us that the application knows what class to load, but was not\nable to autoload it. In our case, we've already setup autoloading, but have not\nyet defined the controller class!  Create the file  module/Blog/src/Controller/ListController.php  with the\nfollowing contents:  <?php\nnamespace Blog\\Controller;\n\nclass ListController\n{\n}  Reloading the page now will finally result into a new screen. The new error message looks like this:  A 404 error occurred\nPage not found.\nThe requested controller was not dispatchable.\n\nController:\nBlog\\Controller\\List(resolves to invalid controller class or alias: Blog\\Controller\\List)\n\nAdditional information:\nZend\\ServiceManager\\Exception\\InvalidServiceException\n\nFile:\n{projectPath}/vendor/zendframework/zend-mvc/src/Controller/ControllerManager.php:{lineNumber}\n\nMessage:\nPlugin of type \"Blog\\Controller\\ListController\" is invalid; must implement Zend\\Stdlib\\DispatchableInterface  This happens because our controller must implement DispatchableInterface \nin order to be 'dispatched' (or run) by zend-mvc. zend-mvc provides a base\ncontroller implementation of it with AbstractActionController ,\nwhich we are going to use. Let's modify our controller now:  // In /module/Blog/src/Blog/Controller/ListController.php:\n\nnamespace Blog\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\n\nclass ListController extends AbstractActionController\n{\n}  It's now time for another refresh of the site. You should now see a new error message:  An error occurred\n\nAn error occurred during execution; please try again later.\n\nAdditional information:\n\nZend\\View\\Exception\\RuntimeException\n\nFile:\n{projectPath}/vendor/zendframework/zend-view/src/Renderer/PhpRenderer.php:{lineNumber}\n\nMessage:\nZend\\View\\Renderer\\PhpRenderer::render: Unable to render template \"blog/list/index\"; resolver could not resolve to a file  Now the application tells you that a view template-file can not be rendered,\nwhich is to be expected as we've not created it yet. The application is\nexpecting it to be at  module/Blog/view/blog/list/index.phtml . Create this\nfile and add some dummy content to it:  <!-- Filename: module/Blog/view/blog/list/index.phtml -->\n<h1>Blog\\ListController::indexAction()</h1>  Before we continue let us quickly take a look at where we placed this file. Note\nthat view files are found within the  /view  subdirectory, not  /src  as they\nare not PHP class files, but template files for rendering HTML. The path,\nhowever, deserves some explanation. First we have the lowercased namespace,\nfollowed by the lowercased controller name (without the suffix 'controller'),\nand lastly comes the name of the action that we are accessing (again without the\nsuffix 'action'). As a templated string, you can think of it as: view/{namespace}/{controller}/{action}.phtml . This has become a community\nstandard but you have the freedom to specify custom paths if desired.  However creating this file alone is not enough and this brings as to the final\ntopic of this part of the tutorial. We need to let the application know where\nto look for view files. We do this within our module's configuration file, module.config.php .  // In module/Blog/config/module.config.php:\n\nreturn [\n    'controllers' => [ /** Controller Configuration */ ],\n    'router'      => [ /** Route Configuration */ ]\n    'view_manager' => [\n        'template_path_stack' => [\n            __DIR__ . '/../view',\n        ],\n    ],\n];  The above configuration tells the application that the folder module/Blog/view/  has view files in it that match the above described default\nscheme. It is important to note that with this you can not only ship view files\nfor your module, but you can also overwrite view files from other modules.  Reload your site now. Finally we are at a point where we see something different\nthan an error being displayed! Congratulations, not only have you created a\nsimple \"Hello World\" style module, you also learned about many error messages\nand their causes. If we didn't exhaust you too much, continue with our\ntutorial, and let's create a module that actually does something.",
            "title": "Configuring the Module"
        },
        {
            "location": "/in-depth-guide/models-and-servicemanager/",
            "text": "Models and the ServiceManager\n\n\nIn the previous chapter we've learned how to create a \"Hello World\" Application\nusing zend-mvc. This is a good start, but the application itself doesn't really\ndo anything. In this chapter we will introduce you into the concept of models,\nand with this, introduce zend-servicemanager.\n\n\nWhat is a Model?\n\n\nA model encapsulates application logic. This often entails \nentity\n or \nvalue\n\nobjects representing specific \nthings\n in our model, and \nrepositories\n for\nretrieving and updating these objects.\n\n\nFor what we're trying to accomplish with our \nBlog\n module, this means that we\nneed functionality for retrieving and saving blog posts. The posts themselves\nare our entities, and the repository will be what we retrieve them from and save\nthem with. The model will get its data from some source; when writing the model,\nwe don't really care about what the source actually is. The model will be\nwritten against an interface that we define and that future data providers must\nimplement.\n\n\nWriting the PostRepository\n\n\nWhen writing a repository, it is a common best-practice to define an interface\nfirst. Interfaces are a good way to ensure that other programmers can easily\nbuild their own implementations. In other words, they can write classes with\nidentical function names, but which internally do completely different things,\nwhile producing the same expected results.\n\n\nIn our case, we want to create a \nPostRepository\n. This means first we are going to\ndefine a \nPostRepositoryInterface\n. The task of our repository is to provide us with\ndata from our blog posts. For now, we are going to focus on the read-only side of\nthings: we will define a method that will give us all posts, and another method\nthat will give us a single post.\n\n\nLet's start by creating the interface at\n\nmodule/Blog/src/Model/PostRepositoryInterface.php\n\n\nnamespace Blog\\Model;\n\ninterface PostRepositoryInterface\n{\n    /**\n     * Return a set of all blog posts that we can iterate over.\n     *\n     * Each entry should be a Post instance.\n     *\n     * @return Post[]\n     */\n    public function findAllPosts();\n\n    /**\n     * Return a single blog post.\n     *\n     * @param  int $id Identifier of the post to return.\n     * @return Post\n     */\n    public function findPost($id);\n}\n\n\n\nThe first method, \nfindAllPosts()\n, will return return all posts, and the second\nmethod, \nfindPost($id)\n, will return the post matching the given identifier\n\n$id\n. What's new in here is the fact that we actually define a return value\nthat doesn't exist yet. We will define this class at a later point; for now, we\nwill create the \nPostRepository\n class.\n\n\nCreate the class \nPostRepository\n at \nmodule/Blog/src/Model/PostRepository.php\n;\nbe sure to implement the \nPostRepositoryInterface\n and its required method (we\nwill fill these in later). You then should have a class that looks like the\nfollowing:\n\n\nnamespace Blog\\Model;\n\nclass PostRepository implements PostRepositoryInterface\n{\n    /**\n     * {@inheritDoc}\n     */\n    public function findAllPosts()\n    {\n        // TODO: Implement findAllPosts() method.\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function findPost($id)\n    {\n        // TODO: Implement findPost() method.\n    }\n}\n\n\n\nCreate an entity\n\n\nSince our \nPostRepository\n will return \nPost\n instances, we must create that\nclass, too. Let's create \nmodule/Blog/src/Model/Post.php\n:\n\n\nnamespace Blog\\Model;\n\nclass Post\n{\n    /**\n     * @var int\n     */\n    private $id;\n\n    /**\n     * @var string\n     */\n    private $text;\n\n    /**\n     * @var string\n     */\n    private $title;\n\n    /**\n     * @param string $title\n     * @param string $text\n     * @param int|null $id\n     */\n    public function __construct($title, $text, $id = null)\n    {\n        $this->title = $title;\n        $this->text = $text;\n        $this->id = $id;\n    }\n\n    /**\n     * @return int|null\n     */\n    public function getId()\n    {\n        return $this->id;\n    }\n\n    /**\n     * @return string\n     */\n    public function getText()\n    {\n        return $this->text;\n    }\n\n    /**\n     * @return string\n     */\n    public function getTitle()\n    {\n        return $this->title;\n    }\n}\n\n\n\nNotice that we only created getter methods; this is because each instance should\nbe unchangeable, allowing us to cache instances in the repository as necessary.\n\n\nBringing Life into our PostRepository\n\n\nNow that we have our entity in place, we can bring life into our\n\nPostRepository\n class. To keep the repository easy to understand, for now we\nwill only return some hard-coded content from our \nPostRepository\n class directly.\nCreate a property inside the \nPostRepository\n called \n$data\n and make this an array\nof our \nPost\n type. Edit \nPostReepository\n as follows:\n\n\nnamespace Blog\\Model;\n\nclass PostRepository implements PostRepositoryInterface\n{\n    private $data = [\n        1 => [\n            'id'    => 1,\n            'title' => 'Hello World #1',\n            'text'  => 'This is our first blog post!',\n        ],\n        2 => [\n            'id'    => 2,\n            'title' => 'Hello World #2',\n            'text'  => 'This is our second blog post!',\n        ],\n        3 => [\n            'id'    => 3,\n            'title' => 'Hello World #3',\n            'text'  => 'This is our third blog post!',\n        ],\n        4 => [\n            'id'    => 4,\n            'title' => 'Hello World #4',\n            'text'  => 'This is our fourth blog post!',\n        ],\n        5 => [\n            'id'    => 5,\n            'title' => 'Hello World #5',\n            'text'  => 'This is our fifth blog post!',\n        ],\n    ];\n\n    /**\n     * {@inheritDoc}\n     */\n    public function findAllPosts()\n    {\n        // TODO: Implement findAllPosts() method.\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function findPost($id)\n    {\n        // TODO: Implement findPost() method.\n    }\n}\n\n\n\nNow that we have some data, let's modify our \nfind*()\n functions to return the\nappropriate entities:\n\n\nnamespace Blog\\Model;\n\nuse DomainException;\n\nclass PostRepository implements PostRepositoryInterface\n{\n    private $data = [\n        1 => [\n            'id'    => 1,\n            'title' => 'Hello World #1',\n            'text'  => 'This is our first blog post!',\n        ],\n        2 => [\n            'id'    => 2,\n            'title' => 'Hello World #2',\n            'text'  => 'This is our second blog post!',\n        ],\n        3 => [\n            'id'    => 3,\n            'title' => 'Hello World #3',\n            'text'  => 'This is our third blog post!',\n        ],\n        4 => [\n            'id'    => 4,\n            'title' => 'Hello World #4',\n            'text'  => 'This is our fourth blog post!',\n        ],\n        5 => [\n            'id'    => 5,\n            'title' => 'Hello World #5',\n            'text'  => 'This is our fifth blog post!',\n        ],\n    ];\n\n    /**\n     * {@inheritDoc}\n     */\n    public function findAllPosts()\n    {\n        return array_map(function ($post) {\n            return new Post(\n                $post['title'],\n                $post['text'],\n                $post['id']\n            );\n        }, $this->data);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function findPost($id)\n    {\n        if (! isset($this->data[$id])) {\n            throw new DomainException(sprintf('Post by id \"%s\" not found', $id));\n        }\n\n        return new Post(\n            $this->data[$id]['title'],\n            $this->data[$id]['text'],\n            $this->data[$id]['id']\n        );\n    }\n}\n\n\n\nBoth methods now have appropriate return values. Please note that from a\ntechnical point of view, the current implementation is far from perfect. We will\nimprove this repository in the future, but for now we have a working repository\nthat is able to give us some data in a way that is defined by our\n\nPostRepositoryInterface\n.\n\n\nBringing the Service into the Controller\n\n\nNow that we have our \nPostRepository\n written, we want to get access to this\nrepository in our controllers. For this task, we will step foot into a new topic\ncalled \"Dependency Injection\" (DI).\n\n\nWhen we're talking about dependency injection, we're talking about a way to get\ndependencies into our classes. The most common form, \"Constructor Injection\", is\nused for all dependencies that are required by a class at all times.\n\n\nIn our case, we want to have our \nListController\n somehow interact with our\n\nPostRepository\n. This means that the class \nPostRepository\n is a dependency of\nthe class \nListController\n; without the \nPostRepository\n, our \nListController\n\nwill not be able to function properly. To make sure that our \nListController\n\nwill always get the appropriate dependency, we will first define the dependency\ninside the \nListController\n constructor. Modify \nListController\n as follows:\n\n\nnamespace Blog\\Controller;\n\nuse Blog\\Model\\PostRepositoryInterface;\nuse Zend\\Mvc\\Controller\\AbstractActionController;\n\nclass ListController extends AbstractActionController\n{\n    /**\n     * @var PostRepositoryInterface\n     */\n    private $postRepository;\n\n    public function __construct(PostRepositoryInterface $postRepository)\n    {\n        $this->postRepository = $postRepository;\n    }\n}\n\n\n\nThe constructor now has a required argument; we will not be able to create\ninstances of this class anymore without providing a \nPostRepositoryInterface\n\nimplementation. If you were to go back to your browser and reload your project\nwith the url \nlocalhost:8080/blog\n, you'd see the following error message:\n\n\nCatchable fatal error: Argument 1 passed to Blog\\Controller\\ListController::__construct()\nmust be an instance of Blog\\Model\\PostRepositoryInterface, none given,\ncalled in {projectPath}/vendor/zendframework/src/Factory/InvokableFactory.php on line {lineNumber}\nand defined in {projectPath}/module/Blog/src/Controller/ListController.php on line {lineNumber}\n\n\n\nAnd this error message is expected. It tells you exactly that our\n\nListController\n expects to be passed an implementation of the\n\nPostRepositoryInterface\n. So how do we make sure that our \nListController\n will\nreceive such an implementation? To solve this, we need to tell the application\nhow to create instances of the \nBlog\\Controller\\ListController\n. If you remember\nback to when we created the controller, we mapped it to the \nInvokableFactory\n\nin the module configuration:\n\n\n// In module/Blog/config/module.config.php:\nnamespace Blog;\n\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    'controllers'  => [\n        'factories' => [\n            Controller\\ListController::class => InvokableFactory::class,\n        ],\n    ],\n    'router' => [ /** Router Config */ ]\n    'view_manager' => [ /** ViewManager Config */ ],\n);\n\n\n\nThe \nInvokableFactory\n instantiates the mapped class using no constructor\narguments.  Since our \nListController\n now has a required argument, we need to\nchange this. We will now create a custom factory for our \nListController\n.\nFirst, update the configuration as follows:\n\n\n// In module/Blog/config/module.config.php:\nnamespace Blog;\n\n// Remove the InvokableFactory import statement\n\nreturn [\n    'controllers' => [\n        'factories' => [\n            // Update the following line:\n            Controller\\ListController::class => Factory\\ListControllerFactory::class,\n        ],\n    ],\n    'router' => [ /** Router Config */ ]\n    'view_manager' => [ /** ViewManager Config */ ],\n);\n\n\n\nThe above changes the mapping for the \nListController\n to use a new factory\nclass we'll be creating, \nBlog\\Factory\\ListControllerFactory\n.  If you refresh\nyour browser you'll see a different error message:\n\n\nAn error occurred\n\nAn error occurred during execution; please try again later.\n\nAdditional information:\n\nZend\\ServiceManager\\Exception\\ServiceNotFoundException\n\nFile:\n{projectPath}/zendframework/zend-servicemanager/src/ServiceManager.php:{lineNumber}\n\nMessage:\n\nUnable to resolve service \"Blog\\Controller\\ListController\" to a factory; are you\ncertain you provided it during configuration?\n\n\n\nThis exception message indicates that the service container could not resolve\nthe service to a factory, and asks if we provided it during configuration. We\ndid, so the end result is that the factory must not exist. Let's write the\nfactory now.\n\n\nWriting a Factory Class\n\n\nFactory classes for zend-servicemanager may implement either\n\nZend\\ServiceManager\\Factory\\FactoryInterface\n, or be callable classes (classes\nthat implement the \n__invoke()\n method); \nFactoryInterface\n itself defines the\n\n__invoke()\n method. The first argument is the application container, and is\nrequired; if you implement the \nFactoryInterface\n, you must also define a second\nargument, \n$requestedName\n, which is the service name mapping to the factory,\nand an optional third argument, \n$options\n, which will be any options provided\nby the controller manager at instantiation. In most situations, the last\nargument can be ignored; however, you can create re-usable factories by\nimplementing the second argument, so this is a good one to consider when writing\nyour factories! For our purposes, this is a one-off factory, so we'll only use\nthe first argument. Let's implement our factory class:\n\n\n// In /module/Blog/src/Factory/ListControllerFactory.php:\nnamespace Blog\\Factory;\n\nuse Blog\\Controller\\ListController;\nuse Blog\\Model\\PostRepositoryInterface;\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Factory\\FactoryInterface;\n\nclass ListControllerFactory implements FactoryInterface\n{\n    /**\n     * @param ContainerInterface $container\n     * @param string $requestedName\n     * @param null|array $options\n     * @return ListController\n     */\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = null)\n    {\n        return new ListController($container->get(PostRepositoryInterface::class));\n    }\n}\n\n\n\nThe factory receives an instance of the application container, which, in our\ncase, is a \nZend\\ServiceManager\\ServiceManager\n instance; these also conform to\n\nInterop\\Container\\ContainerInterface\n, allowing re-use in other dependency\ninjection systems if desired. We pull a service matching the\n\nPostRepositoryInterface\n fully qualified class name and pass it directly to the\ncontroller's constructor.\n\n\nThere's no magic happening; it's just PHP code. \n\n\nRefresh your browser and you will see this error message:\n\n\nAn error occurred\n\nAn error occurred during execution; please try again later.\n\nAdditional information:\n\nZend\\ServiceManager\\Exception\\ServiceNotFoundException\n\nFile:\n{projectPath}/vendor/zendframework/zend-servicemanager/src/ServiceManager.php:{lineNumber}\n\nMessage:\n\nUnable to resolve service \"Blog\\Model\\PostRepositoryInterface\" to a factory; are\nyou certain you provided it during configuration?\n\n\n\nExactly what we expected. Within our factory, the service\n\nBlog\\Model\\PostRepositoryInterface\n is requested but the \nServiceManager\n\ndoesn't know about it yet. Therefore it isn't able to create an instance for the\nrequested name.\n\n\nRegistering Services\n\n\nRegistering other services follows the same pattern as registering a controller.\nWe will modify our \nmodule.config.php\n and add a new key\ncalled \nservice_manager\n; the configuration of this key is the same as that for\nthe \ncontrollers\n key. We will add two entries, one for \naliases\n and one for\n\nfactories\n, as follows:\n\n\n// In module/Blog/config/module.config.php\nnamespace Blog;\n\n// Re-add the following import:\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    // Add this section:\n    'service_manager' => [\n        'aliases' => [\n            Model\\PostRepositoryInterface::class => Model\\PostRepository::class,\n        ],\n        'factories' => [\n            Model\\PostRepository::class => InvokableFactory::class,\n        ],\n    ],\n    'controllers'  => [ /** Controller Config */ ],\n    'router'       => [ /** Router Config */ ],\n    'view_manager' => [ /** View Manager Config */ ],\n];\n\n\n\nThis aliases \nPostRepositoryInterface\n to our \nPostRepository\n implementation,\nand then creates a factory for the \nPostRepository\n class by mapping it to the\n\nInvokableFactory\n (like we originally did for the \nListController\n); we can do\nthis as our \nPostRepository\n implementation has no dependencies of its own.\n\n\nTry refreshing your browser. You should see no more error messages, but rather\nexactly the page that we have created in the previous chapter of the tutorial.\n\n\nUsing the repository in our controller\n\n\nLet's now use the \nPostRepository\n within our \nListController\n. For this we will\nneed to overwrite the default \nindexAction()\n and return a view with the results\nfrom the \nPostRepository\n. Modify \nListController\n as follows:\n\n\n// In module/Blog/src/Controller/ListController.php:\nnamespace Blog\\Controller;\n\nuse Blog\\Model\\PostRepositoryInterface;\nuse Zend\\Mvc\\Controller\\AbstractActionController;\n// Add the following import statement:\nuse Zend\\View\\Model\\ViewModel;\n\nclass ListController extends AbstractActionController\n{\n    /**\n     * @var PostRepositoryInterface\n     */\n    private $postRepository;\n\n    public function __construct(PostRepositoryInterface $postRepository)\n    {\n        $this->postRepository = $postRepository;\n    }\n\n    // Add the following method:\n    public function indexAction()\n    {\n        return new ViewModel([\n            'posts' => $this->postRepository->findAllPosts(),\n        ]);\n    }\n}\n\n\n\nFirst, please note that our controller imported another class,\n\nZend\\View\\Model\\ViewModel\n; this is what controllers will usually return within\nzend-mvc applications. \nViewModel\n instances allow you to provide variables to\nrender within your template, as well as indicate which template to use.  In this\ncase we have assigned a variable called \n$posts\n with the value of whatever the\nrepository method \nfindAllPosts()\n returns (an array of \nPost\n instances).\nRefreshing the browser won't change anything yet because we haven't updated our\ntemplate to display the data.\n\n\n\n\nViewModels are not required\n\n\nYou do not actually need to return an instance of \nViewModel\n; when you return\na normal PHP array, zend-mvc internally converts it into a \nViewModel\n. The\nfollowing are equivalent:\n\n\n// Explicit ViewModel:\nreturn new ViewModel(['foo' => 'bar']);\n\n// Implicit ViewModel:\nreturn ['foo' => 'bar'];\n\n\n\n\n\nAccessing View Variables\n\n\nWhen pushing variables to the view, they are accessible in two ways: either\nusing object notation (\n$this->posts\n) or implicitly as script-level variables\n\n$posts\n). The two approaches are equivalent; however, calling \n$posts\n results\nin a little round-trip through the renderer's \n__get()\n method. We often\nrecommend using \n$this\n notation to visually differentiate between variables\npassed to the view, and those created within the script itself.\n\n\nLet's modify our view to display a table of all blog posts that our repository\nreturns:\n\n\n<!-- Filename: module/Blog/view/blog/list/index.phtml -->\n<h1>Blog</h1>\n\n<?php foreach ($this->posts as $post): ?>\n<article>\n  <h1 id=\"post<?= $post->getId() ?>\"><?= $post->getTitle() ?></h1>\n\n  <p><?= $post->getText() ?></p>\n</article>\n<?php endforeach ?>\n\n\n\nIn the view script, we iterate over the posts passed to the view model.  Since\nevery single entry of our array is of type \nBlog\\Model\\Post\n, we can use its\ngetter methods and render it.\n\n\nAfter saving this file, refresh your browser, and you should now see a list of\nblog entries!\n\n\nSummary\n\n\nIn this chapter, we learned:\n\n\n\n\nAn approach to building the models for an application.\n\n\nA little bit about dependency injection.\n\n\nHow to use zend-servicemanager to implement dependency injection in zend-mvc\n  applications.\n\n\nHow to pass variables to view scripts from the controller.\n\n\n\n\nIn the next chapter, we will take a first look at the things we should do when\nwe want to get data from a database.",
            "title": "Models e o ServiceManager"
        },
        {
            "location": "/in-depth-guide/models-and-servicemanager/#models-and-the-servicemanager",
            "text": "In the previous chapter we've learned how to create a \"Hello World\" Application\nusing zend-mvc. This is a good start, but the application itself doesn't really\ndo anything. In this chapter we will introduce you into the concept of models,\nand with this, introduce zend-servicemanager.",
            "title": "Models and the ServiceManager"
        },
        {
            "location": "/in-depth-guide/models-and-servicemanager/#what-is-a-model",
            "text": "A model encapsulates application logic. This often entails  entity  or  value \nobjects representing specific  things  in our model, and  repositories  for\nretrieving and updating these objects.  For what we're trying to accomplish with our  Blog  module, this means that we\nneed functionality for retrieving and saving blog posts. The posts themselves\nare our entities, and the repository will be what we retrieve them from and save\nthem with. The model will get its data from some source; when writing the model,\nwe don't really care about what the source actually is. The model will be\nwritten against an interface that we define and that future data providers must\nimplement.",
            "title": "What is a Model?"
        },
        {
            "location": "/in-depth-guide/models-and-servicemanager/#writing-the-postrepository",
            "text": "When writing a repository, it is a common best-practice to define an interface\nfirst. Interfaces are a good way to ensure that other programmers can easily\nbuild their own implementations. In other words, they can write classes with\nidentical function names, but which internally do completely different things,\nwhile producing the same expected results.  In our case, we want to create a  PostRepository . This means first we are going to\ndefine a  PostRepositoryInterface . The task of our repository is to provide us with\ndata from our blog posts. For now, we are going to focus on the read-only side of\nthings: we will define a method that will give us all posts, and another method\nthat will give us a single post.  Let's start by creating the interface at module/Blog/src/Model/PostRepositoryInterface.php  namespace Blog\\Model;\n\ninterface PostRepositoryInterface\n{\n    /**\n     * Return a set of all blog posts that we can iterate over.\n     *\n     * Each entry should be a Post instance.\n     *\n     * @return Post[]\n     */\n    public function findAllPosts();\n\n    /**\n     * Return a single blog post.\n     *\n     * @param  int $id Identifier of the post to return.\n     * @return Post\n     */\n    public function findPost($id);\n}  The first method,  findAllPosts() , will return return all posts, and the second\nmethod,  findPost($id) , will return the post matching the given identifier $id . What's new in here is the fact that we actually define a return value\nthat doesn't exist yet. We will define this class at a later point; for now, we\nwill create the  PostRepository  class.  Create the class  PostRepository  at  module/Blog/src/Model/PostRepository.php ;\nbe sure to implement the  PostRepositoryInterface  and its required method (we\nwill fill these in later). You then should have a class that looks like the\nfollowing:  namespace Blog\\Model;\n\nclass PostRepository implements PostRepositoryInterface\n{\n    /**\n     * {@inheritDoc}\n     */\n    public function findAllPosts()\n    {\n        // TODO: Implement findAllPosts() method.\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function findPost($id)\n    {\n        // TODO: Implement findPost() method.\n    }\n}",
            "title": "Writing the PostRepository"
        },
        {
            "location": "/in-depth-guide/models-and-servicemanager/#create-an-entity",
            "text": "Since our  PostRepository  will return  Post  instances, we must create that\nclass, too. Let's create  module/Blog/src/Model/Post.php :  namespace Blog\\Model;\n\nclass Post\n{\n    /**\n     * @var int\n     */\n    private $id;\n\n    /**\n     * @var string\n     */\n    private $text;\n\n    /**\n     * @var string\n     */\n    private $title;\n\n    /**\n     * @param string $title\n     * @param string $text\n     * @param int|null $id\n     */\n    public function __construct($title, $text, $id = null)\n    {\n        $this->title = $title;\n        $this->text = $text;\n        $this->id = $id;\n    }\n\n    /**\n     * @return int|null\n     */\n    public function getId()\n    {\n        return $this->id;\n    }\n\n    /**\n     * @return string\n     */\n    public function getText()\n    {\n        return $this->text;\n    }\n\n    /**\n     * @return string\n     */\n    public function getTitle()\n    {\n        return $this->title;\n    }\n}  Notice that we only created getter methods; this is because each instance should\nbe unchangeable, allowing us to cache instances in the repository as necessary.",
            "title": "Create an entity"
        },
        {
            "location": "/in-depth-guide/models-and-servicemanager/#bringing-life-into-our-postrepository",
            "text": "Now that we have our entity in place, we can bring life into our PostRepository  class. To keep the repository easy to understand, for now we\nwill only return some hard-coded content from our  PostRepository  class directly.\nCreate a property inside the  PostRepository  called  $data  and make this an array\nof our  Post  type. Edit  PostReepository  as follows:  namespace Blog\\Model;\n\nclass PostRepository implements PostRepositoryInterface\n{\n    private $data = [\n        1 => [\n            'id'    => 1,\n            'title' => 'Hello World #1',\n            'text'  => 'This is our first blog post!',\n        ],\n        2 => [\n            'id'    => 2,\n            'title' => 'Hello World #2',\n            'text'  => 'This is our second blog post!',\n        ],\n        3 => [\n            'id'    => 3,\n            'title' => 'Hello World #3',\n            'text'  => 'This is our third blog post!',\n        ],\n        4 => [\n            'id'    => 4,\n            'title' => 'Hello World #4',\n            'text'  => 'This is our fourth blog post!',\n        ],\n        5 => [\n            'id'    => 5,\n            'title' => 'Hello World #5',\n            'text'  => 'This is our fifth blog post!',\n        ],\n    ];\n\n    /**\n     * {@inheritDoc}\n     */\n    public function findAllPosts()\n    {\n        // TODO: Implement findAllPosts() method.\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function findPost($id)\n    {\n        // TODO: Implement findPost() method.\n    }\n}  Now that we have some data, let's modify our  find*()  functions to return the\nappropriate entities:  namespace Blog\\Model;\n\nuse DomainException;\n\nclass PostRepository implements PostRepositoryInterface\n{\n    private $data = [\n        1 => [\n            'id'    => 1,\n            'title' => 'Hello World #1',\n            'text'  => 'This is our first blog post!',\n        ],\n        2 => [\n            'id'    => 2,\n            'title' => 'Hello World #2',\n            'text'  => 'This is our second blog post!',\n        ],\n        3 => [\n            'id'    => 3,\n            'title' => 'Hello World #3',\n            'text'  => 'This is our third blog post!',\n        ],\n        4 => [\n            'id'    => 4,\n            'title' => 'Hello World #4',\n            'text'  => 'This is our fourth blog post!',\n        ],\n        5 => [\n            'id'    => 5,\n            'title' => 'Hello World #5',\n            'text'  => 'This is our fifth blog post!',\n        ],\n    ];\n\n    /**\n     * {@inheritDoc}\n     */\n    public function findAllPosts()\n    {\n        return array_map(function ($post) {\n            return new Post(\n                $post['title'],\n                $post['text'],\n                $post['id']\n            );\n        }, $this->data);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function findPost($id)\n    {\n        if (! isset($this->data[$id])) {\n            throw new DomainException(sprintf('Post by id \"%s\" not found', $id));\n        }\n\n        return new Post(\n            $this->data[$id]['title'],\n            $this->data[$id]['text'],\n            $this->data[$id]['id']\n        );\n    }\n}  Both methods now have appropriate return values. Please note that from a\ntechnical point of view, the current implementation is far from perfect. We will\nimprove this repository in the future, but for now we have a working repository\nthat is able to give us some data in a way that is defined by our PostRepositoryInterface .",
            "title": "Bringing Life into our PostRepository"
        },
        {
            "location": "/in-depth-guide/models-and-servicemanager/#bringing-the-service-into-the-controller",
            "text": "Now that we have our  PostRepository  written, we want to get access to this\nrepository in our controllers. For this task, we will step foot into a new topic\ncalled \"Dependency Injection\" (DI).  When we're talking about dependency injection, we're talking about a way to get\ndependencies into our classes. The most common form, \"Constructor Injection\", is\nused for all dependencies that are required by a class at all times.  In our case, we want to have our  ListController  somehow interact with our PostRepository . This means that the class  PostRepository  is a dependency of\nthe class  ListController ; without the  PostRepository , our  ListController \nwill not be able to function properly. To make sure that our  ListController \nwill always get the appropriate dependency, we will first define the dependency\ninside the  ListController  constructor. Modify  ListController  as follows:  namespace Blog\\Controller;\n\nuse Blog\\Model\\PostRepositoryInterface;\nuse Zend\\Mvc\\Controller\\AbstractActionController;\n\nclass ListController extends AbstractActionController\n{\n    /**\n     * @var PostRepositoryInterface\n     */\n    private $postRepository;\n\n    public function __construct(PostRepositoryInterface $postRepository)\n    {\n        $this->postRepository = $postRepository;\n    }\n}  The constructor now has a required argument; we will not be able to create\ninstances of this class anymore without providing a  PostRepositoryInterface \nimplementation. If you were to go back to your browser and reload your project\nwith the url  localhost:8080/blog , you'd see the following error message:  Catchable fatal error: Argument 1 passed to Blog\\Controller\\ListController::__construct()\nmust be an instance of Blog\\Model\\PostRepositoryInterface, none given,\ncalled in {projectPath}/vendor/zendframework/src/Factory/InvokableFactory.php on line {lineNumber}\nand defined in {projectPath}/module/Blog/src/Controller/ListController.php on line {lineNumber}  And this error message is expected. It tells you exactly that our ListController  expects to be passed an implementation of the PostRepositoryInterface . So how do we make sure that our  ListController  will\nreceive such an implementation? To solve this, we need to tell the application\nhow to create instances of the  Blog\\Controller\\ListController . If you remember\nback to when we created the controller, we mapped it to the  InvokableFactory \nin the module configuration:  // In module/Blog/config/module.config.php:\nnamespace Blog;\n\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    'controllers'  => [\n        'factories' => [\n            Controller\\ListController::class => InvokableFactory::class,\n        ],\n    ],\n    'router' => [ /** Router Config */ ]\n    'view_manager' => [ /** ViewManager Config */ ],\n);  The  InvokableFactory  instantiates the mapped class using no constructor\narguments.  Since our  ListController  now has a required argument, we need to\nchange this. We will now create a custom factory for our  ListController .\nFirst, update the configuration as follows:  // In module/Blog/config/module.config.php:\nnamespace Blog;\n\n// Remove the InvokableFactory import statement\n\nreturn [\n    'controllers' => [\n        'factories' => [\n            // Update the following line:\n            Controller\\ListController::class => Factory\\ListControllerFactory::class,\n        ],\n    ],\n    'router' => [ /** Router Config */ ]\n    'view_manager' => [ /** ViewManager Config */ ],\n);  The above changes the mapping for the  ListController  to use a new factory\nclass we'll be creating,  Blog\\Factory\\ListControllerFactory .  If you refresh\nyour browser you'll see a different error message:  An error occurred\n\nAn error occurred during execution; please try again later.\n\nAdditional information:\n\nZend\\ServiceManager\\Exception\\ServiceNotFoundException\n\nFile:\n{projectPath}/zendframework/zend-servicemanager/src/ServiceManager.php:{lineNumber}\n\nMessage:\n\nUnable to resolve service \"Blog\\Controller\\ListController\" to a factory; are you\ncertain you provided it during configuration?  This exception message indicates that the service container could not resolve\nthe service to a factory, and asks if we provided it during configuration. We\ndid, so the end result is that the factory must not exist. Let's write the\nfactory now.",
            "title": "Bringing the Service into the Controller"
        },
        {
            "location": "/in-depth-guide/models-and-servicemanager/#writing-a-factory-class",
            "text": "Factory classes for zend-servicemanager may implement either Zend\\ServiceManager\\Factory\\FactoryInterface , or be callable classes (classes\nthat implement the  __invoke()  method);  FactoryInterface  itself defines the __invoke()  method. The first argument is the application container, and is\nrequired; if you implement the  FactoryInterface , you must also define a second\nargument,  $requestedName , which is the service name mapping to the factory,\nand an optional third argument,  $options , which will be any options provided\nby the controller manager at instantiation. In most situations, the last\nargument can be ignored; however, you can create re-usable factories by\nimplementing the second argument, so this is a good one to consider when writing\nyour factories! For our purposes, this is a one-off factory, so we'll only use\nthe first argument. Let's implement our factory class:  // In /module/Blog/src/Factory/ListControllerFactory.php:\nnamespace Blog\\Factory;\n\nuse Blog\\Controller\\ListController;\nuse Blog\\Model\\PostRepositoryInterface;\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Factory\\FactoryInterface;\n\nclass ListControllerFactory implements FactoryInterface\n{\n    /**\n     * @param ContainerInterface $container\n     * @param string $requestedName\n     * @param null|array $options\n     * @return ListController\n     */\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = null)\n    {\n        return new ListController($container->get(PostRepositoryInterface::class));\n    }\n}  The factory receives an instance of the application container, which, in our\ncase, is a  Zend\\ServiceManager\\ServiceManager  instance; these also conform to Interop\\Container\\ContainerInterface , allowing re-use in other dependency\ninjection systems if desired. We pull a service matching the PostRepositoryInterface  fully qualified class name and pass it directly to the\ncontroller's constructor.  There's no magic happening; it's just PHP code.   Refresh your browser and you will see this error message:  An error occurred\n\nAn error occurred during execution; please try again later.\n\nAdditional information:\n\nZend\\ServiceManager\\Exception\\ServiceNotFoundException\n\nFile:\n{projectPath}/vendor/zendframework/zend-servicemanager/src/ServiceManager.php:{lineNumber}\n\nMessage:\n\nUnable to resolve service \"Blog\\Model\\PostRepositoryInterface\" to a factory; are\nyou certain you provided it during configuration?  Exactly what we expected. Within our factory, the service Blog\\Model\\PostRepositoryInterface  is requested but the  ServiceManager \ndoesn't know about it yet. Therefore it isn't able to create an instance for the\nrequested name.",
            "title": "Writing a Factory Class"
        },
        {
            "location": "/in-depth-guide/models-and-servicemanager/#registering-services",
            "text": "Registering other services follows the same pattern as registering a controller.\nWe will modify our  module.config.php  and add a new key\ncalled  service_manager ; the configuration of this key is the same as that for\nthe  controllers  key. We will add two entries, one for  aliases  and one for factories , as follows:  // In module/Blog/config/module.config.php\nnamespace Blog;\n\n// Re-add the following import:\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    // Add this section:\n    'service_manager' => [\n        'aliases' => [\n            Model\\PostRepositoryInterface::class => Model\\PostRepository::class,\n        ],\n        'factories' => [\n            Model\\PostRepository::class => InvokableFactory::class,\n        ],\n    ],\n    'controllers'  => [ /** Controller Config */ ],\n    'router'       => [ /** Router Config */ ],\n    'view_manager' => [ /** View Manager Config */ ],\n];  This aliases  PostRepositoryInterface  to our  PostRepository  implementation,\nand then creates a factory for the  PostRepository  class by mapping it to the InvokableFactory  (like we originally did for the  ListController ); we can do\nthis as our  PostRepository  implementation has no dependencies of its own.  Try refreshing your browser. You should see no more error messages, but rather\nexactly the page that we have created in the previous chapter of the tutorial.",
            "title": "Registering Services"
        },
        {
            "location": "/in-depth-guide/models-and-servicemanager/#using-the-repository-in-our-controller",
            "text": "Let's now use the  PostRepository  within our  ListController . For this we will\nneed to overwrite the default  indexAction()  and return a view with the results\nfrom the  PostRepository . Modify  ListController  as follows:  // In module/Blog/src/Controller/ListController.php:\nnamespace Blog\\Controller;\n\nuse Blog\\Model\\PostRepositoryInterface;\nuse Zend\\Mvc\\Controller\\AbstractActionController;\n// Add the following import statement:\nuse Zend\\View\\Model\\ViewModel;\n\nclass ListController extends AbstractActionController\n{\n    /**\n     * @var PostRepositoryInterface\n     */\n    private $postRepository;\n\n    public function __construct(PostRepositoryInterface $postRepository)\n    {\n        $this->postRepository = $postRepository;\n    }\n\n    // Add the following method:\n    public function indexAction()\n    {\n        return new ViewModel([\n            'posts' => $this->postRepository->findAllPosts(),\n        ]);\n    }\n}  First, please note that our controller imported another class, Zend\\View\\Model\\ViewModel ; this is what controllers will usually return within\nzend-mvc applications.  ViewModel  instances allow you to provide variables to\nrender within your template, as well as indicate which template to use.  In this\ncase we have assigned a variable called  $posts  with the value of whatever the\nrepository method  findAllPosts()  returns (an array of  Post  instances).\nRefreshing the browser won't change anything yet because we haven't updated our\ntemplate to display the data.",
            "title": "Using the repository in our controller"
        },
        {
            "location": "/in-depth-guide/models-and-servicemanager/#viewmodels-are-not-required",
            "text": "You do not actually need to return an instance of  ViewModel ; when you return\na normal PHP array, zend-mvc internally converts it into a  ViewModel . The\nfollowing are equivalent:  // Explicit ViewModel:\nreturn new ViewModel(['foo' => 'bar']);\n\n// Implicit ViewModel:\nreturn ['foo' => 'bar'];",
            "title": "ViewModels are not required"
        },
        {
            "location": "/in-depth-guide/models-and-servicemanager/#accessing-view-variables",
            "text": "When pushing variables to the view, they are accessible in two ways: either\nusing object notation ( $this->posts ) or implicitly as script-level variables $posts ). The two approaches are equivalent; however, calling  $posts  results\nin a little round-trip through the renderer's  __get()  method. We often\nrecommend using  $this  notation to visually differentiate between variables\npassed to the view, and those created within the script itself.  Let's modify our view to display a table of all blog posts that our repository\nreturns:  <!-- Filename: module/Blog/view/blog/list/index.phtml -->\n<h1>Blog</h1>\n\n<?php foreach ($this->posts as $post): ?>\n<article>\n  <h1 id=\"post<?= $post->getId() ?>\"><?= $post->getTitle() ?></h1>\n\n  <p><?= $post->getText() ?></p>\n</article>\n<?php endforeach ?>  In the view script, we iterate over the posts passed to the view model.  Since\nevery single entry of our array is of type  Blog\\Model\\Post , we can use its\ngetter methods and render it.  After saving this file, refresh your browser, and you should now see a list of\nblog entries!",
            "title": "Accessing View Variables"
        },
        {
            "location": "/in-depth-guide/models-and-servicemanager/#summary",
            "text": "In this chapter, we learned:   An approach to building the models for an application.  A little bit about dependency injection.  How to use zend-servicemanager to implement dependency injection in zend-mvc\n  applications.  How to pass variables to view scripts from the controller.   In the next chapter, we will take a first look at the things we should do when\nwe want to get data from a database.",
            "title": "Summary"
        },
        {
            "location": "/in-depth-guide/preparing-databases/",
            "text": "Preparing for Different Databases\n\n\nIn the previous chapter, we created a \nPostRepository\n that returns some data\nfrom blog posts. While the implementation was adequate for learning purposes, it\nis quite impractical for real world applications; no one would want to modify\nthe source files each time a new post is added! Fortunately, we an always turn\nto databases for the actual storage of posts; all we need to learn is how to\ninteract with databases within our application.\n\n\nThere's one small catch: there are many database backend systems, including\nrelational databases, documentent databases, key/value stores, and graph\ndatabases. You may be inclined to code directly to the solution that fits your\napplication's immediate needs, but it is a better practice to create another\nlayer in front of the actual database access that abstracts the database\ninteraction. The \nrepository\n approach we used in the previous chapter is one\nsuch approach, primarily geared towards \nqueries\n. In this section, we'll expand\non it to add \ncommand\n capabilities for creating, updating, and deleting\nrecords.\n\n\nWhat is database abstraction?\n\n\n\"Database abstraction\" is the act of providing a common interface for all\ndatabase interactions. Consider a SQL and a NoSQL database; both have methods\nfor CRUD (Create, Read, Update, Delete) operations. For example, to query the\ndatabase against a given row in MySQL you might use\n\n\n$results = mysqli_query('SELECT foo FROM bar')`;\n\n\n\nHowever, for MongoDB,  for example you'd use something like:\n\n\n$results = $mongoDbClient->app->bar->find([], ['foo' => 1, '_id' => 0])`;\n\n\n\nBoth engines would give you the same result, but the execution is different.\n\n\nSo if we start using a SQL database and write those codes directly into our\n\nPostRepository\n and a year later we decide to switch to a NoSQL database, the\nexisting implementation is useless to us. And in a few years later, when a new\npersistence engine pops up, we have to start over yet again.\n\n\nIf we hadn't created an interface first, we'd also likely need to change our\nconsuming code! \n\n\nOn top of that, we may find that we want to use some sort of distributed caching\nlayer for \nread\n operations (fetching items), while \nwrite\n operations will be\nwritten to a relational database. Most likely, we don't want our controllers to\nneed to worry about those implementation details, but we will want to ensure\nthat we account for this in our architecture.\n\n\nAt the code level, the interface is our abstraction layer for dealing with\ndifferences in implementations. However, currently, we only deal with queries.\nLet's expand on that.\n\n\nAdding command abstraction\n\n\nLet's first think a bit about what possible database interactions we can think\nof. We need to be able to:\n\n\n\n\nfind a single blog post\n\n\nfind all blog posts\n\n\ninsert new blog post\n\n\nupdate existing blog posts\n\n\ndelete existing blog posts\n\n\n\n\nAt this time, our \nPostRepositoryInterface\n deals with the first two.\nConsidering this is the layer that is most likely to use different backend\nimplementations, we probably want to keep it separate from the operations that\ncause changes.\n\n\nLet's create a new interface, \nBlog\\Model\\PostCommandInterface\n, in\n\nmodule/Blog/src/Model/PostCommandInterface.php\n, and have it read as follows:\n\n\nnamespace Blog\\Model;\n\ninterface PostCommandInterface\n{\n    /**\n     * Persist a new post in the system.\n     *\n     * @param Post $post The post to insert; may or may not have an identifier.\n     * @return Post The inserted post, with identifier.\n     */\n    public function insertPost(Post $post);\n\n    /**\n     * Update an existing post in the system.\n     *\n     * @param Post $post The post to update; must have an identifier.\n     * @return Post The updated post.\n     */\n    public function updatePost(Post $post);\n\n    /**\n     * Delete a post from the system.\n     *\n     * @param Post $post The post to delete.\n     * @return bool\n     */\n    public function deletePost(Post $post);\n}\n\n\n\nThis new interface defines methods for each \ncommand\n within our model. Each\nexpects a \nPost\n instance, and it is up to the implementation to determine how\nto use that instance to issue the command. In the case of an insert operation,\nour \nPost\n does not require an identifier (which is why the value is nullable in\nthe constructor), but will return a new instance that is guaranteed to have one.\nSimilarly, the update operation will return the updated post (which may be the\nsame instance!), and a delete operation will indicate if the operation was\nsuccessful.\n\n\nConclusion\n\n\nWe're not quite ready to use the new interface; we're using it to set the stage\nfor the next few chapters, where we look at using zend-db to implement our\npersistence, and later creating new controllers to handle blog post\nmanipulation.",
            "title": "Preparando-se para Bancos de Dados Diferentes"
        },
        {
            "location": "/in-depth-guide/preparing-databases/#preparing-for-different-databases",
            "text": "In the previous chapter, we created a  PostRepository  that returns some data\nfrom blog posts. While the implementation was adequate for learning purposes, it\nis quite impractical for real world applications; no one would want to modify\nthe source files each time a new post is added! Fortunately, we an always turn\nto databases for the actual storage of posts; all we need to learn is how to\ninteract with databases within our application.  There's one small catch: there are many database backend systems, including\nrelational databases, documentent databases, key/value stores, and graph\ndatabases. You may be inclined to code directly to the solution that fits your\napplication's immediate needs, but it is a better practice to create another\nlayer in front of the actual database access that abstracts the database\ninteraction. The  repository  approach we used in the previous chapter is one\nsuch approach, primarily geared towards  queries . In this section, we'll expand\non it to add  command  capabilities for creating, updating, and deleting\nrecords.",
            "title": "Preparing for Different Databases"
        },
        {
            "location": "/in-depth-guide/preparing-databases/#what-is-database-abstraction",
            "text": "\"Database abstraction\" is the act of providing a common interface for all\ndatabase interactions. Consider a SQL and a NoSQL database; both have methods\nfor CRUD (Create, Read, Update, Delete) operations. For example, to query the\ndatabase against a given row in MySQL you might use  $results = mysqli_query('SELECT foo FROM bar')`;  However, for MongoDB,  for example you'd use something like:  $results = $mongoDbClient->app->bar->find([], ['foo' => 1, '_id' => 0])`;  Both engines would give you the same result, but the execution is different.  So if we start using a SQL database and write those codes directly into our PostRepository  and a year later we decide to switch to a NoSQL database, the\nexisting implementation is useless to us. And in a few years later, when a new\npersistence engine pops up, we have to start over yet again.  If we hadn't created an interface first, we'd also likely need to change our\nconsuming code!   On top of that, we may find that we want to use some sort of distributed caching\nlayer for  read  operations (fetching items), while  write  operations will be\nwritten to a relational database. Most likely, we don't want our controllers to\nneed to worry about those implementation details, but we will want to ensure\nthat we account for this in our architecture.  At the code level, the interface is our abstraction layer for dealing with\ndifferences in implementations. However, currently, we only deal with queries.\nLet's expand on that.",
            "title": "What is database abstraction?"
        },
        {
            "location": "/in-depth-guide/preparing-databases/#adding-command-abstraction",
            "text": "Let's first think a bit about what possible database interactions we can think\nof. We need to be able to:   find a single blog post  find all blog posts  insert new blog post  update existing blog posts  delete existing blog posts   At this time, our  PostRepositoryInterface  deals with the first two.\nConsidering this is the layer that is most likely to use different backend\nimplementations, we probably want to keep it separate from the operations that\ncause changes.  Let's create a new interface,  Blog\\Model\\PostCommandInterface , in module/Blog/src/Model/PostCommandInterface.php , and have it read as follows:  namespace Blog\\Model;\n\ninterface PostCommandInterface\n{\n    /**\n     * Persist a new post in the system.\n     *\n     * @param Post $post The post to insert; may or may not have an identifier.\n     * @return Post The inserted post, with identifier.\n     */\n    public function insertPost(Post $post);\n\n    /**\n     * Update an existing post in the system.\n     *\n     * @param Post $post The post to update; must have an identifier.\n     * @return Post The updated post.\n     */\n    public function updatePost(Post $post);\n\n    /**\n     * Delete a post from the system.\n     *\n     * @param Post $post The post to delete.\n     * @return bool\n     */\n    public function deletePost(Post $post);\n}  This new interface defines methods for each  command  within our model. Each\nexpects a  Post  instance, and it is up to the implementation to determine how\nto use that instance to issue the command. In the case of an insert operation,\nour  Post  does not require an identifier (which is why the value is nullable in\nthe constructor), but will return a new instance that is guaranteed to have one.\nSimilarly, the update operation will return the updated post (which may be the\nsame instance!), and a delete operation will indicate if the operation was\nsuccessful.",
            "title": "Adding command abstraction"
        },
        {
            "location": "/in-depth-guide/preparing-databases/#conclusion",
            "text": "We're not quite ready to use the new interface; we're using it to set the stage\nfor the next few chapters, where we look at using zend-db to implement our\npersistence, and later creating new controllers to handle blog post\nmanipulation.",
            "title": "Conclusion"
        },
        {
            "location": "/in-depth-guide/zend-db-sql-zend-hydrator/",
            "text": "SQL Abstraction and Object Hydration\n\n\nIn the last chapter, we introduced database abstraction and a new command\ninterface for operations that might change what blog posts we store. We'll now\nstart creating database-backed versions of the \nPostRepositoryInterface\n and\n\nPostCommandInterface\n, demonstrating usage of the various \nZend\\Db\\Sql\n\nclasses.\n\n\nPreparing the Database\n\n\nThis tutorial assumes you've followed the \nGetting Started\n\ntutorial, and that you've already populated the \ndata/zftutorial.db\n SQLite\ndatabase. We will be re-using it, and adding another table to it.\n\n\nCreate the file \ndata/posts.schema.sql\n with the following contents:\n\n\nCREATE TABLE posts (id INTEGER PRIMARY KEY AUTOINCREMENT, title varchar(100) NOT NULL, text TEXT NOT NULL);\n\nINSERT INTO posts (title, text) VALUES ('Blog #1', 'Welcome to my first blog post');\nINSERT INTO posts (title, text) VALUES ('Blog #2', 'Welcome to my second blog post');\nINSERT INTO posts (title, text) VALUES ('Blog #3', 'Welcome to my third blog post');\nINSERT INTO posts (title, text) VALUES ('Blog #4', 'Welcome to my fourth blog post');\nINSERT INTO posts (title, text) VALUES ('Blog #5', 'Welcome to my fifth blog post');\n\n\n\nNow we will execute this against the existing \ndata/zftutorial.db\n SQLite\ndatabase using the \nsqlite\n command (or \nsqlite3\n; check your operating system):\n\n\n$ sqlite data/zftutorial.db < data/posts.schema.sql\n\n\n\nIf you don't have a \nsqlite\n command, you can populate it using PHP. Create the\nfollowing script in \ndata/load_posts.php\n:\n\n\n<?php\n$db = new PDO('sqlite:' . __DIR__ . '/zftutorial.db');\n$fh = fopen(__DIR__ . '/posts.schema.sql', 'r');\nwhile ($line = fread($fh, 4096)) {\n    $line = trim($line);\n    $db->exec($line);\n}\nfclose($fh);\n\n\n\nand execute it using:\n\n\n$ php data/load_posts.php\n\n\n\nQuick Facts Zend\\Db\\Sql\n\n\nTo create queries against a database using \nZend\\Db\\Sql\n, you need to have a\ndatabase adapter available. The \"Getting Started\" tutorial\n\ncovered this in the database chapter\n,\nand we can re-use that adapter.\n\n\nWith the adapter in place and the new table populated, we can run queries\nagainst the database. The construction of queries is best done through the\n\"QueryBuilder\" features of \nZend\\Db\\Sql\n which are \nZend\\Db\\Sql\\Sql\n for select\nqueries, \nZend\\Db\\Sql\\Insert\n for insert queries, \nZend\\Db\\Sql\\Update\n for\nupdate queries and \nZend\\Db\\Sql\\Delete\n for delete queries. The basic workflow\nof these components is:\n\n\n\n\nBuild a query using the relevant class: \nSql\n, \nInsert\n, \nUpdate\n, or\n   \nDelete\n.\n\n\nCreate a SQL statement from the \nSql\n object.\n\n\nExecute the query.\n\n\nDo something with the result.\n\n\n\n\nLet's start writing database-driven implementations of our interfaces now.\n\n\nWriting the repository implementation\n\n\nCreate a class named \nZendDbSqlRepository\n in the \nBlog\\Model\n namespace that\nimplements \nPostRepositoryInterface\n; leave the methods empty for now:\n\n\n// In module/Blog/src/Model/ZendDbSqlRepository.php:\nnamespace Blog\\Model;\n\nuse InvalidArgumentException;\nuse RuntimeException;\n\nclass ZendDbSqlRepository implements PostRepositoryInterface\n{\n    /**\n     * {@inheritDoc}\n     */\n    public function findAllPosts()\n    {\n    }\n\n    /**\n     * {@inheritDoc}\n     * @throws InvalidArgumentException\n     * @throws RuntimeException\n     */\n    public function findPost($id)\n    {\n    }\n}\n\n\n\nNow recall what we have learned earlier: for \nZend\\Db\\Sql\n to function, we will\nneed a working implementation of the \nAdapterInterface\n. This is a\n\nrequirement\n, and therefore will be injected using \nconstructor injection\n.\nCreate a \n__construct()\n method that accepts an \nAdapterInterface\n as its sole\nparameter, and stores it as an instance property:\n\n\n// In module/Blog/src/Model/ZendDbSqlRepository.php:\nnamespace Blog\\Model;\n\nuse InvalidArgumentException;\nuse RuntimeException;\nuse Zend\\Db\\Adapter\\AdapterInterface;\n\nclass ZendDbSqlRepository implements PostRepositoryInterface\n{\n    /**\n     * @var AdapterInterface\n     */\n    private $db;\n\n    /**\n     * @param AdapterInterface $db\n     */\n    public function __construct(AdapterInterface $db)\n    {\n        $this->db = $db;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function findAllPosts()\n    {\n    }\n\n    /**\n     * {@inheritDoc}\n     * @throws InvalidArgumentException\n     * @throws RuntimeException\n     */\n    public function findPost($id)\n    {\n    }\n}\n\n\n\nWhenever we have a required parameter, we need to write a factory for the class.\nGo ahead and create a factory for our new repository implementation:\n\n\n// In module/Blog/src/Factory/ZendDbSqlRepositoryFactory.php\nnamespace Blog\\Factory;\n\nuse Interop\\Container\\ContainerInterface;\nuse Blog\\Model\\ZendDbSqlRepository;\nuse Zend\\Db\\Adapter\\AdapterInterface;\nuse Zend\\ServiceManager\\Factory\\FactoryInterface;\n\nclass ZendDbSqlRepositoryFactory implements FactoryInterface\n{\n    /**\n     * @param ContainerInterface $container\n     * @param string $requestedName\n     * @param null|array $options\n     * @return ZendDbSqlRepository\n     */\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = null)\n    {\n        return new ZendDbSqlRepository($container->get(AdapterInterface::class));\n    }\n}\n\n\n\nWe're now able to register our repository implementation as a service. To do so,\nwe'll make two changes:\n\n\n\n\nRegister a factory entry for the new repository.\n\n\nUpdate the existing alias for \nPostRepositoryInterface\n to point to the new\n  repository.\n\n\n\n\nUpdate \nmodule/Blog/config/module.config.php\n as follows:\n\n\nreturn [\n    'service_manager' => [\n        'aliases' => [\n            // Update this line:\n            Model\\PostRepositoryInterface::class => Model\\ZendDbSqlRepository::class,\n        ],\n        'factories' => [\n            Model\\PostRepository::class => InvokableFactory::class,\n            // Add this line:\n            Model\\ZendDbSqlRepository::class => Factory\\ZendDbSqlRepositoryFactory::class,\n        ],\n    ],\n    'controllers'  => [ /* ... */ ],\n    'router'       => [ /* ... */ ],\n    'view_manager' => [ /* ... */ ],\n];\n\n\n\nWith the adapter in place you're now able to refresh the blog index at\n\nlocalhost:8080/blog\n and you'll notice that the \nServiceNotFoundException\n is\ngone and we get the following PHP Warning:\n\n\nWarning: Invalid argument supplied for foreach() in {projectPath}/module/Blog/view/blog/list/index.phtml on line {lineNumber}\n\n\n\nThis is due to the fact that our mapper doesn't return anything yet. Let's\nmodify the \nfindAllPosts()\n function to return all blog posts from the database\ntable:\n\n\n// In /module/Blog/src/Model/ZendDbSqlRepository.php:\nnamespace Blog\\Model;\n\nuse InvalidArgumentException;\nuse RuntimeException\nuse Zend\\Db\\Adapter\\AdapterInterface;\nuse Zend\\Db\\Sql\\Sql;\n\nclass ZendDbSqlRepository implements PostRepositoryInterface\n{\n    /**\n     * @var AdapterInterface\n     */\n    private $db;\n\n    /**\n     * @param AdapterInterface $db\n     */\n    public function __construct(AdapterInterface $db)\n    {\n        $this->db = $db;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function findAllPosts()\n    {\n        $sql    = new Sql($this->db);\n        $select = $sql->select('posts');\n        $stmt   = $sql->prepareStatementForSqlObject($select);\n        $result = $stmt->execute();\n        return $result;\n    }\n\n    /**\n     * {@inheritDoc}\n     * @throws InvalidArgumentException\n     * @throw RuntimeException\n     */\n    public function findPost($id)\n    {\n    }\n}\n\n\n\nSadly, though, a refresh of the application reveals another error message:\n\n\nPHP Fatal error:  Call to a member function getId() on array in {projectPath}/module/Blog/view/blog/list/index.phtml on line {lineNumber}\n\n\n\nLet's not return the \n$result\n variable for now and do a dump of it to see what\nwe get here. Change the \nfindAllPosts()\n method and dump the result:\n\n\npublic function findAllPosts()\n{\n    $sql    = new Sql($this->db);\n    $select = $sql->select('posts');\n    $stmt   = $sql->prepareStatementForSqlObject($select);\n    $result = $stmt->execute();\n\n    var_export($result);\n    die();\n\n    return $result;\n}\n\n\n\nRefreshing the application you should now see output similar to the following:\n\n\nZend\\Db\\Adapter\\Driver\\Pdo\\Result::__set_state(array(\n    'statementMode'   => 'forward',\n    'fetchMode'       => 2,\n    'resource'        => PDOStatement::__set_state(array(\n        'queryString' => 'SELECT \"posts\".* FROM \"posts\"',\n    )),\n    'options'         => null,\n    'currentComplete' => false,\n    'currentData'     => null,\n    'position'        => -1,\n    'generatedValue'  => '0',\n    'rowCount'        => Closure::__set_state(array()),\n))\n\n\n\nAs you can see, we do not get any data returned. Instead we are presented with a\ndump of some \nResult\n object that appears to have no data in it whatsoever. But\nthis is a faulty assumption. This \nResult\n object only has information available\nfor you when you actually try to access it. If you can determine that the query\nwas successful, the best way to make use of the data within the \nResult\n object\nis to pass it to a \nResultSet\n object.\n\n\nFirst, add two more import statements to the class file:\n\n\nuse Zend\\Db\\Adapter\\Driver\\ResultInterface;\nuse Zend\\Db\\ResultSet\\ResultSet;\n\n\n\nNow update the \nfindAllPosts()\n method as follows:\n\n\npublic function findAllPosts()\n{\n    $sql    = new Sql($this->db);\n    $select = $sql->select('posts');\n    $stmt   = $sql->prepareStatementForSqlObject($select);\n    $result = $stmt->execute();\n\n    if ($result instanceof ResultInterface && $result->isQueryResult()) {\n        $resultSet = new ResultSet();\n        $resultSet->initialize($result);\n        var_export($resultSet);\n        die();\n    }\n\n    die('no data');\n}\n\n\n\nRefreshing the page, you should now see the dump of a \nResultSet\n instance:\n\n\nZend\\Db\\ResultSet\\ResultSet::__set_state(array(\n    'allowedReturnTypes'   =>\n        array(\n            0 => 'arrayobject',\n            1 => 'array',\n        ),\n    'arrayObjectPrototype' =>\n        ArrayObject::__set_state(array(\n        )),\n    'returnType'           => 'arrayobject',\n    'buffer'               => null,\n    'count'                => null,\n    'dataSource'           =>\n        Zend\\Db\\Adapter\\Driver\\Pdo\\Result::__set_state(array(\n            'statementMode'   => 'forward',\n            'fetchMode'       => 2,\n            'resource'        =>\n                PDOStatement::__set_state(array(\n                    'queryString' => 'SELECT \"album\".* FROM \"album\"',\n                )),\n            'options'         => null,\n            'currentComplete' => false,\n            'currentData'     => null,\n            'position'        => -1,\n            'generatedValue'  => '0',\n            'rowCount'        =>\n                Closure::__set_state(array(\n                )),\n        )),\n    'fieldCount'           => 3,\n    'position'             => 0,\n))\n\n\n\nOf particular interest is the \nreturnType\n property, which has a value of\n\narrayobject\n.  This tells us that all database entries will be returned as an\n\nArrayObject\n instances. And this is a little problem for us, as the\n\nPostRepositoryInterface\n requires us to return an array of \nPost\n instances.\nLuckily the \nZend\\Db\\ResultSet\n subcomponent offers a solution for us, via the\n\nHydratingResultSet\n; this result set type will populate an object of a type we\nspecify with the data returned.\n\n\nLet's modify our code. First, remove the following import statement from the\nclass file:\n\n\nuse Zend\\Db\\ResultSet\\ResultSet;\n\n\n\nNext, we'll add the following import statements to our class file:\n\n\nuse Zend\\Hydrator\\Reflection as ReflectionHydrator;\nuse Zend\\Db\\ResultSet\\HydratingResultSet;\n\n\n\nNow, update the \nfindAllPosts()\n method to read as follows:\n\n\npublic function findAllPosts()\n{\n    $sql       = new Sql($this->db);\n    $select    = $sql->select('posts');\n    $statement = $sql->prepareStatementForSqlObject($select);\n    $result    = $statement->execute();\n\n    if (! $result instanceof ResultInterface || ! $result->isQueryResult()) {\n        return [];\n    }\n\n    $resultSet = new HydratingResultSet(\n        new ReflectionHydrator(),\n        new Post('', '')\n    );\n    $resultSet->initialize($result);\n    return $resultSet;\n}\n\n\n\nWe have changed a couple of things here. First, instead of a normal \nResultSet\n,\nwe are now using the \nHydratingResultSet\n. This specialized result set requires two parameters, the\nsecond one being an object to hydrate with data, and the first one being the\n\nhydrator\n that will be used (a \nhydrator\n is an object that will transform an\narray of data into an object, and vice versa). We use \nZend\\Hydrator\\Reflection\n\nhere, which is capable of injecting private properties of an instance. We\nprovide an empty \nPost\n instance, which the hydrator will clone to create new\ninstances with data from individual rows.\n\n\nInstead of dumping the \n$result\n variable, we now directly return the\ninitialized \nHydratingResultSet\n so we can access the data stored within. In\ncase we get something else returned that is not an instance of a\n\nResultInterface\n, we return an empty array.\n\n\nRefreshing the page you will now see all your blog posts listed on the page. Great!\n\n\nRefactoring hidden dependencies\n\n\nThere's one little thing that we have done that's not a best-practice. We use\nboth a hydrator and an \nPost\n prototype inside our \nZendDbSqlRepository\n. Let's\ninject those instead, so that we can reuse them between our repository and\ncommand implementations, or vary them based on environment. Update your\n\nZendDbSqlRepository\n as follows:\n\n\n// In module/Blog/src/Model/ZendDbSqlRepository.php:\nnamespace Blog\\Model;\n\nuse InvalidArgumentException;\nuse RuntimeException;\n// Replace the import of the Reflection hydrator with this:\nuse Zend\\Hydrator\\HydratorInterface;\nuse Zend\\Db\\Adapter\\AdapterInterface;\nuse Zend\\Db\\Adapter\\Driver\\ResultInterface;\nuse Zend\\Db\\ResultSet\\HydratingResultSet;\nuse Zend\\Db\\Sql\\Sql;\n\nclass ZendDbSqlRepository implements PostRepositoryInterface\n{\n    /**\n     * @var AdapterInterface\n     */\n    private $db;\n\n    /**\n     * @var HydratorInterface\n     */\n    private $hydrator;\n\n    /**\n     * @var Post\n     */\n    private $postPrototype;\n\n    public function __construct(\n        AdapterInterface $db,\n        HydratorInterface $hydrator,\n        Post $postPrototype\n    ) {\n        $this->db            = $db;\n        $this->hydrator      = $hydrator;\n        $this->postPrototype = $postPrototype;\n    }\n\n    /**\n     * Return a set of all blog posts that we can iterate over.\n     *\n     * Each entry should be a Post instance.\n     *\n     * @return Post[]\n     */\n    public function findAllPosts()\n    {\n        $sql       = new Sql($this->db);\n        $select    = $sql->select('posts');\n        $statement = $sql->prepareStatementForSqlObject($select);\n        $result    = $statement->execute();\n\n        if (! $result instanceof ResultInterface || ! $result->isQueryResult()) {\n            return [];\n        }\n\n        $resultSet = new HydratingResultSet($this->hydrator, $this->postPrototype);\n        $resultSet->initialize($result);\n        return $resultSet;\n    }\n\n    /**\n     * Return a single blog post.\n     *\n     * @param  int $id Identifier of the post to return.\n     * @return Post\n     */\n    public function findPost($id)\n    {\n    }\n}\n\n\n\nNow that our repository requires more parameters, we need to update the\n\nZendDbSqlRepositoryFactory\n and inject those parameters:\n\n\n// In /module/Blog/src/Factory/ZendDbSqlRepositoryFactory.php\nnamespace Blog\\Factory;\n\nuse Interop\\Container\\ContainerInterface;\nuse Blog\\Model\\Post;\nuse Blog\\Model\\ZendDbSqlRepository;\nuse Zend\\Db\\Adapter\\AdapterInterface;\nuse Zend\\Hydrator\\Reflection as ReflectionHydrator;\nuse Zend\\ServiceManager\\Factory\\FactoryInterface;\n\nclass ZendDbSqlRepositoryFactory implements FactoryInterface\n{\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = null)\n    {\n        return new ZendDbSqlRepository(\n            $container->get(AdapterInterface::class),\n            new ReflectionHydrator(),\n            new Post('', '')\n        );\n    }\n}\n\n\n\nWith this in place you can refresh the application again and you'll see your\nblog posts listed once again. Our repository no longer has hidden dependencies,\nand works with a database!\n\n\nFinishing the repository\n\n\nBefore we jump into the next chapter, let's quickly finish the repository\nimplementation by completing the \nfindPost()\n method:\n\n\npublic function findPost($id)\n{\n    $sql       = new Sql($this->db);\n    $select    = $sql->select('posts');\n    $select->where(['id = ?' => $id]);\n\n    $statement = $sql->prepareStatementForSqlObject($select);\n    $result    = $statement->execute();\n\n    if (! $result instanceof ResultInterface || ! $result->isQueryResult()) {\n        throw new RuntimeException(sprintf(\n            'Failed retrieving blog post with identifier \"%s\"; unknown database error.',\n            $id\n        ));\n    }\n\n    $resultSet = new HydratingResultSet($this->hydrator, $this->postPrototype);\n    $resultSet->initialize($result);\n    $post = $resultSet->current();\n\n    if (! $post) {\n        throw new InvalidArgumentException(sprintf(\n            'Blog post with identifier \"%s\" not found.',\n            $id\n        ));\n    }\n\n    return $post;\n}\n\n\n\nThe \nfindPost()\n function looks similar to the \nfindAllPosts()\n method, with\nseveral differences.\n\n\n\n\nWe need to add a condition to the query to select only the row matching the\n  provided identifier; this is done using the \nwhere()\n method of the \nSql\n\n  object.\n\n\nWe check if the \n$result\n is valid, using \nisQueryResult()\n; if not, an error\n  occurred during the query that we report via a \nRuntimeException\n.\n\n\nWe pull the \ncurrent()\n item off the result set we create, and test to make\n  sure we received something; if not, we had an invalid identifier, and raise an\n  \nInvalidArgumentException\n.\n\n\n\n\nConclusion\n\n\nFinishing this chapter, you now know how to \nquery\n for data using the\n\nZend\\Db\\Sql\n classes. You have also learned a little about the zend-hydrator\ncomponent, and the integration zend-db provides with it.  Furthermore, we've\ncontinued demonstrating dependency injection in all aspects of our application.\n\n\nIn the next chapter we'll take a closer look at the router so we'll be able to\nstart displaying individual blog posts.",
            "title": "Abstra\u00e7\u00e3o de SQL e Hidrata\u00e7\u00e3o de Objetos"
        },
        {
            "location": "/in-depth-guide/zend-db-sql-zend-hydrator/#sql-abstraction-and-object-hydration",
            "text": "In the last chapter, we introduced database abstraction and a new command\ninterface for operations that might change what blog posts we store. We'll now\nstart creating database-backed versions of the  PostRepositoryInterface  and PostCommandInterface , demonstrating usage of the various  Zend\\Db\\Sql \nclasses.",
            "title": "SQL Abstraction and Object Hydration"
        },
        {
            "location": "/in-depth-guide/zend-db-sql-zend-hydrator/#preparing-the-database",
            "text": "This tutorial assumes you've followed the  Getting Started \ntutorial, and that you've already populated the  data/zftutorial.db  SQLite\ndatabase. We will be re-using it, and adding another table to it.  Create the file  data/posts.schema.sql  with the following contents:  CREATE TABLE posts (id INTEGER PRIMARY KEY AUTOINCREMENT, title varchar(100) NOT NULL, text TEXT NOT NULL);\n\nINSERT INTO posts (title, text) VALUES ('Blog #1', 'Welcome to my first blog post');\nINSERT INTO posts (title, text) VALUES ('Blog #2', 'Welcome to my second blog post');\nINSERT INTO posts (title, text) VALUES ('Blog #3', 'Welcome to my third blog post');\nINSERT INTO posts (title, text) VALUES ('Blog #4', 'Welcome to my fourth blog post');\nINSERT INTO posts (title, text) VALUES ('Blog #5', 'Welcome to my fifth blog post');  Now we will execute this against the existing  data/zftutorial.db  SQLite\ndatabase using the  sqlite  command (or  sqlite3 ; check your operating system):  $ sqlite data/zftutorial.db < data/posts.schema.sql  If you don't have a  sqlite  command, you can populate it using PHP. Create the\nfollowing script in  data/load_posts.php :  <?php\n$db = new PDO('sqlite:' . __DIR__ . '/zftutorial.db');\n$fh = fopen(__DIR__ . '/posts.schema.sql', 'r');\nwhile ($line = fread($fh, 4096)) {\n    $line = trim($line);\n    $db->exec($line);\n}\nfclose($fh);  and execute it using:  $ php data/load_posts.php",
            "title": "Preparing the Database"
        },
        {
            "location": "/in-depth-guide/zend-db-sql-zend-hydrator/#quick-facts-zend92db92sql",
            "text": "To create queries against a database using  Zend\\Db\\Sql , you need to have a\ndatabase adapter available. The \"Getting Started\" tutorial covered this in the database chapter ,\nand we can re-use that adapter.  With the adapter in place and the new table populated, we can run queries\nagainst the database. The construction of queries is best done through the\n\"QueryBuilder\" features of  Zend\\Db\\Sql  which are  Zend\\Db\\Sql\\Sql  for select\nqueries,  Zend\\Db\\Sql\\Insert  for insert queries,  Zend\\Db\\Sql\\Update  for\nupdate queries and  Zend\\Db\\Sql\\Delete  for delete queries. The basic workflow\nof these components is:   Build a query using the relevant class:  Sql ,  Insert ,  Update , or\n    Delete .  Create a SQL statement from the  Sql  object.  Execute the query.  Do something with the result.   Let's start writing database-driven implementations of our interfaces now.",
            "title": "Quick Facts Zend\\Db\\Sql"
        },
        {
            "location": "/in-depth-guide/zend-db-sql-zend-hydrator/#writing-the-repository-implementation",
            "text": "Create a class named  ZendDbSqlRepository  in the  Blog\\Model  namespace that\nimplements  PostRepositoryInterface ; leave the methods empty for now:  // In module/Blog/src/Model/ZendDbSqlRepository.php:\nnamespace Blog\\Model;\n\nuse InvalidArgumentException;\nuse RuntimeException;\n\nclass ZendDbSqlRepository implements PostRepositoryInterface\n{\n    /**\n     * {@inheritDoc}\n     */\n    public function findAllPosts()\n    {\n    }\n\n    /**\n     * {@inheritDoc}\n     * @throws InvalidArgumentException\n     * @throws RuntimeException\n     */\n    public function findPost($id)\n    {\n    }\n}  Now recall what we have learned earlier: for  Zend\\Db\\Sql  to function, we will\nneed a working implementation of the  AdapterInterface . This is a requirement , and therefore will be injected using  constructor injection .\nCreate a  __construct()  method that accepts an  AdapterInterface  as its sole\nparameter, and stores it as an instance property:  // In module/Blog/src/Model/ZendDbSqlRepository.php:\nnamespace Blog\\Model;\n\nuse InvalidArgumentException;\nuse RuntimeException;\nuse Zend\\Db\\Adapter\\AdapterInterface;\n\nclass ZendDbSqlRepository implements PostRepositoryInterface\n{\n    /**\n     * @var AdapterInterface\n     */\n    private $db;\n\n    /**\n     * @param AdapterInterface $db\n     */\n    public function __construct(AdapterInterface $db)\n    {\n        $this->db = $db;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function findAllPosts()\n    {\n    }\n\n    /**\n     * {@inheritDoc}\n     * @throws InvalidArgumentException\n     * @throws RuntimeException\n     */\n    public function findPost($id)\n    {\n    }\n}  Whenever we have a required parameter, we need to write a factory for the class.\nGo ahead and create a factory for our new repository implementation:  // In module/Blog/src/Factory/ZendDbSqlRepositoryFactory.php\nnamespace Blog\\Factory;\n\nuse Interop\\Container\\ContainerInterface;\nuse Blog\\Model\\ZendDbSqlRepository;\nuse Zend\\Db\\Adapter\\AdapterInterface;\nuse Zend\\ServiceManager\\Factory\\FactoryInterface;\n\nclass ZendDbSqlRepositoryFactory implements FactoryInterface\n{\n    /**\n     * @param ContainerInterface $container\n     * @param string $requestedName\n     * @param null|array $options\n     * @return ZendDbSqlRepository\n     */\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = null)\n    {\n        return new ZendDbSqlRepository($container->get(AdapterInterface::class));\n    }\n}  We're now able to register our repository implementation as a service. To do so,\nwe'll make two changes:   Register a factory entry for the new repository.  Update the existing alias for  PostRepositoryInterface  to point to the new\n  repository.   Update  module/Blog/config/module.config.php  as follows:  return [\n    'service_manager' => [\n        'aliases' => [\n            // Update this line:\n            Model\\PostRepositoryInterface::class => Model\\ZendDbSqlRepository::class,\n        ],\n        'factories' => [\n            Model\\PostRepository::class => InvokableFactory::class,\n            // Add this line:\n            Model\\ZendDbSqlRepository::class => Factory\\ZendDbSqlRepositoryFactory::class,\n        ],\n    ],\n    'controllers'  => [ /* ... */ ],\n    'router'       => [ /* ... */ ],\n    'view_manager' => [ /* ... */ ],\n];  With the adapter in place you're now able to refresh the blog index at localhost:8080/blog  and you'll notice that the  ServiceNotFoundException  is\ngone and we get the following PHP Warning:  Warning: Invalid argument supplied for foreach() in {projectPath}/module/Blog/view/blog/list/index.phtml on line {lineNumber}  This is due to the fact that our mapper doesn't return anything yet. Let's\nmodify the  findAllPosts()  function to return all blog posts from the database\ntable:  // In /module/Blog/src/Model/ZendDbSqlRepository.php:\nnamespace Blog\\Model;\n\nuse InvalidArgumentException;\nuse RuntimeException\nuse Zend\\Db\\Adapter\\AdapterInterface;\nuse Zend\\Db\\Sql\\Sql;\n\nclass ZendDbSqlRepository implements PostRepositoryInterface\n{\n    /**\n     * @var AdapterInterface\n     */\n    private $db;\n\n    /**\n     * @param AdapterInterface $db\n     */\n    public function __construct(AdapterInterface $db)\n    {\n        $this->db = $db;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function findAllPosts()\n    {\n        $sql    = new Sql($this->db);\n        $select = $sql->select('posts');\n        $stmt   = $sql->prepareStatementForSqlObject($select);\n        $result = $stmt->execute();\n        return $result;\n    }\n\n    /**\n     * {@inheritDoc}\n     * @throws InvalidArgumentException\n     * @throw RuntimeException\n     */\n    public function findPost($id)\n    {\n    }\n}  Sadly, though, a refresh of the application reveals another error message:  PHP Fatal error:  Call to a member function getId() on array in {projectPath}/module/Blog/view/blog/list/index.phtml on line {lineNumber}  Let's not return the  $result  variable for now and do a dump of it to see what\nwe get here. Change the  findAllPosts()  method and dump the result:  public function findAllPosts()\n{\n    $sql    = new Sql($this->db);\n    $select = $sql->select('posts');\n    $stmt   = $sql->prepareStatementForSqlObject($select);\n    $result = $stmt->execute();\n\n    var_export($result);\n    die();\n\n    return $result;\n}  Refreshing the application you should now see output similar to the following:  Zend\\Db\\Adapter\\Driver\\Pdo\\Result::__set_state(array(\n    'statementMode'   => 'forward',\n    'fetchMode'       => 2,\n    'resource'        => PDOStatement::__set_state(array(\n        'queryString' => 'SELECT \"posts\".* FROM \"posts\"',\n    )),\n    'options'         => null,\n    'currentComplete' => false,\n    'currentData'     => null,\n    'position'        => -1,\n    'generatedValue'  => '0',\n    'rowCount'        => Closure::__set_state(array()),\n))  As you can see, we do not get any data returned. Instead we are presented with a\ndump of some  Result  object that appears to have no data in it whatsoever. But\nthis is a faulty assumption. This  Result  object only has information available\nfor you when you actually try to access it. If you can determine that the query\nwas successful, the best way to make use of the data within the  Result  object\nis to pass it to a  ResultSet  object.  First, add two more import statements to the class file:  use Zend\\Db\\Adapter\\Driver\\ResultInterface;\nuse Zend\\Db\\ResultSet\\ResultSet;  Now update the  findAllPosts()  method as follows:  public function findAllPosts()\n{\n    $sql    = new Sql($this->db);\n    $select = $sql->select('posts');\n    $stmt   = $sql->prepareStatementForSqlObject($select);\n    $result = $stmt->execute();\n\n    if ($result instanceof ResultInterface && $result->isQueryResult()) {\n        $resultSet = new ResultSet();\n        $resultSet->initialize($result);\n        var_export($resultSet);\n        die();\n    }\n\n    die('no data');\n}  Refreshing the page, you should now see the dump of a  ResultSet  instance:  Zend\\Db\\ResultSet\\ResultSet::__set_state(array(\n    'allowedReturnTypes'   =>\n        array(\n            0 => 'arrayobject',\n            1 => 'array',\n        ),\n    'arrayObjectPrototype' =>\n        ArrayObject::__set_state(array(\n        )),\n    'returnType'           => 'arrayobject',\n    'buffer'               => null,\n    'count'                => null,\n    'dataSource'           =>\n        Zend\\Db\\Adapter\\Driver\\Pdo\\Result::__set_state(array(\n            'statementMode'   => 'forward',\n            'fetchMode'       => 2,\n            'resource'        =>\n                PDOStatement::__set_state(array(\n                    'queryString' => 'SELECT \"album\".* FROM \"album\"',\n                )),\n            'options'         => null,\n            'currentComplete' => false,\n            'currentData'     => null,\n            'position'        => -1,\n            'generatedValue'  => '0',\n            'rowCount'        =>\n                Closure::__set_state(array(\n                )),\n        )),\n    'fieldCount'           => 3,\n    'position'             => 0,\n))  Of particular interest is the  returnType  property, which has a value of arrayobject .  This tells us that all database entries will be returned as an ArrayObject  instances. And this is a little problem for us, as the PostRepositoryInterface  requires us to return an array of  Post  instances.\nLuckily the  Zend\\Db\\ResultSet  subcomponent offers a solution for us, via the HydratingResultSet ; this result set type will populate an object of a type we\nspecify with the data returned.  Let's modify our code. First, remove the following import statement from the\nclass file:  use Zend\\Db\\ResultSet\\ResultSet;  Next, we'll add the following import statements to our class file:  use Zend\\Hydrator\\Reflection as ReflectionHydrator;\nuse Zend\\Db\\ResultSet\\HydratingResultSet;  Now, update the  findAllPosts()  method to read as follows:  public function findAllPosts()\n{\n    $sql       = new Sql($this->db);\n    $select    = $sql->select('posts');\n    $statement = $sql->prepareStatementForSqlObject($select);\n    $result    = $statement->execute();\n\n    if (! $result instanceof ResultInterface || ! $result->isQueryResult()) {\n        return [];\n    }\n\n    $resultSet = new HydratingResultSet(\n        new ReflectionHydrator(),\n        new Post('', '')\n    );\n    $resultSet->initialize($result);\n    return $resultSet;\n}  We have changed a couple of things here. First, instead of a normal  ResultSet ,\nwe are now using the  HydratingResultSet . This specialized result set requires two parameters, the\nsecond one being an object to hydrate with data, and the first one being the hydrator  that will be used (a  hydrator  is an object that will transform an\narray of data into an object, and vice versa). We use  Zend\\Hydrator\\Reflection \nhere, which is capable of injecting private properties of an instance. We\nprovide an empty  Post  instance, which the hydrator will clone to create new\ninstances with data from individual rows.  Instead of dumping the  $result  variable, we now directly return the\ninitialized  HydratingResultSet  so we can access the data stored within. In\ncase we get something else returned that is not an instance of a ResultInterface , we return an empty array.  Refreshing the page you will now see all your blog posts listed on the page. Great!",
            "title": "Writing the repository implementation"
        },
        {
            "location": "/in-depth-guide/zend-db-sql-zend-hydrator/#refactoring-hidden-dependencies",
            "text": "There's one little thing that we have done that's not a best-practice. We use\nboth a hydrator and an  Post  prototype inside our  ZendDbSqlRepository . Let's\ninject those instead, so that we can reuse them between our repository and\ncommand implementations, or vary them based on environment. Update your ZendDbSqlRepository  as follows:  // In module/Blog/src/Model/ZendDbSqlRepository.php:\nnamespace Blog\\Model;\n\nuse InvalidArgumentException;\nuse RuntimeException;\n// Replace the import of the Reflection hydrator with this:\nuse Zend\\Hydrator\\HydratorInterface;\nuse Zend\\Db\\Adapter\\AdapterInterface;\nuse Zend\\Db\\Adapter\\Driver\\ResultInterface;\nuse Zend\\Db\\ResultSet\\HydratingResultSet;\nuse Zend\\Db\\Sql\\Sql;\n\nclass ZendDbSqlRepository implements PostRepositoryInterface\n{\n    /**\n     * @var AdapterInterface\n     */\n    private $db;\n\n    /**\n     * @var HydratorInterface\n     */\n    private $hydrator;\n\n    /**\n     * @var Post\n     */\n    private $postPrototype;\n\n    public function __construct(\n        AdapterInterface $db,\n        HydratorInterface $hydrator,\n        Post $postPrototype\n    ) {\n        $this->db            = $db;\n        $this->hydrator      = $hydrator;\n        $this->postPrototype = $postPrototype;\n    }\n\n    /**\n     * Return a set of all blog posts that we can iterate over.\n     *\n     * Each entry should be a Post instance.\n     *\n     * @return Post[]\n     */\n    public function findAllPosts()\n    {\n        $sql       = new Sql($this->db);\n        $select    = $sql->select('posts');\n        $statement = $sql->prepareStatementForSqlObject($select);\n        $result    = $statement->execute();\n\n        if (! $result instanceof ResultInterface || ! $result->isQueryResult()) {\n            return [];\n        }\n\n        $resultSet = new HydratingResultSet($this->hydrator, $this->postPrototype);\n        $resultSet->initialize($result);\n        return $resultSet;\n    }\n\n    /**\n     * Return a single blog post.\n     *\n     * @param  int $id Identifier of the post to return.\n     * @return Post\n     */\n    public function findPost($id)\n    {\n    }\n}  Now that our repository requires more parameters, we need to update the ZendDbSqlRepositoryFactory  and inject those parameters:  // In /module/Blog/src/Factory/ZendDbSqlRepositoryFactory.php\nnamespace Blog\\Factory;\n\nuse Interop\\Container\\ContainerInterface;\nuse Blog\\Model\\Post;\nuse Blog\\Model\\ZendDbSqlRepository;\nuse Zend\\Db\\Adapter\\AdapterInterface;\nuse Zend\\Hydrator\\Reflection as ReflectionHydrator;\nuse Zend\\ServiceManager\\Factory\\FactoryInterface;\n\nclass ZendDbSqlRepositoryFactory implements FactoryInterface\n{\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = null)\n    {\n        return new ZendDbSqlRepository(\n            $container->get(AdapterInterface::class),\n            new ReflectionHydrator(),\n            new Post('', '')\n        );\n    }\n}  With this in place you can refresh the application again and you'll see your\nblog posts listed once again. Our repository no longer has hidden dependencies,\nand works with a database!",
            "title": "Refactoring hidden dependencies"
        },
        {
            "location": "/in-depth-guide/zend-db-sql-zend-hydrator/#finishing-the-repository",
            "text": "Before we jump into the next chapter, let's quickly finish the repository\nimplementation by completing the  findPost()  method:  public function findPost($id)\n{\n    $sql       = new Sql($this->db);\n    $select    = $sql->select('posts');\n    $select->where(['id = ?' => $id]);\n\n    $statement = $sql->prepareStatementForSqlObject($select);\n    $result    = $statement->execute();\n\n    if (! $result instanceof ResultInterface || ! $result->isQueryResult()) {\n        throw new RuntimeException(sprintf(\n            'Failed retrieving blog post with identifier \"%s\"; unknown database error.',\n            $id\n        ));\n    }\n\n    $resultSet = new HydratingResultSet($this->hydrator, $this->postPrototype);\n    $resultSet->initialize($result);\n    $post = $resultSet->current();\n\n    if (! $post) {\n        throw new InvalidArgumentException(sprintf(\n            'Blog post with identifier \"%s\" not found.',\n            $id\n        ));\n    }\n\n    return $post;\n}  The  findPost()  function looks similar to the  findAllPosts()  method, with\nseveral differences.   We need to add a condition to the query to select only the row matching the\n  provided identifier; this is done using the  where()  method of the  Sql \n  object.  We check if the  $result  is valid, using  isQueryResult() ; if not, an error\n  occurred during the query that we report via a  RuntimeException .  We pull the  current()  item off the result set we create, and test to make\n  sure we received something; if not, we had an invalid identifier, and raise an\n   InvalidArgumentException .",
            "title": "Finishing the repository"
        },
        {
            "location": "/in-depth-guide/zend-db-sql-zend-hydrator/#conclusion",
            "text": "Finishing this chapter, you now know how to  query  for data using the Zend\\Db\\Sql  classes. You have also learned a little about the zend-hydrator\ncomponent, and the integration zend-db provides with it.  Furthermore, we've\ncontinued demonstrating dependency injection in all aspects of our application.  In the next chapter we'll take a closer look at the router so we'll be able to\nstart displaying individual blog posts.",
            "title": "Conclusion"
        },
        {
            "location": "/in-depth-guide/understanding-routing/",
            "text": "Understanding the Router\n\n\nOur module is coming along nicely. However, we're not really doing all that much\nyet; to be precise, all we do is display \nall\n blog entries on one page. In this\nchapter, you will learn everything you need to know about the \nRouter\n in order\nto route to controllers and actions for displaying a single blog post, adding a\nnew blog post, editing an existing post, and deleting a post.\n\n\nDifferent route types\n\n\nBefore we go into details on our application, let's take a look at the most\noften used route types.\n\n\nLiteral routes\n\n\nAs mentioned in a previous chapter, a literal route is one that exactly matches\na specific string. Examples of URLs that can utilize literal routes include:\n\n\n\n\nhttp://domain.com/blog\n\n\nhttp://domain.com/blog/add\n\n\nhttp://domain.com/about-me\n\n\nhttp://domain.com/my/very/deep/page\n\n\n\n\nConfiguration for a literal route requires you to provide the path to match, and\nthe \"defaults\" to return on a match. The \"defaults\" are then returned as route\nmatch parameters; one use case for these is to specify the controller to invoke\nand the action method on that controller to use. As an example:\n\n\n'router' => [\n    'routes' => [\n        'about' => [\n            'type' => \\Zend\\Router\\Http\\Literal::class,\n            'options' => [\n                'route'    => '/about-me',\n                'defaults' => [\n                    'controller' => 'AboutMeController',\n                    'action'     => 'aboutme',\n                ],\n            ],\n        ],\n    ],\n],\n\n\n\nSegment routes\n\n\nSegment routes allow you to define routes with variable parameters; a common use\ncase is for specifying an identifier in the path.  Examples of URLs that might\nrequire segment routes include:\n\n\n\n\nhttp://domain.com/blog/1\n (parameter \"1\" is dynamic)\n\n\nhttp://domain.com/blog/details/1\n (parameter \"1\" is dynamic)\n\n\nhttp://domain.com/blog/edit/1\n (parameter \"1\" is dynamic)\n\n\nhttp://domain.com/blog/1/edit\n (parameter \"1\" is dynamic)\n\n\nhttp://domain.com/news/archive/2014\n (parameter \"2014\" is dynamic)\n\n\nhttp://domain.com/news/archive/2014/january\n (parameter \"2014\" and \"january\"\n   are dynamic)\n\n\n\n\nConfiguring a segment route is similar to that of a literal route.\nThe primary differences are:\n\n\n\n\nThe route will have one or more \n:<varname>\n segments, indicating items that\n  will be dynamically filled. \n<varname>\n should be a string, and will be used\n  to identify the variable to return when routing is successful.\n\n\nThe route \nmay\n also contain \noptional\n segments, which are items surrounded\n  by square braces (\n[]\n), and which can contain any mix of literal and variable\n  segments internally.\n\n\nThe \"defaults\" can include the names of variable segments; in case that\n  segment is missing, the default will be used. (They can also be completely\n  independent; for instance, the \"controller\" rarely should be included as a\n  segment!).\n\n\nYou may also specify \"constraints\" for each variable segment; each constraint\n  will be a regular expression that must pass for matching to be successful.\n\n\n\n\nAs an example, let's consider a route where we want to specify a variable \"year\"\nsegment, and indicate that the segment must contain exactly four digits; when\nmatched, we should use the \nArchiveController\n and its \nbyYear\n action:\n\n\n'router' => [\n    'routes' => [\n        'archives' => [\n            'type' => \\Zend\\Router\\Http\\Segment::class,\n            'options' => [\n                'route'    => '/news/archive[/:year]',\n                'defaults' => [\n                    'controller' => ArchiveController::class,\n                    'action'     => 'byYear',\n                    'year'       => date('Y'),\n                ],\n                'constraints' => [\n                    'year' => '\\d{4}',\n                ],\n            ],\n        ],\n    ],\n],\n\n\n\nThis configuration defines a route for a URL such as\n\n//example.com/news/archive/2014\n. The route contains the variable segment\n\n:year\n, which has a regex constraint defined as \n\\d{4}\n, indicating it will\nmatch if and only if it is exactly four digits. As such, the URL\n\n//example.com/news/archive/123\n will fail to match, but\n\n//example.com/news/archive/1234\n will.\n\n\nThe definition marks an optional segment, denoted by \n[/:year]\n. This has a\ncouple of implications. First, it means that we can also match:\n\n\n\n\n//example.com/news/archive\n\n\n//example.com/news/archive/\n\n\n\n\nIn both cases, we'll also still receive a value for the \n:year\n segment, because\nwe defined a default for it: the expression \ndate('Y')\n (returning the current\nyear).\n\n\nSegment routes allow you to dynamically match paths, and provide extensive\ncapabilities for how you shape those paths, matching variable segments, and\nproviding constraints for them.\n\n\nDifferent routing concepts\n\n\nWhen thinking about an entire application, you'll quickly realize that you may\nhave many, many routes to define.\nWhen writing these routes you have two options:\n\n\n\n\nSpend less time writing routes that in turn are a little slow in matching.\n\n\nWrite very explicit routes that match faster, but require more work to define.\n\n\n\n\nGeneric routes\n\n\nA generic route is greedy, and will match as many URLs as possible.\nA common approach is to write a route that matches the controller and action:\n\n\n'router' => [\n    'routes' => [\n        'default' => [\n            'type' => \\Zend\\Router\\Http\\Segment::class,\n            'options' => [\n                'route'    => '/[:controller[/:action]]',\n                'defaults' => [\n                    'controller' => Application\\Controller\\IndexController::class,\n                    'action'     => 'index',\n                ],\n                'constraints' => [\n                    'controller' => '[a-zA-Z][a-zA-Z0-9_-]*',\n                    'action'     => '[a-zA-Z][a-zA-Z0-9_-]*',\n                ],\n            ],\n        ],\n    ],\n],\n\n\n\nLet's take a closer look as to what has been defined in this configuration. The\n\nroute\n part now contains two optional parameters, \ncontroller\n and \naction\n.\nThe \naction\n parameter is optional only when the \ncontroller\n parameter is\npresent. Both have constraints that ensure they only allow strings that would be\nvalid PHP class and method names.\n\n\nThe big advantage of this approach is the immense time you save when developing\nyour application; one route, and then all you need to do is create controllers,\nadd action methods to them, and they are immediately available.\n\n\nThe downsides are in the details.\n\n\nIn order for this to work, you will need to use aliases when defining your\ncontrollers, so that you can alias shorter names that omit namespaces to the\nfully qualified controller class names; this sets up the potential for\ncollisions between different application modules which might define the same\ncontroller class names.\n\n\nSecond, matching nested optional segments, each with regular expression\nconstraints, adds performance overhead to routing.\n\n\nThird, such a route does not match any additional segments, constraining your\ncontrollers to omit dynamic route segments and instead rely on query string\narguments for route parameters \u2014 which in turn leaves parameter validation\nto your controllers.\n\n\nFinally, there is no guarantee that a valid match will result in a valid\ncontroller and action. As an example, if somebody requested\n\n//example.com/strange/nonExistent\n, and no controller maps to \nstrange\n, or the\ncontroller has no \nnonExistentAction()\n method, the application will use more\ncycles to discover and report the error condition than it would if routing had\nsimply failed to match. This is both a performance and a security consideration,\nas an attacker could use this fact to launch a Denial of Service.\n\n\nBasic routing\n\n\nBy now, you should be convinced that generic routes, while nice for prototyping,\nshould likely be avoided. That means defining explicit routes.\n\n\nYour initial approach might be to create one route for every permutation:\n\n\n'router' => [\n    'routes' => [\n        'news' => [\n            'type' => \\Zend\\Router\\Http\\Literal::class,\n            'options' => [\n                'route'    => '/news',\n                'defaults' => [\n                    'controller' => NewsController::class,\n                    'action'     => 'showAll',\n                ],\n            ],\n        ],\n        'news-archive' => [\n            'type' => \\Zend\\Router\\Http\\Segment::class,\n            'options' => [\n                'route'    => '/news/archive[/:year]',\n                'defaults' => [\n                    'controller' => NewsController::class,\n                    'action'     => 'archive',\n                ],\n                'constraints' => [\n                    'year' => '\\d{4}',\n                ],\n            ],\n        ],\n        'news-single' => [\n            'type' => \\Zend\\Router\\Http\\Segment::class,\n            'options' => [\n                'route'    => '/news/:id',\n                'defaults' => [\n                    'controller' => NewsController::class,\n                    'action'     => 'detail',\n                ],\n                'constraints' => [\n                    'id' => '\\d+',\n                ],\n            ],\n        ],\n    ],\n],\n\n\n\nRouting is done as a stack, meaning last in, first out (LIFO). The trick is to\ndefine your most general routes first, and your most specific routes last. In\nthe example above, our most general route is a literal match against the path\n\n/news\n. We then have two additional routes that are more specific, one matching\n\n/news/archive\n (with an optional segment for the year), and another one\nmatching \n/news/:id\n. These exhibit a fair bit of repetition:\n\n\n\n\nIn order to prevent naming collisions between routes, each route name is\n  prefixed with \nnews-\n.\n\n\nEach routing string contains \n/news\n.\n\n\nEach defines the same default controller.\n\n\n\n\nClearly, this can get tedious. Additionally, if you have many routes with\nrepitition such as this, you need to pay special attention to the stack and\npossible route overlaps, as well as performance (if the stack becomes large).\n\n\nChild routes\n\n\nTo solve the problems detailed in the last section, zend-router allows defining\n\"child routes\". Child routes inherit all \noptions\n from their respective\nparents; this means that if an option, such as the controller default, doesn't change, you do not need to\nredefine it.\n\n\nAdditionally, child routes match \nrelative\n to the parent route. This provides\nseveral optimizations:\n\n\n\n\nYou do not need to duplicate common path segments.\n\n\nRouting will ignore the child routes \nunless the parent matches\n, which can\n  provide enormous performance benefits during routing.\n\n\n\n\nLet's take a look at a child routes configuration using the same example as\nabove:\n\n\n'router' => [\n    'routes' => [\n        'news' => [\n            // First we define the basic options for the parent route:\n            'type' => \\Zend\\Router\\Http\\Literal::class,\n            'options' => [\n                'route'    => '/news',\n                'defaults' => [\n                    'controller' => NewsController::class,\n                    'action'     => 'showAll',\n                ],\n            ],\n\n            // The following allows \"/news\" to match on its own if no child\n            // routes match:\n            'may_terminate' => true,\n\n            // Child routes begin:\n            'child_routes' => [\n                'archive' => [\n                    'type' => \\Zend\\Router\\Http\\Segment::class,\n                    'options' => [\n                        'route'    => '/archive[/:year]',\n                        'defaults' => [\n                            'action' => 'archive',\n                        ],\n                        'constraints' => [\n                            'year' => '\\d{4}',\n                        ],\n                    ],\n                ],\n                'single' => [\n                    'type' => \\Zend\\Router\\Http\\Segment::class,\n                    'options' => [\n                        'route'    => '/:id',\n                        'defaults' => [\n                            'action' => 'detail',\n                        ],\n                        'constraints' => [\n                            'id' => '\\d+',\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n],\n\n\n\nAt its most basic, we define a parent route as normal, and then add an\nadditional key, \nchild_routes\n, which is normal routing configuration for\nadditional routes to match if the parent route matches.\n\n\nThe \nmay_terminate\n configuration key is used to determine if the parent route\nis allowed to match on its own; in other words, if no child routes match, is the\nparent route a valid route match? The flag is \nfalse\n by default; setting it to\n\ntrue\n allows the parent to match on its own.\n\n\nThe \nchild_routes\n themselves look like standard routing at the top-level, and\nfollow the same rules; they themselves can have child routes, too! The thing to\nremember is that any routing strings defined \nare relative to the parent\n. As\nsuch, the above definition allows matching any of the following:\n\n\n\n\n/news\n\n\n/news/archive\n\n\n/news/archive/2014\n\n\n/news/42\n\n\n\n\n(If \nmay_terminate\n was set to \nfalse\n, the first path above, \n/news\n, \nwould not\nmatch\n.)\n\n\nYou'll note that the child routes defined above do not specify a \ncontroller\n\ndefault. Child routes \ninherit options\n from the parent, however, which means\nthat, effectively, each of these will use the same controller as the parent!\n\n\nThe advantages to using child routes include:\n\n\n\n\nExplicit routes mean fewer error conditions with regards to matching\n  controllers and action methods.\n\n\nPerformance; the router ignores child routes unless the parent matches.\n\n\nDe-duplication; the parent route contains the common path prefix and common\n  options.\n\n\nOrganization; you can see at a glance all route definitions that start with a\n  common path segment.\n\n\n\n\nThe primary disadvantage is the verbosity of configuration.\n\n\nA practical example for our blog module\n\n\nNow that we know how to configure routes, let's first create a route to display\nonly a single blog entry based on internal identifier.  Given that ID is a\nvariable parameter, we need a segment route. Furthermore, we know that the route\nwill also match against the same \n/blog\n path prefix, so we can define it as a\nchild route of our existing route. Let's update our configuration:\n\n\n// In module/Blog/config/module.config.php:\nnamespace Blog;\n\nuse Zend\\Router\\Http\\Literal;\nuse Zend\\Router\\Http\\Segment;\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    'service_manager' => [ /* ... */ ],\n    'controllers'     => [ /* ... */ ],\n    'router'          => [\n        'routes' => [\n            'blog' => [\n                'type' => Literal::class,\n                'options' => [\n                    'route'    => '/blog',\n                    'defaults' => [\n                        'controller' => Controller\\ListController::class,\n                        'action'     => 'index',\n                    ],\n                ],\n                'may_terminate' => true,\n                'child_routes'  => [\n                    'detail' => [\n                        'type' => Segment::class,\n                        'options' => [\n                            'route'    => '/:id',\n                            'defaults' => [\n                                'action' => 'detail',\n                            ],\n                            'constraints' => [\n                                'id' => '[1-9]\\d*',\n                            ],\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n    'view_manager'    => [ /* ... */ ],\n];\n\n\n\nWith this we have set up a new route that we use to display a single blog entry.\nThe route defines a parameter, \nid\n, which needs to be a sequence of 1 or more\npositive digits, not beginning with 0.\n\n\nThe route will call the same \ncontroller\n as the parent route, but using\nthe \ndetailAction()\n method instead. Go to your browser and request the URL\n\nhttp://localhost:8080/blog/2\n; you'll see the following error message:\n\n\nA 404 error occurred\n\nPage not found.\n\nThe requested controller was unable to dispatch the request.\n\nController:\nBlog\\Controller\\ListController\n\nNo Exception available\n\n\n\nThis is due to the fact that the controller tries to access the\n\ndetailAction()\n, which does not yet exist. We'll create this action now; go to\nyour \nListController\n and add the following action, which will return an empty\nview model\n\n\n// In module/Blog/src/Controller/ListController.php:\n\n/* .. */\n\nclass ListController extends AbstractActionController\n{\n    /* ... */\n\n    public function detailAction()\n    {\n        return new ViewModel();\n    }\n}\n\n\n\nRefresh your browser, which should result in the familiar message that a template\nwas unable to be rendered.\n\n\nLet's create this template now and assume that we will get a \nPost\n instance\npassed to the template to see the details of our blog. Create a new view file\nunder \nmodule/Blog/view/blog/list/detail.phtml\n:\n\n\n<h1>Post Details</h1>\n\n<dl>\n    <dt>Post Title</dt>\n    <dd><?= $this->escapeHtml($this->post->getTitle()) ?></dd>\n\n    <dt>Post Text</dt>\n    <dd><?= $this->escapeHtml($this->post->getText()) ?></dd>\n</dl>\n\n\n\nThe above template is expecting a \n$post\n variable referencing a \nPost\n instance\nin the view model. We'll now update the \nListController\n to provide that:\n\n\npublic function detailAction()\n{\n    $id = $this->params()->fromRoute('id');\n\n    return new ViewModel([\n        'post' => $this->postRepository->findPost($id),\n    ]);\n}\n\n\n\nIf you refresh your application now, you'll see the details for our \nPost\n are\ndisplayed. However, there is one problem with what we have done: while we\nhave our repository set up to throw an \nInvalidArgumentException\n when no post\nis found matching a given identifier, we do not check for it in our controller.\n\n\nGo to your browser and open the URL \nhttp://localhost:8080/blog/99\n; you will\nsee the following error message:\n\n\nAn error occurred\n\nAn error occurred during execution; please try again later.\n\nAdditional information:\nInvalidArgumentException\n\nFile:\n{projectPath}/module/Blog/src/Model/ZendDbSqlRepository.php:{lineNumber}\n\nMessage:\nBlog post with identifier \"99\" not found.\n\n\n\nThis is kind of ugly, so our \nListController\n should be prepared to do something\nwhenever an \nInvalidArgumentException\n is thrown by the \nPostService\n. Let's\nhave the controller redirect to the blog post overview.\n\n\nFirst, add a new import to the \nListController\n class file:\n\n\nuse InvalidArgumentException;\n\n\n\nNow add the following try-catch statement to the \ndetailAction()\n method:\n\n\npublic function detailAction()\n{\n    $id = $this->params()->fromRoute('id');\n\n    try {\n        $post = $this->postRepository->findPost($id);\n    } catch (\\InvalidArgumentException $ex) {\n        return $this->redirect()->toRoute('blog');\n    }\n\n    return new ViewModel([\n        'post' => $post,\n    ]);\n}\n\n\n\nNow whenever a user requests an invalid identifier, you'll be redirected to the\nroute \nblog\n, which is our list of blog posts!",
            "title": "Entendendo o Router"
        },
        {
            "location": "/in-depth-guide/understanding-routing/#understanding-the-router",
            "text": "Our module is coming along nicely. However, we're not really doing all that much\nyet; to be precise, all we do is display  all  blog entries on one page. In this\nchapter, you will learn everything you need to know about the  Router  in order\nto route to controllers and actions for displaying a single blog post, adding a\nnew blog post, editing an existing post, and deleting a post.",
            "title": "Understanding the Router"
        },
        {
            "location": "/in-depth-guide/understanding-routing/#different-route-types",
            "text": "Before we go into details on our application, let's take a look at the most\noften used route types.",
            "title": "Different route types"
        },
        {
            "location": "/in-depth-guide/understanding-routing/#literal-routes",
            "text": "As mentioned in a previous chapter, a literal route is one that exactly matches\na specific string. Examples of URLs that can utilize literal routes include:   http://domain.com/blog  http://domain.com/blog/add  http://domain.com/about-me  http://domain.com/my/very/deep/page   Configuration for a literal route requires you to provide the path to match, and\nthe \"defaults\" to return on a match. The \"defaults\" are then returned as route\nmatch parameters; one use case for these is to specify the controller to invoke\nand the action method on that controller to use. As an example:  'router' => [\n    'routes' => [\n        'about' => [\n            'type' => \\Zend\\Router\\Http\\Literal::class,\n            'options' => [\n                'route'    => '/about-me',\n                'defaults' => [\n                    'controller' => 'AboutMeController',\n                    'action'     => 'aboutme',\n                ],\n            ],\n        ],\n    ],\n],",
            "title": "Literal routes"
        },
        {
            "location": "/in-depth-guide/understanding-routing/#segment-routes",
            "text": "Segment routes allow you to define routes with variable parameters; a common use\ncase is for specifying an identifier in the path.  Examples of URLs that might\nrequire segment routes include:   http://domain.com/blog/1  (parameter \"1\" is dynamic)  http://domain.com/blog/details/1  (parameter \"1\" is dynamic)  http://domain.com/blog/edit/1  (parameter \"1\" is dynamic)  http://domain.com/blog/1/edit  (parameter \"1\" is dynamic)  http://domain.com/news/archive/2014  (parameter \"2014\" is dynamic)  http://domain.com/news/archive/2014/january  (parameter \"2014\" and \"january\"\n   are dynamic)   Configuring a segment route is similar to that of a literal route.\nThe primary differences are:   The route will have one or more  :<varname>  segments, indicating items that\n  will be dynamically filled.  <varname>  should be a string, and will be used\n  to identify the variable to return when routing is successful.  The route  may  also contain  optional  segments, which are items surrounded\n  by square braces ( [] ), and which can contain any mix of literal and variable\n  segments internally.  The \"defaults\" can include the names of variable segments; in case that\n  segment is missing, the default will be used. (They can also be completely\n  independent; for instance, the \"controller\" rarely should be included as a\n  segment!).  You may also specify \"constraints\" for each variable segment; each constraint\n  will be a regular expression that must pass for matching to be successful.   As an example, let's consider a route where we want to specify a variable \"year\"\nsegment, and indicate that the segment must contain exactly four digits; when\nmatched, we should use the  ArchiveController  and its  byYear  action:  'router' => [\n    'routes' => [\n        'archives' => [\n            'type' => \\Zend\\Router\\Http\\Segment::class,\n            'options' => [\n                'route'    => '/news/archive[/:year]',\n                'defaults' => [\n                    'controller' => ArchiveController::class,\n                    'action'     => 'byYear',\n                    'year'       => date('Y'),\n                ],\n                'constraints' => [\n                    'year' => '\\d{4}',\n                ],\n            ],\n        ],\n    ],\n],  This configuration defines a route for a URL such as //example.com/news/archive/2014 . The route contains the variable segment :year , which has a regex constraint defined as  \\d{4} , indicating it will\nmatch if and only if it is exactly four digits. As such, the URL //example.com/news/archive/123  will fail to match, but //example.com/news/archive/1234  will.  The definition marks an optional segment, denoted by  [/:year] . This has a\ncouple of implications. First, it means that we can also match:   //example.com/news/archive  //example.com/news/archive/   In both cases, we'll also still receive a value for the  :year  segment, because\nwe defined a default for it: the expression  date('Y')  (returning the current\nyear).  Segment routes allow you to dynamically match paths, and provide extensive\ncapabilities for how you shape those paths, matching variable segments, and\nproviding constraints for them.",
            "title": "Segment routes"
        },
        {
            "location": "/in-depth-guide/understanding-routing/#different-routing-concepts",
            "text": "When thinking about an entire application, you'll quickly realize that you may\nhave many, many routes to define.\nWhen writing these routes you have two options:   Spend less time writing routes that in turn are a little slow in matching.  Write very explicit routes that match faster, but require more work to define.",
            "title": "Different routing concepts"
        },
        {
            "location": "/in-depth-guide/understanding-routing/#generic-routes",
            "text": "A generic route is greedy, and will match as many URLs as possible.\nA common approach is to write a route that matches the controller and action:  'router' => [\n    'routes' => [\n        'default' => [\n            'type' => \\Zend\\Router\\Http\\Segment::class,\n            'options' => [\n                'route'    => '/[:controller[/:action]]',\n                'defaults' => [\n                    'controller' => Application\\Controller\\IndexController::class,\n                    'action'     => 'index',\n                ],\n                'constraints' => [\n                    'controller' => '[a-zA-Z][a-zA-Z0-9_-]*',\n                    'action'     => '[a-zA-Z][a-zA-Z0-9_-]*',\n                ],\n            ],\n        ],\n    ],\n],  Let's take a closer look as to what has been defined in this configuration. The route  part now contains two optional parameters,  controller  and  action .\nThe  action  parameter is optional only when the  controller  parameter is\npresent. Both have constraints that ensure they only allow strings that would be\nvalid PHP class and method names.  The big advantage of this approach is the immense time you save when developing\nyour application; one route, and then all you need to do is create controllers,\nadd action methods to them, and they are immediately available.  The downsides are in the details.  In order for this to work, you will need to use aliases when defining your\ncontrollers, so that you can alias shorter names that omit namespaces to the\nfully qualified controller class names; this sets up the potential for\ncollisions between different application modules which might define the same\ncontroller class names.  Second, matching nested optional segments, each with regular expression\nconstraints, adds performance overhead to routing.  Third, such a route does not match any additional segments, constraining your\ncontrollers to omit dynamic route segments and instead rely on query string\narguments for route parameters \u2014 which in turn leaves parameter validation\nto your controllers.  Finally, there is no guarantee that a valid match will result in a valid\ncontroller and action. As an example, if somebody requested //example.com/strange/nonExistent , and no controller maps to  strange , or the\ncontroller has no  nonExistentAction()  method, the application will use more\ncycles to discover and report the error condition than it would if routing had\nsimply failed to match. This is both a performance and a security consideration,\nas an attacker could use this fact to launch a Denial of Service.",
            "title": "Generic routes"
        },
        {
            "location": "/in-depth-guide/understanding-routing/#basic-routing",
            "text": "By now, you should be convinced that generic routes, while nice for prototyping,\nshould likely be avoided. That means defining explicit routes.  Your initial approach might be to create one route for every permutation:  'router' => [\n    'routes' => [\n        'news' => [\n            'type' => \\Zend\\Router\\Http\\Literal::class,\n            'options' => [\n                'route'    => '/news',\n                'defaults' => [\n                    'controller' => NewsController::class,\n                    'action'     => 'showAll',\n                ],\n            ],\n        ],\n        'news-archive' => [\n            'type' => \\Zend\\Router\\Http\\Segment::class,\n            'options' => [\n                'route'    => '/news/archive[/:year]',\n                'defaults' => [\n                    'controller' => NewsController::class,\n                    'action'     => 'archive',\n                ],\n                'constraints' => [\n                    'year' => '\\d{4}',\n                ],\n            ],\n        ],\n        'news-single' => [\n            'type' => \\Zend\\Router\\Http\\Segment::class,\n            'options' => [\n                'route'    => '/news/:id',\n                'defaults' => [\n                    'controller' => NewsController::class,\n                    'action'     => 'detail',\n                ],\n                'constraints' => [\n                    'id' => '\\d+',\n                ],\n            ],\n        ],\n    ],\n],  Routing is done as a stack, meaning last in, first out (LIFO). The trick is to\ndefine your most general routes first, and your most specific routes last. In\nthe example above, our most general route is a literal match against the path /news . We then have two additional routes that are more specific, one matching /news/archive  (with an optional segment for the year), and another one\nmatching  /news/:id . These exhibit a fair bit of repetition:   In order to prevent naming collisions between routes, each route name is\n  prefixed with  news- .  Each routing string contains  /news .  Each defines the same default controller.   Clearly, this can get tedious. Additionally, if you have many routes with\nrepitition such as this, you need to pay special attention to the stack and\npossible route overlaps, as well as performance (if the stack becomes large).",
            "title": "Basic routing"
        },
        {
            "location": "/in-depth-guide/understanding-routing/#child-routes",
            "text": "To solve the problems detailed in the last section, zend-router allows defining\n\"child routes\". Child routes inherit all  options  from their respective\nparents; this means that if an option, such as the controller default, doesn't change, you do not need to\nredefine it.  Additionally, child routes match  relative  to the parent route. This provides\nseveral optimizations:   You do not need to duplicate common path segments.  Routing will ignore the child routes  unless the parent matches , which can\n  provide enormous performance benefits during routing.   Let's take a look at a child routes configuration using the same example as\nabove:  'router' => [\n    'routes' => [\n        'news' => [\n            // First we define the basic options for the parent route:\n            'type' => \\Zend\\Router\\Http\\Literal::class,\n            'options' => [\n                'route'    => '/news',\n                'defaults' => [\n                    'controller' => NewsController::class,\n                    'action'     => 'showAll',\n                ],\n            ],\n\n            // The following allows \"/news\" to match on its own if no child\n            // routes match:\n            'may_terminate' => true,\n\n            // Child routes begin:\n            'child_routes' => [\n                'archive' => [\n                    'type' => \\Zend\\Router\\Http\\Segment::class,\n                    'options' => [\n                        'route'    => '/archive[/:year]',\n                        'defaults' => [\n                            'action' => 'archive',\n                        ],\n                        'constraints' => [\n                            'year' => '\\d{4}',\n                        ],\n                    ],\n                ],\n                'single' => [\n                    'type' => \\Zend\\Router\\Http\\Segment::class,\n                    'options' => [\n                        'route'    => '/:id',\n                        'defaults' => [\n                            'action' => 'detail',\n                        ],\n                        'constraints' => [\n                            'id' => '\\d+',\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n],  At its most basic, we define a parent route as normal, and then add an\nadditional key,  child_routes , which is normal routing configuration for\nadditional routes to match if the parent route matches.  The  may_terminate  configuration key is used to determine if the parent route\nis allowed to match on its own; in other words, if no child routes match, is the\nparent route a valid route match? The flag is  false  by default; setting it to true  allows the parent to match on its own.  The  child_routes  themselves look like standard routing at the top-level, and\nfollow the same rules; they themselves can have child routes, too! The thing to\nremember is that any routing strings defined  are relative to the parent . As\nsuch, the above definition allows matching any of the following:   /news  /news/archive  /news/archive/2014  /news/42   (If  may_terminate  was set to  false , the first path above,  /news ,  would not\nmatch .)  You'll note that the child routes defined above do not specify a  controller \ndefault. Child routes  inherit options  from the parent, however, which means\nthat, effectively, each of these will use the same controller as the parent!  The advantages to using child routes include:   Explicit routes mean fewer error conditions with regards to matching\n  controllers and action methods.  Performance; the router ignores child routes unless the parent matches.  De-duplication; the parent route contains the common path prefix and common\n  options.  Organization; you can see at a glance all route definitions that start with a\n  common path segment.   The primary disadvantage is the verbosity of configuration.",
            "title": "Child routes"
        },
        {
            "location": "/in-depth-guide/understanding-routing/#a-practical-example-for-our-blog-module",
            "text": "Now that we know how to configure routes, let's first create a route to display\nonly a single blog entry based on internal identifier.  Given that ID is a\nvariable parameter, we need a segment route. Furthermore, we know that the route\nwill also match against the same  /blog  path prefix, so we can define it as a\nchild route of our existing route. Let's update our configuration:  // In module/Blog/config/module.config.php:\nnamespace Blog;\n\nuse Zend\\Router\\Http\\Literal;\nuse Zend\\Router\\Http\\Segment;\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    'service_manager' => [ /* ... */ ],\n    'controllers'     => [ /* ... */ ],\n    'router'          => [\n        'routes' => [\n            'blog' => [\n                'type' => Literal::class,\n                'options' => [\n                    'route'    => '/blog',\n                    'defaults' => [\n                        'controller' => Controller\\ListController::class,\n                        'action'     => 'index',\n                    ],\n                ],\n                'may_terminate' => true,\n                'child_routes'  => [\n                    'detail' => [\n                        'type' => Segment::class,\n                        'options' => [\n                            'route'    => '/:id',\n                            'defaults' => [\n                                'action' => 'detail',\n                            ],\n                            'constraints' => [\n                                'id' => '[1-9]\\d*',\n                            ],\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n    'view_manager'    => [ /* ... */ ],\n];  With this we have set up a new route that we use to display a single blog entry.\nThe route defines a parameter,  id , which needs to be a sequence of 1 or more\npositive digits, not beginning with 0.  The route will call the same  controller  as the parent route, but using\nthe  detailAction()  method instead. Go to your browser and request the URL http://localhost:8080/blog/2 ; you'll see the following error message:  A 404 error occurred\n\nPage not found.\n\nThe requested controller was unable to dispatch the request.\n\nController:\nBlog\\Controller\\ListController\n\nNo Exception available  This is due to the fact that the controller tries to access the detailAction() , which does not yet exist. We'll create this action now; go to\nyour  ListController  and add the following action, which will return an empty\nview model  // In module/Blog/src/Controller/ListController.php:\n\n/* .. */\n\nclass ListController extends AbstractActionController\n{\n    /* ... */\n\n    public function detailAction()\n    {\n        return new ViewModel();\n    }\n}  Refresh your browser, which should result in the familiar message that a template\nwas unable to be rendered.  Let's create this template now and assume that we will get a  Post  instance\npassed to the template to see the details of our blog. Create a new view file\nunder  module/Blog/view/blog/list/detail.phtml :  <h1>Post Details</h1>\n\n<dl>\n    <dt>Post Title</dt>\n    <dd><?= $this->escapeHtml($this->post->getTitle()) ?></dd>\n\n    <dt>Post Text</dt>\n    <dd><?= $this->escapeHtml($this->post->getText()) ?></dd>\n</dl>  The above template is expecting a  $post  variable referencing a  Post  instance\nin the view model. We'll now update the  ListController  to provide that:  public function detailAction()\n{\n    $id = $this->params()->fromRoute('id');\n\n    return new ViewModel([\n        'post' => $this->postRepository->findPost($id),\n    ]);\n}  If you refresh your application now, you'll see the details for our  Post  are\ndisplayed. However, there is one problem with what we have done: while we\nhave our repository set up to throw an  InvalidArgumentException  when no post\nis found matching a given identifier, we do not check for it in our controller.  Go to your browser and open the URL  http://localhost:8080/blog/99 ; you will\nsee the following error message:  An error occurred\n\nAn error occurred during execution; please try again later.\n\nAdditional information:\nInvalidArgumentException\n\nFile:\n{projectPath}/module/Blog/src/Model/ZendDbSqlRepository.php:{lineNumber}\n\nMessage:\nBlog post with identifier \"99\" not found.  This is kind of ugly, so our  ListController  should be prepared to do something\nwhenever an  InvalidArgumentException  is thrown by the  PostService . Let's\nhave the controller redirect to the blog post overview.  First, add a new import to the  ListController  class file:  use InvalidArgumentException;  Now add the following try-catch statement to the  detailAction()  method:  public function detailAction()\n{\n    $id = $this->params()->fromRoute('id');\n\n    try {\n        $post = $this->postRepository->findPost($id);\n    } catch (\\InvalidArgumentException $ex) {\n        return $this->redirect()->toRoute('blog');\n    }\n\n    return new ViewModel([\n        'post' => $post,\n    ]);\n}  Now whenever a user requests an invalid identifier, you'll be redirected to the\nroute  blog , which is our list of blog posts!",
            "title": "A practical example for our blog module"
        },
        {
            "location": "/in-depth-guide/zend-form-zend-form-fieldset/",
            "text": "Making Use of Forms and Fieldsets\n\n\nSo far all we have done is read data from the database. In a real-life\napplication, this won't get us very far, as we'll often need to support the full\nrange of full \nCreate\n, \nRead\n, \nUpdate\n and \nDelete\n operations (CRUD).\nTypically, new data will arrive via web form submissions.\n\n\nForm components\n\n\nThe \nzend-form\n and\n\nzend-inputfilter\n components\nprovide us with the ability to create fully-featured forms and their validation\nrules. zend-form consumes zend-inputfilter internally, so let's take a look at\nthe elements of zend-form that we will use for our application.\n\n\nFieldsets\n\n\nZend\\Form\\Fieldset\n models a reusable set of elements. You will use a\n\nFieldset\n to create the various HTML inputs needed to map to your server-side\nentities. It is considered good practice to have one \nFieldset\n for every entity\nin your application.\n\n\nThe \nFieldset\n component, however, is not a form, meaning you will not be able\nto use a \nFieldset\n without attaching it to the \nZend\\Form\\Form\n instance. The\nadvantage here is that you have one set of elements that you can re-use for as\nmany forms as you like.\n\n\nForms\n\n\nZend\\Form\\Form\n is a container for all elements of your HTML \n<form>\n. You are\nable to add both single elements or fieldsets (modeled as \nZend\\Form\\Fieldset\n\ninstances).\n\n\nCreating your first Fieldset\n\n\nExplaining how zend-form works is best done by giving you real\ncode to work with. So let's jump right into it and create all the forms we need\nto finish our \nBlog\n module. We start by creating a \nFieldset\n that contains all\nthe input elements that we need to work with our blog data:\n\n\n\n\nYou will need one hidden input for the \nid\n property, which is only needed for\n  editting and deleting data.\n\n\nYou will need one text input for the \ntitle\n property.\n\n\nYou will need one textarea for the \ntext\n property.\n\n\n\n\nCreate the file \nmodule/Blog/src/Form/PostFieldset.php\n with the following\ncontents:\n\n\n<?php\nnamespace Blog\\Form;\n\nuse Zend\\Form\\Fieldset;\n\nclass PostFieldset extends Fieldset\n{\n    public function init()\n    {\n        $this->add([\n            'type' => 'hidden',\n            'name' => 'id',\n        ]);\n\n        $this->add([\n            'type' => 'text',\n            'name' => 'title',\n            'options' => [\n                'label' => 'Post Title',\n            ],\n        ]);\n\n        $this->add([\n            'type' => 'textarea',\n            'name' => 'text',\n            'options' => [\n                'label' => 'Post Text',\n            ],\n        ]);\n    }\n}\n\n\n\nThis new class creates an extension of \nZend\\Form\\Fieldset\n that, in an \ninit()\n\nmethod (more on this later),  adds elements for each aspect of our blog post. We\ncan now re-use this fieldset in as many forms as we want. Let's create our first\nform.\n\n\nCreating the PostForm\n\n\nNow that we have our \nPostFieldset\n in place, we can use it inside a \nForm\n.\nThe form will use the \nPostFieldset\n, and also include a submit button so that\nthe user can submit the data.\n\n\nCreate the file \nmodule/Blog/src/Form/PostForm.php\n with the following contents:\n\n\n<?php\nnamespace Blog\\Form;\n\nuse Zend\\Form\\Form;\n\nclass PostForm extends Form\n{\n    public function init()\n    {\n        $this->add([\n            'name' => 'post',\n            'type' => PostFieldset::class,\n        ]);\n\n        $this->add([\n            'type' => 'submit',\n            'name' => 'submit',\n            'attributes' => [\n                'value' => 'Insert new Post',\n            ],\n        ]);\n    }\n}\n\n\n\nAnd that's our form. Nothing special here, we add our \nPostFieldset\n to the\nform, we add a submit button to the form, and nothing more.\n\n\nAdding a new Post\n\n\nNow that we have the \nPostForm\n written, it's time to use it. But there are a\nfew more tasks left:\n\n\n\n\nWe need to create a new controller \nWriteController\n which accepts the\n  following instances via its constructor:\n\n\na \nPostCommandInterface\n instance\n\n\na \nPostForm\n instance\n\n\nWe need to create an \naddAction()\n method in the new \nWriteController\n to\n  handle displaying the form and processing it.\n\n\nWe need to create a new route, \nblog/add\n, that routes to the\n  \nWriteController\n and its \naddAction()\n method.\n\n\nWe need to create a new view script to display the form.\n\n\n\n\nCreating the WriteController\n\n\nWhile we could re-use our existing controller, it has a different\nresponsibility: it will be \nwriting\n new blog posts. As such, it will need to\nemit \ncommands\n, and thus use the \nPostCommandInterface\n that we have defined\npreviously.\n\n\nTo do that, it needs to accept and process user input, which we have modeled\nin our \nPostForm\n in a previous section of this chapter.\n\n\nLet's create this new class now. Open a new file,\n\nmodule/Blog/src/Controller/WriteController.php\n, and add the following\ncontents:\n\n\n<?php\nnamespace Blog\\Controller;\n\nuse Blog\\Form\\PostForm;\nuse Blog\\Model\\Post;\nuse Blog\\Model\\PostCommandInterface;\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass WriteController extends AbstractActionController\n{\n    /**\n     * @var PostCommandInterface\n     */\n    private $command;\n\n    /**\n     * @var PostForm\n     */\n    private $form;\n\n    /**\n     * @param PostCommandInterface $command\n     * @param PostForm $form\n     */\n    public function __construct(PostCommandInterface $command, PostForm $form)\n    {\n        $this->command = $command;\n        $this->form = $form;\n    }\n\n    public function addAction()\n    {\n    }\n}\n\n\n\nWe'll now create a factory for this new controller; create a new file,\n\nmodule/Blog/src/Factory/WriteControllerFactory.php\n, with the following\ncontents:\n\n\n<?php\nnamespace Blog\\Factory;\n\nuse Blog\\Controller\\WriteController;\nuse Blog\\Form\\PostForm;\nuse Blog\\Model\\PostCommandInterface;\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Factory\\FactoryInterface;\n\nclass WriteControllerFactory implements FactoryInterface\n{\n    /**\n     * @param ContainerInterface $container\n     * @param string $requestedName\n     * @param null|array $options\n     * @return WriteController\n     */\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = null)\n    {\n        $formManager = $container->get('FormElementManager');\n        return new WriteController(\n            $container->get(PostCommandInterface::class),\n            $formManager->get(PostForm::class)\n        );\n    }\n}\n\n\n\nThe above factory introduces something new: the \nFormElementManager\n. This is a\nplugin manager implementation that is specifically for forms. We don't\nnecessarily need to register our forms with it, as it will check to see if a\nrequested instance is a form when attempting to pull one from it. However, it\ndoes provide a couple nice features: \n\n\n\n\nIf the form or fieldset or element retrieved implements an \ninit()\n method, it\n  invokes that method after instantiation. This is useful, as that way we're\n  initializing after we have all our dependencies injected, such as input\n  filters. Our form and fieldset define this method!\n\n\nIt ensures that the various plugin managers related to input validation are\n  shared with the instance, a feature we'll be using later.\n\n\n\n\nFinally, we need to configure the new factory; in\n\nmodule/Blog/config/module.config.php\n, add an entry in the \ncontrollers\n\nconfiguration section:\n\n\n'controllers' => [\n    'factories' => [\n        Controller\\ListController::class => Factory\\ListControllerFactory::class,\n        // Add the following line:\n        Controller\\WriteController::class => Factory\\WriteControllerFactory::class,\n    ],\n],\n\n\n\nNow that we have the basics for our controller in place, we can create a route\nto it:\n\n\n<?php\n// In module/Blog/config/module.config.php:\nnamespace Blog;\n\nuse Zend\\Router\\Http\\Literal;\nuse Zend\\Router\\Http\\Segment;\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    'service_manager' => [ /* ... */ ],\n    'controllers'     => [ /* ... */ ],\n    'router'          => [\n        'routes' => [\n            'blog' => [\n                'type' => Literal::class,\n                'options' => [\n                    'route'    => '/blog',\n                    'defaults' => [\n                        'controller' => Controller\\ListController::class,\n                        'action'     => 'index',\n                    ],\n                ],\n                'may_terminate' => true,\n                'child_routes'  => [\n                    'detail' => [\n                        'type' => Segment::class,\n                        'options' => [\n                            'route'    => '/:id',\n                            'defaults' => [\n                                'action' => 'detail',\n                            ],\n                            'constraints' => [\n                                'id' => '\\d+',\n                            ],\n                        ],\n                    ],\n\n                    // Add the following route:\n                    'add' => [\n                        'type' => Literal::class,\n                        'options' => [\n                            'route'    => '/add',\n                            'defaults' => [\n                                'controller' => Controller\\WriteController::class,\n                                'action'     => 'add',\n                            ],\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n    'view_manager'    => [ /* ... */ ],\n];\n\n\n\nFinally, we'll create a dummy template:\n\n\n<!-- Filename: module/Blog/view/blog/write/add.phtml -->\n<h1>WriteController::addAction()</h1>\n\n\n\nCheck-in\n\n\nIf you try to access the new route \nlocalhost:8080/blog/add\n you're supposed to\nsee the following error message:\n\n\nAn error occurred\n\nAn error occurred during execution; please try again later.\n\nAdditional information:\n\nZend\\ServiceManager\\Exception\\ServiceNotFoundException\n\nFile:\n{projectPath}/vendor/zendframework/zend-servicemanager/src/ServiceManager.php:{lineNumber}\n\nMessage:\nUnable to resolve service \"Blog\\Model\\PostCommandInterface\" to a factory; are you certain you provided it during configuration?\n\n\n\nIf this is not the case, be sure to follow the tutorial correctly and carefully\ncheck all your files.\n\n\nThe error is due to the fact that we have not yet defined an \nimplementation\n of\nour \nPostCommandInterface\n, much less wired the implementation into our\napplication!\n\n\nLet's create a dummy implementation, as we did when we first started working\nwith repositories. Create the file \nmodule/Blog/src/Model/PostCommand.php\n with\nthe following contents:\n\n\n<?php\nnamespace Blog\\Model;\n\nclass PostCommand implements PostCommandInterface\n{\n    /**\n     * {@inheritDoc}\n     */\n    public function insertPost(Post $post)\n    {\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function updatePost(Post $post)\n    {\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function deletePost(Post $post)\n    {\n    }\n}\n\n\n\nNow add service configuration in \nmodule/Blog/config/module.config.php\n:\n\n\n'service_manager' => [\n    'aliases' => [\n        /* ... */\n        // Add the following line:\n        Model\\PostCommandInterface::class => Model\\PostCommand::class,\n    ],\n    'factories' => [\n        /* ... */\n        // Add the following line:\n        Model\\PostCommand::class => InvokableFactory::class,\n    ],\n],\n\n\n\nReloading your application now will yield you the desired result.\n\n\nDisplaying the form\n\n\nNow that we have new controller working, it's time to pass this form to the view\nand render it.  Change your controller so that the form is passed to the view:\n\n\n// In /module/Blog/src/Controller/WriteController.php:\npublic function addAction()\n{\n    return new ViewModel([\n        'form' => $this->form,\n    ]);\n}\n\n\n\nAnd then we need to modify our view to render the form:\n\n\n<!-- Filename: module/Blog/view/blog/write/add.phtml -->\n<h1>Add a blog post</h1>\n\n<?php\n$form = $this->form;\n$form->setAttribute('action', $this->url());\n$form->prepare();\n\necho $this->form()->openTag($form);\necho $this->formCollection($form);\necho $this->form()->closeTag();\n\n\n\nThe above does the following:\n\n\n\n\nWe set the \naction\n attribute of the form to the current URL.\n\n\nWe \"prepare\" the form; this ensures any data or error messages bound to the\n  form or its various elements are injected and ready to use for display\n  purposes.\n\n\nWe render an opening tag for the form we are using.\n\n\nWe render the contents of the form, using the \nformCollection()\n view helper;\n  this is a convenience method with some typically sane default markup. We'll be\n  changing it momentarily.\n\n\nWe render a closing tag for the form.\n\n\n\n\n\n\nForm method\n\n\nHTML forms can be sent using \nPOST\n and \nGET\n. zend-form defaults to \nPOST\n.\nIf you want to switch to \nGET\n:\n\n\n$form->setAttribute('method', 'GET');\n\n\n\n\n\nRefreshing the browser you will now see your form properly displayed. It's not\npretty, though, as the default markup does not follow semantics for Bootstrap\n(which is used in the skeleton application by default). Let's update it a bit to\nmake it look better; we'll do that in the view script itself, as markup-related\nconcerns belong in the view layer:\n\n\n<!-- Filename: module/Blog/view/blog/write/add.phtml -->\n<h1>Add a blog post</h1>\n\n<?php\n$form = $this->form;\n$form->setAttribute('action', $this->url());\n\n$fieldset = $form->get('post');\n\n$title = $fieldset->get('title');\n$title->setAttribute('class', 'form-control');\n$title->setAttribute('placeholder', 'Post title');\n\n$text = $fieldset->get('text');\n$text->setAttribute('class', 'form-control');\n$text->setAttribute('placeholder', 'Post content');\n\n$submit = $form->get('submit');\n$submit->setAttribute('class', 'btn btn-primary');\n\n$form->prepare();\n\necho $this->form()->openTag($form);\n?>\n\n<fieldset>\n<div class=\"form-group\">\n    <?= $this->formLabel($title) ?>\n    <?= $this->formElement($title) ?>\n    <?= $this->formElementErrors()->render($title, ['class' => 'help-block']) ?>\n</div>\n\n<div class=\"form-group\">\n    <?= $this->formLabel($text) ?>\n    <?= $this->formElement($text) ?>\n    <?= $this->formElementErrors()->render($text, ['class' => 'help-block']) ?>\n</div>\n</fieldset>\n\n<?php\necho $this->formSubmit($submit);\necho $this->formHidden($fieldset->get('id'));\necho $this->form()->closeTag();\n\n\n\nThe above adds HTML attributes to a number of the elements we've defined, and\nuses more specific view helpers to allow us to render the exact markup we want\nfor our form.\n\n\nHowever, if we're submitting the form all we see is our form being displayed\nagain. And this is due to the simple fact that we didn't add any logic to the\ncontroller yet.\n\n\nGeneral form-handling logic for controllers\n\n\nWriting a controller that handles a form workflow follows the same basic pattern\nregardless of form and entities:\n\n\n\n\nYou need to check if the HTTP request method is via \nPOST\n, meaning if the\n   form has been sent.\n\n\nIf the form has been sent, you need to:\n\n\npass the submitted data to your \nForm\n instance\n\n\nvalidate the \nForm\n instance\n\n\nIf the form passes validation, you will:\n\n\npersist the form data\n\n\nredirect the user to either the detail page of the entered data, or to an\n     overview page\n\n\nIn all other cases, you need to display the form, potentially with error\n   messages.\n\n\n\n\nModify your \nWriteController:addAction()\n to read as follows:\n\n\npublic function addAction()\n{\n    $request   = $this->getRequest();\n    $viewModel = new ViewModel(['form' => $this->form]);\n\n    if (! $request->isPost()) {\n        return $viewModel;\n    }\n\n    $this->form->setData($request->getPost());\n\n    if (! $this->form->isValid()) {\n        return $viewModel;\n    }\n\n    $data = $this->form->getData()['post'];\n    $post = new Post($data['title'], $data['text']);\n\n    try {\n        $post = $this->command->insertPost($post);\n    } catch (\\Exception $ex) {\n        // An exception occurred; we may want to log this later and/or\n        // report it to the user. For now, we'll just re-throw.\n        throw $ex;\n    }\n\n    return $this->redirect()->toRoute(\n        'blog/detail',\n        ['id' => $post->getId()]\n    );\n}\n\n\n\nStepping through the code:\n\n\n\n\nWe retrieve the current request.\n\n\nWe create a default view model containing the form.\n\n\nIf we do not have a \nPOST\n request, we return the default view model.\n\n\nWe populate the form with data from the request.\n\n\nIf the form is not valid, we return the default view model; at this point, the\n  form will also contain error messages.\n\n\nWe create a \nPost\n instance from the validated data.\n\n\nWe attempt to insert the post.\n\n\nOn success, we redirect to the post's detail page.\n\n\n\n\n\n\nChild route names\n\n\nWhen using the various \nurl()\n helpers provided in zend-mvc and zend-view,\nyou need to provide the name of a route. When using child routes, the route\nname is of the form \n<parent>/<child>\n \u2014 i.e., the parent name and child\nname are separated with a slash.\n\n\n\n\nSubmitting the form right now will return into the following error\n\n\nFatal error: Call to a member function getId() on null in\n{projectPath}/module/Blog/src/Controller/WriteController.php\non line {lineNumber}\n\n\n\nThis is because our stub \nPostCommand\n class does not return a new \nPost\n\ninstance, violating the contract!\n\n\nLet's create a new implementation to work against zend-db. Create the file\n\nmodule/Blog/src/Model/ZendDbSqlCommand.php\n with the following contents:\n\n\n<?php\nnamespace Blog\\Model;\n\nuse RuntimeException;\nuse Zend\\Db\\Adapter\\AdapterInterface;\nuse Zend\\Db\\Adapter\\Driver\\ResultInterface;\nuse Zend\\Db\\Sql\\Delete;\nuse Zend\\Db\\Sql\\Insert;\nuse Zend\\Db\\Sql\\Sql;\nuse Zend\\Db\\Sql\\Update;\n\nclass ZendDbSqlCommand implements PostCommandInterface\n{\n    /**\n     * @var AdapterInterface\n     */\n    private $db;\n\n    /**\n     * @param AdapterInterface $db\n     */\n    public function __construct(AdapterInterface $db)\n    {\n        $this->db = $db;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function insertPost(Post $post)\n    {\n        $insert = new Insert('posts');\n        $insert->values([\n            'title' => $post->getTitle(),\n            'text' => $post->getText(),\n        ]);\n\n        $sql = new Sql($this->db);\n        $statement = $sql->prepareStatementForSqlObject($insert);\n        $result = $statement->execute();\n\n        if (! $result instanceof ResultInterface) {\n            throw new RuntimeException(\n                'Database error occurred during blog post insert operation'\n            );\n        }\n\n        $id = $result->getGeneratedValue();\n\n        return new Post(\n            $post->getTitle(),\n            $post->getText(),\n            $result->getGeneratedValue()\n        );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function updatePost(Post $post)\n    {\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function deletePost(Post $post)\n    {\n    }\n}\n\n\n\nIn the \ninsertPost()\n method, we do the following:\n\n\n\n\nWe create a \nZend\\Db\\Sql\\Insert\n instance, providing it the table name.\n\n\nWe add values to the \nInsert\n instance.\n\n\nWe create a \nZend\\Db\\Sql\\Sql\n instance with the database adapter, and prepare\n  a statement from our \nInsert\n instance.\n\n\nWe execute the statement and check for a valid result.\n\n\nWe marshal a return value.\n\n\n\n\nNow that we have this in place, we'll create a factory for it; create the file\n\nmodule/Blog/src/Factory/ZendDbSqlCommandFactory.php\n with the following\ncontents:\n\n\n<?php\nnamespace Blog\\Factory;\n\nuse Interop\\Container\\ContainerInterface;\nuse Blog\\Model\\ZendDbSqlCommand;\nuse Zend\\Db\\Adapter\\AdapterInterface;\nuse Zend\\ServiceManager\\Factory\\FactoryInterface;\n\nclass ZendDbSqlCommandFactory implements FactoryInterface\n{\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = null)\n    {\n        return new ZendDbSqlCommand($container->get(AdapterInterface::class));\n    }\n}\n\n\n\nAnd finally, we'll wire it up in the configuration; update the \nservice_manager\n\nsection of \nmodule/Blog/config/module.config.php\n to read as follows:\n\n\n'service_manager' => [\n    'aliases' => [\n        Model\\PostRepositoryInterface::class => Model\\ZendDbSqlRepository::class,\n        // Update the following alias:\n        Model\\PostCommandInterface::class => Model\\ZendDbSqlCommand::class,\n    ],\n    'factories' => [\n        Model\\PostRepository::class => InvokableFactory::class,\n        Model\\ZendDbSqlRepository::class => Factory\\ZendDbSqlRepositoryFactory::class,\n        Model\\PostCommand::class => InvokableFactory::class,\n        // Add the following line:\n        Model\\ZendDbSqlCommand::class => Factory\\ZendDbSqlCommandFactory::class,\n    ],\n],\n\n\n\nSubmitting your form again, it should process the form and redirect you to the\ndetail page for the new entry!\n\n\nLet's see if we an improve this a bit.\n\n\nUsing zend-hydrator with zend-form\n\n\nIn our controller currently, we have the following:\n\n\n$data = $this->form->getData()['post'];\n$post = new Post($data['title'], $data['text']);\n\n\n\nWhat if we could automate that, so we didn't need to worry about:\n\n\n\n\nWhether or not we're using a fieldset\n\n\nWhat the form fields are named\n\n\n\n\nFortunately, zend-form features integration with zend-hydrator. This will allow\nus to return a \nPost\n instance when we retrieve the validated values!\n\n\nLet's udpate our fieldset to provide a hydrator and a prototype object.\n\n\nFirst, add two import statements to the top of the class file:\n\n\n// In module/Blog/src/Form/PostFieldset.php:\nuse Blog\\Model\\Post;\nuse Zend\\Hydrator\\Reflection as ReflectionHydrator;\n\n\n\nNext, update the \ninit()\n method to add the following two lines:\n\n\n// In /module/Blog/src/Form/PostFieldset.php:\n\npublic function init()\n{\n    $this->setHydrator(new ReflectionHydrator());\n    $this->setObject(new Post('', ''));\n\n    /* ... */\n}\n\n\n\nWhen you grab the data from this fiedlset, it will be returned as a \nPost\n\ninstance.\n\n\nHowever, we grab data \nfrom the form\n; how can we simplify that interaction?\n\n\nSince we only have the one fieldset, we'll set it as the form's \nbase fieldset\n.\nThis hints to the form that when we retrieve data from it, it should return the\nvalues from the specified fieldset instead; since our fieldset returns the\n\nPost\n instance, we'll have exactly what we need.\n\n\nModify your \nPostForm\n class as follows:\n\n\n// In /module/Blog/src/Form/PostForm.php:\n\npublic function init()\n{\n    $this->add([\n        'name' => 'post',\n        'type' => PostFieldset::class,\n        'options' => [\n            'use_as_base_fieldset' => true,\n        ],\n    ]);\n\n    /* ... */\n\n\n\nLet's update our \nWriteController\n; modify the \naddAction()\n method to replace\nthe following two lines:\n\n\n$data = $this->form->getData()['post'];\n$post = new Post($data['title'], $data['text']);\n\n\n\nto:\n\n\n$post = $this->form->getData();\n\n\n\nEverything should continue to work. The changes done serve the purpose of\nde-coupling the details of how the form is structured from the controller,\nallowing us to work directly with our entities at all times!\n\n\nConclusion\n\n\nIn this chapter, we've learned the fundamentals of using zend-form, including\nadding fieldsets and elements, rendering the form, validating input, and wiring\nforms and fieldsets to use entities.\n\n\nIn the next chapter we will finalize the CRUD functionality by creating the\nupdate and delete routines for the blog module.",
            "title": "Usando Forms e Fieldsets"
        },
        {
            "location": "/in-depth-guide/zend-form-zend-form-fieldset/#making-use-of-forms-and-fieldsets",
            "text": "So far all we have done is read data from the database. In a real-life\napplication, this won't get us very far, as we'll often need to support the full\nrange of full  Create ,  Read ,  Update  and  Delete  operations (CRUD).\nTypically, new data will arrive via web form submissions.",
            "title": "Making Use of Forms and Fieldsets"
        },
        {
            "location": "/in-depth-guide/zend-form-zend-form-fieldset/#form-components",
            "text": "The  zend-form  and zend-inputfilter  components\nprovide us with the ability to create fully-featured forms and their validation\nrules. zend-form consumes zend-inputfilter internally, so let's take a look at\nthe elements of zend-form that we will use for our application.",
            "title": "Form components"
        },
        {
            "location": "/in-depth-guide/zend-form-zend-form-fieldset/#fieldsets",
            "text": "Zend\\Form\\Fieldset  models a reusable set of elements. You will use a Fieldset  to create the various HTML inputs needed to map to your server-side\nentities. It is considered good practice to have one  Fieldset  for every entity\nin your application.  The  Fieldset  component, however, is not a form, meaning you will not be able\nto use a  Fieldset  without attaching it to the  Zend\\Form\\Form  instance. The\nadvantage here is that you have one set of elements that you can re-use for as\nmany forms as you like.",
            "title": "Fieldsets"
        },
        {
            "location": "/in-depth-guide/zend-form-zend-form-fieldset/#forms",
            "text": "Zend\\Form\\Form  is a container for all elements of your HTML  <form> . You are\nable to add both single elements or fieldsets (modeled as  Zend\\Form\\Fieldset \ninstances).",
            "title": "Forms"
        },
        {
            "location": "/in-depth-guide/zend-form-zend-form-fieldset/#creating-your-first-fieldset",
            "text": "Explaining how zend-form works is best done by giving you real\ncode to work with. So let's jump right into it and create all the forms we need\nto finish our  Blog  module. We start by creating a  Fieldset  that contains all\nthe input elements that we need to work with our blog data:   You will need one hidden input for the  id  property, which is only needed for\n  editting and deleting data.  You will need one text input for the  title  property.  You will need one textarea for the  text  property.   Create the file  module/Blog/src/Form/PostFieldset.php  with the following\ncontents:  <?php\nnamespace Blog\\Form;\n\nuse Zend\\Form\\Fieldset;\n\nclass PostFieldset extends Fieldset\n{\n    public function init()\n    {\n        $this->add([\n            'type' => 'hidden',\n            'name' => 'id',\n        ]);\n\n        $this->add([\n            'type' => 'text',\n            'name' => 'title',\n            'options' => [\n                'label' => 'Post Title',\n            ],\n        ]);\n\n        $this->add([\n            'type' => 'textarea',\n            'name' => 'text',\n            'options' => [\n                'label' => 'Post Text',\n            ],\n        ]);\n    }\n}  This new class creates an extension of  Zend\\Form\\Fieldset  that, in an  init() \nmethod (more on this later),  adds elements for each aspect of our blog post. We\ncan now re-use this fieldset in as many forms as we want. Let's create our first\nform.",
            "title": "Creating your first Fieldset"
        },
        {
            "location": "/in-depth-guide/zend-form-zend-form-fieldset/#creating-the-postform",
            "text": "Now that we have our  PostFieldset  in place, we can use it inside a  Form .\nThe form will use the  PostFieldset , and also include a submit button so that\nthe user can submit the data.  Create the file  module/Blog/src/Form/PostForm.php  with the following contents:  <?php\nnamespace Blog\\Form;\n\nuse Zend\\Form\\Form;\n\nclass PostForm extends Form\n{\n    public function init()\n    {\n        $this->add([\n            'name' => 'post',\n            'type' => PostFieldset::class,\n        ]);\n\n        $this->add([\n            'type' => 'submit',\n            'name' => 'submit',\n            'attributes' => [\n                'value' => 'Insert new Post',\n            ],\n        ]);\n    }\n}  And that's our form. Nothing special here, we add our  PostFieldset  to the\nform, we add a submit button to the form, and nothing more.",
            "title": "Creating the PostForm"
        },
        {
            "location": "/in-depth-guide/zend-form-zend-form-fieldset/#adding-a-new-post",
            "text": "Now that we have the  PostForm  written, it's time to use it. But there are a\nfew more tasks left:   We need to create a new controller  WriteController  which accepts the\n  following instances via its constructor:  a  PostCommandInterface  instance  a  PostForm  instance  We need to create an  addAction()  method in the new  WriteController  to\n  handle displaying the form and processing it.  We need to create a new route,  blog/add , that routes to the\n   WriteController  and its  addAction()  method.  We need to create a new view script to display the form.",
            "title": "Adding a new Post"
        },
        {
            "location": "/in-depth-guide/zend-form-zend-form-fieldset/#creating-the-writecontroller",
            "text": "While we could re-use our existing controller, it has a different\nresponsibility: it will be  writing  new blog posts. As such, it will need to\nemit  commands , and thus use the  PostCommandInterface  that we have defined\npreviously.  To do that, it needs to accept and process user input, which we have modeled\nin our  PostForm  in a previous section of this chapter.  Let's create this new class now. Open a new file, module/Blog/src/Controller/WriteController.php , and add the following\ncontents:  <?php\nnamespace Blog\\Controller;\n\nuse Blog\\Form\\PostForm;\nuse Blog\\Model\\Post;\nuse Blog\\Model\\PostCommandInterface;\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass WriteController extends AbstractActionController\n{\n    /**\n     * @var PostCommandInterface\n     */\n    private $command;\n\n    /**\n     * @var PostForm\n     */\n    private $form;\n\n    /**\n     * @param PostCommandInterface $command\n     * @param PostForm $form\n     */\n    public function __construct(PostCommandInterface $command, PostForm $form)\n    {\n        $this->command = $command;\n        $this->form = $form;\n    }\n\n    public function addAction()\n    {\n    }\n}  We'll now create a factory for this new controller; create a new file, module/Blog/src/Factory/WriteControllerFactory.php , with the following\ncontents:  <?php\nnamespace Blog\\Factory;\n\nuse Blog\\Controller\\WriteController;\nuse Blog\\Form\\PostForm;\nuse Blog\\Model\\PostCommandInterface;\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Factory\\FactoryInterface;\n\nclass WriteControllerFactory implements FactoryInterface\n{\n    /**\n     * @param ContainerInterface $container\n     * @param string $requestedName\n     * @param null|array $options\n     * @return WriteController\n     */\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = null)\n    {\n        $formManager = $container->get('FormElementManager');\n        return new WriteController(\n            $container->get(PostCommandInterface::class),\n            $formManager->get(PostForm::class)\n        );\n    }\n}  The above factory introduces something new: the  FormElementManager . This is a\nplugin manager implementation that is specifically for forms. We don't\nnecessarily need to register our forms with it, as it will check to see if a\nrequested instance is a form when attempting to pull one from it. However, it\ndoes provide a couple nice features:    If the form or fieldset or element retrieved implements an  init()  method, it\n  invokes that method after instantiation. This is useful, as that way we're\n  initializing after we have all our dependencies injected, such as input\n  filters. Our form and fieldset define this method!  It ensures that the various plugin managers related to input validation are\n  shared with the instance, a feature we'll be using later.   Finally, we need to configure the new factory; in module/Blog/config/module.config.php , add an entry in the  controllers \nconfiguration section:  'controllers' => [\n    'factories' => [\n        Controller\\ListController::class => Factory\\ListControllerFactory::class,\n        // Add the following line:\n        Controller\\WriteController::class => Factory\\WriteControllerFactory::class,\n    ],\n],  Now that we have the basics for our controller in place, we can create a route\nto it:  <?php\n// In module/Blog/config/module.config.php:\nnamespace Blog;\n\nuse Zend\\Router\\Http\\Literal;\nuse Zend\\Router\\Http\\Segment;\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    'service_manager' => [ /* ... */ ],\n    'controllers'     => [ /* ... */ ],\n    'router'          => [\n        'routes' => [\n            'blog' => [\n                'type' => Literal::class,\n                'options' => [\n                    'route'    => '/blog',\n                    'defaults' => [\n                        'controller' => Controller\\ListController::class,\n                        'action'     => 'index',\n                    ],\n                ],\n                'may_terminate' => true,\n                'child_routes'  => [\n                    'detail' => [\n                        'type' => Segment::class,\n                        'options' => [\n                            'route'    => '/:id',\n                            'defaults' => [\n                                'action' => 'detail',\n                            ],\n                            'constraints' => [\n                                'id' => '\\d+',\n                            ],\n                        ],\n                    ],\n\n                    // Add the following route:\n                    'add' => [\n                        'type' => Literal::class,\n                        'options' => [\n                            'route'    => '/add',\n                            'defaults' => [\n                                'controller' => Controller\\WriteController::class,\n                                'action'     => 'add',\n                            ],\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n    'view_manager'    => [ /* ... */ ],\n];  Finally, we'll create a dummy template:  <!-- Filename: module/Blog/view/blog/write/add.phtml -->\n<h1>WriteController::addAction()</h1>",
            "title": "Creating the WriteController"
        },
        {
            "location": "/in-depth-guide/zend-form-zend-form-fieldset/#check-in",
            "text": "If you try to access the new route  localhost:8080/blog/add  you're supposed to\nsee the following error message:  An error occurred\n\nAn error occurred during execution; please try again later.\n\nAdditional information:\n\nZend\\ServiceManager\\Exception\\ServiceNotFoundException\n\nFile:\n{projectPath}/vendor/zendframework/zend-servicemanager/src/ServiceManager.php:{lineNumber}\n\nMessage:\nUnable to resolve service \"Blog\\Model\\PostCommandInterface\" to a factory; are you certain you provided it during configuration?  If this is not the case, be sure to follow the tutorial correctly and carefully\ncheck all your files.  The error is due to the fact that we have not yet defined an  implementation  of\nour  PostCommandInterface , much less wired the implementation into our\napplication!  Let's create a dummy implementation, as we did when we first started working\nwith repositories. Create the file  module/Blog/src/Model/PostCommand.php  with\nthe following contents:  <?php\nnamespace Blog\\Model;\n\nclass PostCommand implements PostCommandInterface\n{\n    /**\n     * {@inheritDoc}\n     */\n    public function insertPost(Post $post)\n    {\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function updatePost(Post $post)\n    {\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function deletePost(Post $post)\n    {\n    }\n}  Now add service configuration in  module/Blog/config/module.config.php :  'service_manager' => [\n    'aliases' => [\n        /* ... */\n        // Add the following line:\n        Model\\PostCommandInterface::class => Model\\PostCommand::class,\n    ],\n    'factories' => [\n        /* ... */\n        // Add the following line:\n        Model\\PostCommand::class => InvokableFactory::class,\n    ],\n],  Reloading your application now will yield you the desired result.",
            "title": "Check-in"
        },
        {
            "location": "/in-depth-guide/zend-form-zend-form-fieldset/#displaying-the-form",
            "text": "Now that we have new controller working, it's time to pass this form to the view\nand render it.  Change your controller so that the form is passed to the view:  // In /module/Blog/src/Controller/WriteController.php:\npublic function addAction()\n{\n    return new ViewModel([\n        'form' => $this->form,\n    ]);\n}  And then we need to modify our view to render the form:  <!-- Filename: module/Blog/view/blog/write/add.phtml -->\n<h1>Add a blog post</h1>\n\n<?php\n$form = $this->form;\n$form->setAttribute('action', $this->url());\n$form->prepare();\n\necho $this->form()->openTag($form);\necho $this->formCollection($form);\necho $this->form()->closeTag();  The above does the following:   We set the  action  attribute of the form to the current URL.  We \"prepare\" the form; this ensures any data or error messages bound to the\n  form or its various elements are injected and ready to use for display\n  purposes.  We render an opening tag for the form we are using.  We render the contents of the form, using the  formCollection()  view helper;\n  this is a convenience method with some typically sane default markup. We'll be\n  changing it momentarily.  We render a closing tag for the form.",
            "title": "Displaying the form"
        },
        {
            "location": "/in-depth-guide/zend-form-zend-form-fieldset/#form-method",
            "text": "HTML forms can be sent using  POST  and  GET . zend-form defaults to  POST .\nIf you want to switch to  GET :  $form->setAttribute('method', 'GET');   Refreshing the browser you will now see your form properly displayed. It's not\npretty, though, as the default markup does not follow semantics for Bootstrap\n(which is used in the skeleton application by default). Let's update it a bit to\nmake it look better; we'll do that in the view script itself, as markup-related\nconcerns belong in the view layer:  <!-- Filename: module/Blog/view/blog/write/add.phtml -->\n<h1>Add a blog post</h1>\n\n<?php\n$form = $this->form;\n$form->setAttribute('action', $this->url());\n\n$fieldset = $form->get('post');\n\n$title = $fieldset->get('title');\n$title->setAttribute('class', 'form-control');\n$title->setAttribute('placeholder', 'Post title');\n\n$text = $fieldset->get('text');\n$text->setAttribute('class', 'form-control');\n$text->setAttribute('placeholder', 'Post content');\n\n$submit = $form->get('submit');\n$submit->setAttribute('class', 'btn btn-primary');\n\n$form->prepare();\n\necho $this->form()->openTag($form);\n?>\n\n<fieldset>\n<div class=\"form-group\">\n    <?= $this->formLabel($title) ?>\n    <?= $this->formElement($title) ?>\n    <?= $this->formElementErrors()->render($title, ['class' => 'help-block']) ?>\n</div>\n\n<div class=\"form-group\">\n    <?= $this->formLabel($text) ?>\n    <?= $this->formElement($text) ?>\n    <?= $this->formElementErrors()->render($text, ['class' => 'help-block']) ?>\n</div>\n</fieldset>\n\n<?php\necho $this->formSubmit($submit);\necho $this->formHidden($fieldset->get('id'));\necho $this->form()->closeTag();  The above adds HTML attributes to a number of the elements we've defined, and\nuses more specific view helpers to allow us to render the exact markup we want\nfor our form.  However, if we're submitting the form all we see is our form being displayed\nagain. And this is due to the simple fact that we didn't add any logic to the\ncontroller yet.",
            "title": "Form method"
        },
        {
            "location": "/in-depth-guide/zend-form-zend-form-fieldset/#general-form-handling-logic-for-controllers",
            "text": "Writing a controller that handles a form workflow follows the same basic pattern\nregardless of form and entities:   You need to check if the HTTP request method is via  POST , meaning if the\n   form has been sent.  If the form has been sent, you need to:  pass the submitted data to your  Form  instance  validate the  Form  instance  If the form passes validation, you will:  persist the form data  redirect the user to either the detail page of the entered data, or to an\n     overview page  In all other cases, you need to display the form, potentially with error\n   messages.   Modify your  WriteController:addAction()  to read as follows:  public function addAction()\n{\n    $request   = $this->getRequest();\n    $viewModel = new ViewModel(['form' => $this->form]);\n\n    if (! $request->isPost()) {\n        return $viewModel;\n    }\n\n    $this->form->setData($request->getPost());\n\n    if (! $this->form->isValid()) {\n        return $viewModel;\n    }\n\n    $data = $this->form->getData()['post'];\n    $post = new Post($data['title'], $data['text']);\n\n    try {\n        $post = $this->command->insertPost($post);\n    } catch (\\Exception $ex) {\n        // An exception occurred; we may want to log this later and/or\n        // report it to the user. For now, we'll just re-throw.\n        throw $ex;\n    }\n\n    return $this->redirect()->toRoute(\n        'blog/detail',\n        ['id' => $post->getId()]\n    );\n}  Stepping through the code:   We retrieve the current request.  We create a default view model containing the form.  If we do not have a  POST  request, we return the default view model.  We populate the form with data from the request.  If the form is not valid, we return the default view model; at this point, the\n  form will also contain error messages.  We create a  Post  instance from the validated data.  We attempt to insert the post.  On success, we redirect to the post's detail page.",
            "title": "General form-handling logic for controllers"
        },
        {
            "location": "/in-depth-guide/zend-form-zend-form-fieldset/#child-route-names",
            "text": "When using the various  url()  helpers provided in zend-mvc and zend-view,\nyou need to provide the name of a route. When using child routes, the route\nname is of the form  <parent>/<child>  \u2014 i.e., the parent name and child\nname are separated with a slash.   Submitting the form right now will return into the following error  Fatal error: Call to a member function getId() on null in\n{projectPath}/module/Blog/src/Controller/WriteController.php\non line {lineNumber}  This is because our stub  PostCommand  class does not return a new  Post \ninstance, violating the contract!  Let's create a new implementation to work against zend-db. Create the file module/Blog/src/Model/ZendDbSqlCommand.php  with the following contents:  <?php\nnamespace Blog\\Model;\n\nuse RuntimeException;\nuse Zend\\Db\\Adapter\\AdapterInterface;\nuse Zend\\Db\\Adapter\\Driver\\ResultInterface;\nuse Zend\\Db\\Sql\\Delete;\nuse Zend\\Db\\Sql\\Insert;\nuse Zend\\Db\\Sql\\Sql;\nuse Zend\\Db\\Sql\\Update;\n\nclass ZendDbSqlCommand implements PostCommandInterface\n{\n    /**\n     * @var AdapterInterface\n     */\n    private $db;\n\n    /**\n     * @param AdapterInterface $db\n     */\n    public function __construct(AdapterInterface $db)\n    {\n        $this->db = $db;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function insertPost(Post $post)\n    {\n        $insert = new Insert('posts');\n        $insert->values([\n            'title' => $post->getTitle(),\n            'text' => $post->getText(),\n        ]);\n\n        $sql = new Sql($this->db);\n        $statement = $sql->prepareStatementForSqlObject($insert);\n        $result = $statement->execute();\n\n        if (! $result instanceof ResultInterface) {\n            throw new RuntimeException(\n                'Database error occurred during blog post insert operation'\n            );\n        }\n\n        $id = $result->getGeneratedValue();\n\n        return new Post(\n            $post->getTitle(),\n            $post->getText(),\n            $result->getGeneratedValue()\n        );\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function updatePost(Post $post)\n    {\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function deletePost(Post $post)\n    {\n    }\n}  In the  insertPost()  method, we do the following:   We create a  Zend\\Db\\Sql\\Insert  instance, providing it the table name.  We add values to the  Insert  instance.  We create a  Zend\\Db\\Sql\\Sql  instance with the database adapter, and prepare\n  a statement from our  Insert  instance.  We execute the statement and check for a valid result.  We marshal a return value.   Now that we have this in place, we'll create a factory for it; create the file module/Blog/src/Factory/ZendDbSqlCommandFactory.php  with the following\ncontents:  <?php\nnamespace Blog\\Factory;\n\nuse Interop\\Container\\ContainerInterface;\nuse Blog\\Model\\ZendDbSqlCommand;\nuse Zend\\Db\\Adapter\\AdapterInterface;\nuse Zend\\ServiceManager\\Factory\\FactoryInterface;\n\nclass ZendDbSqlCommandFactory implements FactoryInterface\n{\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = null)\n    {\n        return new ZendDbSqlCommand($container->get(AdapterInterface::class));\n    }\n}  And finally, we'll wire it up in the configuration; update the  service_manager \nsection of  module/Blog/config/module.config.php  to read as follows:  'service_manager' => [\n    'aliases' => [\n        Model\\PostRepositoryInterface::class => Model\\ZendDbSqlRepository::class,\n        // Update the following alias:\n        Model\\PostCommandInterface::class => Model\\ZendDbSqlCommand::class,\n    ],\n    'factories' => [\n        Model\\PostRepository::class => InvokableFactory::class,\n        Model\\ZendDbSqlRepository::class => Factory\\ZendDbSqlRepositoryFactory::class,\n        Model\\PostCommand::class => InvokableFactory::class,\n        // Add the following line:\n        Model\\ZendDbSqlCommand::class => Factory\\ZendDbSqlCommandFactory::class,\n    ],\n],  Submitting your form again, it should process the form and redirect you to the\ndetail page for the new entry!  Let's see if we an improve this a bit.",
            "title": "Child route names"
        },
        {
            "location": "/in-depth-guide/zend-form-zend-form-fieldset/#using-zend-hydrator-with-zend-form",
            "text": "In our controller currently, we have the following:  $data = $this->form->getData()['post'];\n$post = new Post($data['title'], $data['text']);  What if we could automate that, so we didn't need to worry about:   Whether or not we're using a fieldset  What the form fields are named   Fortunately, zend-form features integration with zend-hydrator. This will allow\nus to return a  Post  instance when we retrieve the validated values!  Let's udpate our fieldset to provide a hydrator and a prototype object.  First, add two import statements to the top of the class file:  // In module/Blog/src/Form/PostFieldset.php:\nuse Blog\\Model\\Post;\nuse Zend\\Hydrator\\Reflection as ReflectionHydrator;  Next, update the  init()  method to add the following two lines:  // In /module/Blog/src/Form/PostFieldset.php:\n\npublic function init()\n{\n    $this->setHydrator(new ReflectionHydrator());\n    $this->setObject(new Post('', ''));\n\n    /* ... */\n}  When you grab the data from this fiedlset, it will be returned as a  Post \ninstance.  However, we grab data  from the form ; how can we simplify that interaction?  Since we only have the one fieldset, we'll set it as the form's  base fieldset .\nThis hints to the form that when we retrieve data from it, it should return the\nvalues from the specified fieldset instead; since our fieldset returns the Post  instance, we'll have exactly what we need.  Modify your  PostForm  class as follows:  // In /module/Blog/src/Form/PostForm.php:\n\npublic function init()\n{\n    $this->add([\n        'name' => 'post',\n        'type' => PostFieldset::class,\n        'options' => [\n            'use_as_base_fieldset' => true,\n        ],\n    ]);\n\n    /* ... */  Let's update our  WriteController ; modify the  addAction()  method to replace\nthe following two lines:  $data = $this->form->getData()['post'];\n$post = new Post($data['title'], $data['text']);  to:  $post = $this->form->getData();  Everything should continue to work. The changes done serve the purpose of\nde-coupling the details of how the form is structured from the controller,\nallowing us to work directly with our entities at all times!",
            "title": "Using zend-hydrator with zend-form"
        },
        {
            "location": "/in-depth-guide/zend-form-zend-form-fieldset/#conclusion",
            "text": "In this chapter, we've learned the fundamentals of using zend-form, including\nadding fieldsets and elements, rendering the form, validating input, and wiring\nforms and fieldsets to use entities.  In the next chapter we will finalize the CRUD functionality by creating the\nupdate and delete routines for the blog module.",
            "title": "Conclusion"
        },
        {
            "location": "/in-depth-guide/data-binding/",
            "text": "Editing and Deleting Data\n\n\nIn the previous chapter we've come to learn how we can use the zend-form and\nzend-db components for \ncreating\n new data-sets. This chapter will focus on\nfinalizing the CRUD functionality by introducing the concepts for \nediting\n and\n\ndeleting\n data.\n\n\nBinding Objects to Forms\n\n\nThe one fundamental difference between our \"add post\" and \"edit post\" forms is\nthe existence of data.  This means we need to find a way to get data from our\nrepository into the form. Luckily, zend-form provides this via a\n\ndata-binding\n feature.\n\n\nIn order to use this feature, you will need to retrieve a \nPost\n instance, and\nbind it to the form. To do this, we will need to:\n\n\n\n\nAdd a dependency in our \nWriteController\n on our \nPostRepositoryInterface\n,\n  from which we will retrieve our \nPost\n.\n\n\nAdd a new method to our \nWriteController\n, \neditAction()\n, that will retrieve\n  a \nPost\n, bind it to the form, and either display the form or process it.\n\n\nUpdate our \nWriteControllerFactory\n to inject the \nPostRepositoryInterface\n.\n\n\n\n\nWe'll begin by updating the \nWriteController\n:\n\n\n\n\nWe will import the \nPostRepositoryInterface\n.\n\n\nWe will add a property for storing the \nPostRepositoryInterface\n.\n\n\nWe will update the constructor to accept the \nPostRepositoryInterface\n.\n\n\nWe will add the \neditAction()\n implementation.\n\n\n\n\nThe final result will look like the following:\n\n\n<?php\n// In module/Blog/src/Controller/WriteController.php:\n\nnamespace Blog\\Controller;\n\nuse Blog\\Form\\PostForm;\nuse Blog\\Model\\Post;\nuse Blog\\Model\\PostCommandInterface;\nuse Blog\\Model\\PostRepositoryInterface;\nuse InvalidArgumentException;\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass WriteController extends AbstractActionController\n{\n    /**\n     * @var PostCommandInterface\n     */\n    private $command;\n\n    /**\n     * @var PostForm\n     */\n    private $form;\n\n    /**\n     * @var PostRepositoryInterface\n     */\n    private $repository;\n\n    /**\n     * @param PostCommandInterface $command\n     * @param PostForm $form\n     * @param PostRepositoryInterface $repository\n     */\n    public function __construct(\n        PostCommandInterface $command,\n        PostForm $form,\n        PostRepositoryInterface $repository\n    ) {\n        $this->command = $command;\n        $this->form = $form;\n        $this->repository = $repository;\n    }\n\n    public function addAction()\n    {\n        $request   = $this->getRequest();\n        $viewModel = new ViewModel(['form' => $this->form]);\n\n        if (! $request->isPost()) {\n            return $viewModel;\n        }\n\n        $this->form->setData($request->getPost());\n\n        if (! $this->form->isValid()) {\n            return $viewModel;\n        }\n\n        $post = $this->form->getData();\n\n        try {\n            $post = $this->command->insertPost($post);\n        } catch (\\Exception $ex) {\n            // An exception occurred; we may want to log this later and/or\n            // report it to the user. For now, we'll just re-throw.\n            throw $ex;\n        }\n\n        return $this->redirect()->toRoute(\n            'blog/detail',\n            ['id' => $post->getId()]\n        );\n    }\n\n    public function editAction()\n    {\n        $id = $this->params()->fromRoute('id');\n        if (! $id) {\n            return $this->redirect()->toRoute('blog');\n        }\n\n        try {\n            $post = $this->repository->findPost($id);\n        } catch (InvalidArgumentException $ex) {\n            return $this->redirect()->toRoute('blog');\n        }\n\n        $this->form->bind($post);\n        $viewModel = new ViewModel(['form' => $this->form]);\n\n        $request = $this->getRequest();\n        if (! $request->isPost()) {\n            return $viewModel;\n        }\n\n        $this->form->setData($request->getPost());\n\n        if (! $this->form->isValid()) {\n            return $viewModel;\n        }\n\n        $post = $this->command->updatePost($post);\n        return $this->redirect()->toRoute(\n            'blog/detail',\n            ['id' => $post->getId()]\n        );\n    }\n}\n\n\n\nThe primary differences between \naddAction()\n and \neditAction()\n are that the\nlatter needs to first fetch a \nPost\n, and this post is \nbound\n to the form. By\nbinding it, we ensure that the data is populated in the form for the initial\ndisplay, and, once validated, the same instance is updated. This means that we\ncan omit the call to \ngetData()\n after validating the form.\n\n\nNow we need to update our \nWriteControllerFactory\n. First, add a new import\nstatement to it:\n\n\n// In module/Blog/src/Factory/WriteControllerFactory.php:\nuse Blog\\Model\\PostRepositoryInterface;\n\n\n\nNext, update the body of the factory to read as follows:\n\n\n// In module/Blog/src/Factory/WriteControllerFactory.php:\npublic function __invoke(ContainerInterface $container, $requestedName, array $options = null)\n{\n    $formManager = $container->get('FormElementManager');\n\n    return new WriteController(\n        $container->get(PostCommandInterface::class),\n        $formManager->get(PostForm::class),\n        $container->get(PostRepositoryInterface::class)\n    );\n}\n\n\n\nThe controller and model are now wired together, so it's time to turn to\nrouting.\n\n\nAdding the edit route\n\n\nThe edit route is identical to the \nblog/detail\n route we previously defined,\nwith two exceptions:\n\n\n\n\nit will have a path prefix, \n/edit\n\n\nit will route to our \nWriteController\n\n\n\n\nUpdate the 'blog' \nchild_routes\n to add the new route:\n\n\n// In module/Blog/config/module.config.php:\n\nuse Zend\\Router\\Http\\Segment;\n\nreturn [\n    'service_manager' => [ /* ... */ ],\n    'controllers'     => [ /* ... */ ],\n    'router'          => [\n        'routes' => [\n            'blog' => [\n                /* ... */\n\n                'child_routes' => [\n                    /* ... */\n\n                    'edit' => [\n                        'type' => Segment::class,\n                        'options' => [\n                            'route'    => '/edit/:id',\n                            'defaults' => [\n                                'controller' => Controller\\WriteController::class,\n                                'action'     => 'edit',\n                            ],\n                            'constraints' => [\n                                'id' => '[1-9]\\d*',\n                            ],\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n    'view_manager'    => [ /* ... */ ],\n];\n\n\n\nCreating the edit template\n\n\nRendering the form remains essentially the same between the \nadd\n and \nedit\n\ntemplates; the only difference between them is the form action. As such, we will\ncreate a new \npartial\n script for the form, update the \nadd\n template to use it,\nand create a new \nedit\n template.\n\n\nCreate a new file, \nmodule/Blog/view/blog/write/form.phtml\n, with the following\ncontents:\n\n\n<?php\n$form = $this->form;\n$fieldset = $form->get('post');\n\n$title = $fieldset->get('title');\n$title->setAttribute('class', 'form-control');\n$title->setAttribute('placeholder', 'Post title');\n\n$text = $fieldset->get('text');\n$text->setAttribute('class', 'form-control');\n$text->setAttribute('placeholder', 'Post content');\n\n$submit = $form->get('submit');\n$submit->setValue($this->submitLabel);\n$submit->setAttribute('class', 'btn btn-primary');\n\n$form->prepare();\n\necho $this->form()->openTag($form);\n?>\n\n<fieldset>\n<div class=\"form-group\">\n    <?= $this->formLabel($title) ?>\n    <?= $this->formElement($title) ?>\n    <?= $this->formElementErrors()->render($title, ['class' => 'help-block']) ?>\n</div>\n\n<div class=\"form-group\">\n    <?= $this->formLabel($text) ?>\n    <?= $this->formElement($text) ?>\n    <?= $this->formElementErrors()->render($text, ['class' => 'help-block']) ?>\n</div>\n</fieldset>\n\n<?php\necho $this->formSubmit($submit);\necho $this->formHidden($fieldset->get('id'));\necho $this->form()->closeTag();\n\n\n\nNow, update the \nadd\n template, \nmodule/Blog/view/write/add.phtml\n to read as\nfollows:\n\n\n<h1>Add a blog post</h1>\n\n<?php\n$form = $this->form;\n$form->setAttribute('action', $this->url());\necho $this->partial('blog/write/form', [\n    'form' => $form,\n    'submitLabel' => 'Insert new post',\n]);\n\n\n\nThe above retrieves the form, sets the form action, provides a\ncontext-appropriate label for the submit button, and renders it with our new\npartial view script.\n\n\nNext in line is the creation of the new template, \nblog/write/edit\n:\n\n\n<h1>Edit blog post</h1>\n\n<?php\n$form = $this->form;\n$form->setAttribute('action', $this->url('blog/edit', [], true));\necho $this->partial('blog/write/form', [\n    'form' => $form,\n    'submitLabel' => 'Update post',\n]);\n\n\n\nThe three differences between the \nadd\n and \nedit\n templates are:\n\n\n\n\nThe heading at the top of the page.\n\n\nThe URI used for the form action.\n\n\nThe label used for the submit button.\n\n\n\n\nBecause the URI requires the identifier, we need to ensure the identifier is\npassed. The way we've done this in the controllers is to pass the identifier as\na parameter: \n$this->url('blog/edit/', ['id' => $id])\n. This would require that\nwe pass the original \nPost\n instance or the identifier we pull from it to the\nview, however. zend-router allows another option, however: you can tell it to\nre-use currently matched parameters.  This is done by setting the last parameter\nof the view-helper to \ntrue\n: \n$this->url('blog/edit', [], true)\n.\n\n\nIf you try and update the post, it'll be successful, but you'll notice that no\nedits were saved! Why? Because we have not yet implemented the functionality in\nour command class. Let's do that now.\n\n\nEdit the file \nmodule/Blog/src/Model/ZendDbSqlCommand.php\n, and update the\n\nupdatePost()\n method to read as follows:\n\n\npublic function updatePost(Post $post)\n{\n    if (! $post->getId()) {\n        throw new RuntimeException('Cannot update post; missing identifier');\n    }\n\n    $update = new Update('posts');\n    $update->set([\n            'title' => $post->getTitle(),\n            'text' => $post->getText(),\n    ]);\n    $update->where(['id = ?' => $post->getId()]);\n\n    $sql = new Sql($this->db);\n    $statement = $sql->prepareStatementForSqlObject($update);\n    $result = $statement->execute();\n\n    if (! $result instanceof ResultInterface) {\n        throw new RuntimeException(\n            'Database error occurred during blog post update operation'\n        );\n    }\n\n    return $post;\n}\n\n\n\nThis looks very similar to the \ninsertPost()\n implementation we did earlier. The\nprimary difference is the usage of the \nUpdate\n class; instead of calling a\n\nvalues()\n method on it, we call:\n\n\n\n\nset()\n, to provide the values we are updating.\n\n\nwhere()\n, to provide criteria to determine which records (record singular, in\n  our case) are updated.\n\n\n\n\nAdditionally, we test for the presence of an identifier before performing the\noperation, and, because we already have one, and the \nPost\n submitted to us\ncontains all the edits we submitted to the database, we return it verbatim on\nsuccess.\n\n\nImplementing the delete functionality\n\n\nLast but not least, it's time to delete some data. We start this process by\nimplementing the \ndeletePost()\n method in our \nZendDbSqlCommand\n class:\n\n\n// In module/Blog/src/Model/ZendDbSqlCommand.php:\n\npublic function deletePost(Post $post)\n{\n    if (! $post->getId()) {\n        throw new RuntimeException('Cannot update post; missing identifier');\n    }\n\n    $delete = new Delete('posts');\n    $delete->where(['id = ?' => $post->getId()]);\n\n    $sql = new Sql($this->db);\n    $statement = $sql->prepareStatementForSqlObject($delete);\n    $result = $statement->execute();\n\n    if (! $result instanceof ResultInterface) {\n        return false;\n    }\n\n    return true;\n}\n\n\n\nThe above uses \nZend\\Db\\Sql\\Delete\n to create the SQL necessary to delete the\npost with the given identifier, which we then execute.\n\n\nNext, let's create a new controller, \nBlog\\Controller\\DeleteController\n, in a\nnew file \nmodule/Blog/src/Controller/DeleteController.php\n, with the following\ncontents:\n\n\n<?php\nnamespace Blog\\Controller;\n\nuse Blog\\Model\\Post;\nuse Blog\\Model\\PostCommandInterface;\nuse Blog\\Model\\PostRepositoryInterface;\nuse InvalidArgumentException;\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass DeleteController extends AbstractActionController\n{\n    /**\n     * @var PostCommandInterface\n     */\n    private $command;\n\n    /**\n     * @var PostRepositoryInterface\n     */\n    private $repository;\n\n    /**\n     * @param PostCommandInterface $command\n     * @param PostRepositoryInterface $repository\n     */\n    public function __construct(\n        PostCommandInterface $command,\n        PostRepositoryInterface $repository\n    ) {\n        $this->command = $command;\n        $this->repository = $repository;\n    }\n\n    public function deleteAction()\n    {\n        $id = $this->params()->fromRoute('id');\n        if (! $id) {\n            return $this->redirect()->toRoute('blog');\n        }\n\n        try {\n            $post = $this->repository->findPost($id);\n        } catch (InvalidArgumentException $ex) {\n            return $this->redirect()->toRoute('blog');\n        }\n\n        $request = $this->getRequest();\n        if (! $request->isPost()) {\n            return new ViewModel(['post' => $post]);\n        }\n\n        if ($id != $request->getPost('id')\n            || 'Delete' !== $request->getPost('confirm', 'no')\n        ) {\n            return $this->redirect()->toRoute('blog');\n        }\n\n        $post = $this->command->deletePost($post);\n        return $this->redirect()->toRoute('blog');\n    }\n}\n\n\n\nLike the \nWriteController\n, it composes both our \nPostRepositoryInterface\n and\n\nPostCommandInterface\n. The former is used to ensure we are referencing a valid\npost instance, and the latter to perform the actual deletion.\n\n\nWhen a user requests the page via the \nGET\n method, we will display a page\ncontaining details of the post, and a confirmation form. When submitted, we'll\ncheck to make sure they confirmed the deletion before issuing our delete\ncommand. If any conditions fail, or on a successful deletion, we redirect to our\nblog listing page.\n\n\nLike the other controllers, we now need a factory. Create the file\n\nmodule/Blog/src/Factory/DeleteControllerFactory.php\n with the following\ncontents:\n\n\n<?php\nnamespace Blog\\Factory;\n\nuse Blog\\Controller\\DeleteController;\nuse Blog\\Model\\PostCommandInterface;\nuse Blog\\Model\\PostRepositoryInterface;\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Factory\\FactoryInterface;\n\nclass DeleteControllerFactory implements FactoryInterface\n{\n    /**\n     * @param ContainerInterface $container\n     * @param string $requestedName\n     * @param null|array $options\n     * @return DeleteController\n     */\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = null)\n    {\n        return new DeleteController(\n            $container->get(PostCommandInterface::class),\n            $container->get(PostRepositoryInterface::class)\n        );\n    }\n}\n\n\n\nWe'll now wire this into the application, mapping the controller to its factory,\nand providing a new route. Open the file \nmodule/Blog/config/module.config.php\n\nand make the following edits.\n\n\nFirst, map the controller to its factory:\n\n\n'controllers' => [\n    'factories' => [\n        Controller\\ListController::class => Factory\\ListControllerFactory::class,\n        Controller\\WriteController::class => Factory\\WriteControllerFactory::class,\n        // Add the following line:\n        Controller\\DeleteController::class => Factory\\DeleteControllerFactory::class,\n    ],\n],\n\n\n\nNow add another child route to our \"blog\" route:\n\n\n'router' => [\n    'routes' => [\n        'blog' => [\n            /* ... */\n\n            'child_routes' => [\n                /* ... */\n\n                'delete' => [\n                    'type' => Segment::class,\n                    'options' => [\n                        'route' => '/delete/:id',\n                        'defaults' => [\n                            'controller' => Controller\\DeleteController::class,\n                            'action'     => 'delete',\n                        ],\n                        'constraints' => [\n                            'id' => '[1-9]\\d*',\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n],\n\n\n\nFinally, we'll create a new view script,\n\nmodule/Blog/view/blog/delete/delete.phtml\n, with the following contents:\n\n\n<h1>Delete post</h1>\n\n<p>Are you sure you want to delete the following post?</p>\n\n<ul class=\"list-group\">\n    <li class=\"list-group-item\"><?= $this->escapeHtml($this->post->getTitle()) ?></li>\n</ul>\n\n<form action=\"<?php $this->url('blog/delete', [], true) ?>\" method=\"post\">\n    <input type=\"hidden\" name=\"id\" value=\"<?= $this->escapeHtmlAttr($this->post->getId()) ?>\" />\n    <input class=\"btn btn-default\" type=\"submit\" name=\"confirm\" value=\"Cancel\" />\n    <input class=\"btn btn-danger\" type=\"submit\" name=\"confirm\" value=\"Delete\" />\n</form>\n\n\n\nThis time around, we're not using zend-form; as it consists of just a hidden\nelement and cancel/confirm buttons, there's no need to provide an OOP model for it.\n\n\nFrom here, you can now visit one of the existing blog posts, e.g.,\n\nhttp://localhost:8080/blog/delete/1\n to see the form. If you choose \nCancel\n,\nyou should be taken back to the list; if you choose \nDelete\n, it should delete\nthe post and then take you back to the list, and you should see the post is no\nlonger present.\n\n\nMaking the list more useful\n\n\nOur blog post list currently lists everything about all of our blog posts;\nadditionally, it doesn't link to them, which means we have to manually update\nthe URL in our browser in order to test functionality. Let's update the list\nview to be more useful; we'll:\n\n\n\n\nList just the title of each blog post;\n\n\nlinking the title to the post display;\n\n\nand providing links for editing and deleting the post.\n\n\nAdd a button to allow users to add a new post.\n\n\n\n\nIn a real-world application, we'd probably use some sort of access controls to\ndetermine if the edit and delete links will be displayed; we'll leave that for\nanother tutorial, however.\n\n\nOpen your \nmodule/Blog/view/blog/list/index.phtml\n file, and update it to read\nas follows:\n\n\n<h1>Blog Posts</h1>\n\n<div class=\"list-group\">\n<?php foreach ($this->posts as $post): ?>\n  <div class=\"list-group-item\">\n    <h4 class=\"list-group-item-heading\">\n      <a href=\"<?= $this->url('blog/detail', ['id' => $post->getId()]) ?>\">\n        <?= $post->getTitle() ?>\n      </a>\n    </h4>\n\n    <div class=\"btn-group\" role=\"group\" aria-label=\"Post actions\">\n      <a class=\"btn btn-xs btn-default\" href=\"<?= $this->url('blog/edit', ['id' => $post->getId()]) ?>\">Edit</a>\n      <a class=\"btn btn-xs btn-danger\" href=\"<?= $this->url('blog/delete', ['id' => $post->getId()]) ?>\">Delete</a>\n    </div>\n  </div>    \n<?php endforeach ?>\n</div>\n\n<div class=\"btn-group\" role=\"group\" aria-label=\"Post actions\">\n  <a class=\"btn btn-primary\" href=\"<?= $this->url('blog/add') ?>\">Write new post</a>\n</div>\n\n\n\nAt this point, we have a far more functional blog, as we can move around between\npages using links and buttons.\n\n\nSummary\n\n\nIn this chapter we've learned how data binding within the zend-form component\nworks, and used it to provide functionality for our update routine. We also\nlearned how this allows us to de-couple our controllers from the details of how\na form is structured, helping us keep implementation details out of our\ncontroller.\n\n\nWe also demonstrated the use of view partials, which allow us to split out\nduplication in our views and re-use them. In particular, we did this with our\nform, to prevent needlessly duplicating the form markup.\n\n\nFinally, we looked at two more aspects of the \nZend\\Db\\Sql\n subcomponent, and\nlearned how to \nUpdate\n and \nDelete\n operations.\n\n\nIn the next chapter we'll summarize everything we've done. We'll talk about the\ndesign patterns we've used, and we'll cover several questions that likely arose\nduring the course of this tutorial.",
            "title": "Editando e Deletando Dados"
        },
        {
            "location": "/in-depth-guide/data-binding/#editing-and-deleting-data",
            "text": "In the previous chapter we've come to learn how we can use the zend-form and\nzend-db components for  creating  new data-sets. This chapter will focus on\nfinalizing the CRUD functionality by introducing the concepts for  editing  and deleting  data.",
            "title": "Editing and Deleting Data"
        },
        {
            "location": "/in-depth-guide/data-binding/#binding-objects-to-forms",
            "text": "The one fundamental difference between our \"add post\" and \"edit post\" forms is\nthe existence of data.  This means we need to find a way to get data from our\nrepository into the form. Luckily, zend-form provides this via a data-binding  feature.  In order to use this feature, you will need to retrieve a  Post  instance, and\nbind it to the form. To do this, we will need to:   Add a dependency in our  WriteController  on our  PostRepositoryInterface ,\n  from which we will retrieve our  Post .  Add a new method to our  WriteController ,  editAction() , that will retrieve\n  a  Post , bind it to the form, and either display the form or process it.  Update our  WriteControllerFactory  to inject the  PostRepositoryInterface .   We'll begin by updating the  WriteController :   We will import the  PostRepositoryInterface .  We will add a property for storing the  PostRepositoryInterface .  We will update the constructor to accept the  PostRepositoryInterface .  We will add the  editAction()  implementation.   The final result will look like the following:  <?php\n// In module/Blog/src/Controller/WriteController.php:\n\nnamespace Blog\\Controller;\n\nuse Blog\\Form\\PostForm;\nuse Blog\\Model\\Post;\nuse Blog\\Model\\PostCommandInterface;\nuse Blog\\Model\\PostRepositoryInterface;\nuse InvalidArgumentException;\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass WriteController extends AbstractActionController\n{\n    /**\n     * @var PostCommandInterface\n     */\n    private $command;\n\n    /**\n     * @var PostForm\n     */\n    private $form;\n\n    /**\n     * @var PostRepositoryInterface\n     */\n    private $repository;\n\n    /**\n     * @param PostCommandInterface $command\n     * @param PostForm $form\n     * @param PostRepositoryInterface $repository\n     */\n    public function __construct(\n        PostCommandInterface $command,\n        PostForm $form,\n        PostRepositoryInterface $repository\n    ) {\n        $this->command = $command;\n        $this->form = $form;\n        $this->repository = $repository;\n    }\n\n    public function addAction()\n    {\n        $request   = $this->getRequest();\n        $viewModel = new ViewModel(['form' => $this->form]);\n\n        if (! $request->isPost()) {\n            return $viewModel;\n        }\n\n        $this->form->setData($request->getPost());\n\n        if (! $this->form->isValid()) {\n            return $viewModel;\n        }\n\n        $post = $this->form->getData();\n\n        try {\n            $post = $this->command->insertPost($post);\n        } catch (\\Exception $ex) {\n            // An exception occurred; we may want to log this later and/or\n            // report it to the user. For now, we'll just re-throw.\n            throw $ex;\n        }\n\n        return $this->redirect()->toRoute(\n            'blog/detail',\n            ['id' => $post->getId()]\n        );\n    }\n\n    public function editAction()\n    {\n        $id = $this->params()->fromRoute('id');\n        if (! $id) {\n            return $this->redirect()->toRoute('blog');\n        }\n\n        try {\n            $post = $this->repository->findPost($id);\n        } catch (InvalidArgumentException $ex) {\n            return $this->redirect()->toRoute('blog');\n        }\n\n        $this->form->bind($post);\n        $viewModel = new ViewModel(['form' => $this->form]);\n\n        $request = $this->getRequest();\n        if (! $request->isPost()) {\n            return $viewModel;\n        }\n\n        $this->form->setData($request->getPost());\n\n        if (! $this->form->isValid()) {\n            return $viewModel;\n        }\n\n        $post = $this->command->updatePost($post);\n        return $this->redirect()->toRoute(\n            'blog/detail',\n            ['id' => $post->getId()]\n        );\n    }\n}  The primary differences between  addAction()  and  editAction()  are that the\nlatter needs to first fetch a  Post , and this post is  bound  to the form. By\nbinding it, we ensure that the data is populated in the form for the initial\ndisplay, and, once validated, the same instance is updated. This means that we\ncan omit the call to  getData()  after validating the form.  Now we need to update our  WriteControllerFactory . First, add a new import\nstatement to it:  // In module/Blog/src/Factory/WriteControllerFactory.php:\nuse Blog\\Model\\PostRepositoryInterface;  Next, update the body of the factory to read as follows:  // In module/Blog/src/Factory/WriteControllerFactory.php:\npublic function __invoke(ContainerInterface $container, $requestedName, array $options = null)\n{\n    $formManager = $container->get('FormElementManager');\n\n    return new WriteController(\n        $container->get(PostCommandInterface::class),\n        $formManager->get(PostForm::class),\n        $container->get(PostRepositoryInterface::class)\n    );\n}  The controller and model are now wired together, so it's time to turn to\nrouting.",
            "title": "Binding Objects to Forms"
        },
        {
            "location": "/in-depth-guide/data-binding/#adding-the-edit-route",
            "text": "The edit route is identical to the  blog/detail  route we previously defined,\nwith two exceptions:   it will have a path prefix,  /edit  it will route to our  WriteController   Update the 'blog'  child_routes  to add the new route:  // In module/Blog/config/module.config.php:\n\nuse Zend\\Router\\Http\\Segment;\n\nreturn [\n    'service_manager' => [ /* ... */ ],\n    'controllers'     => [ /* ... */ ],\n    'router'          => [\n        'routes' => [\n            'blog' => [\n                /* ... */\n\n                'child_routes' => [\n                    /* ... */\n\n                    'edit' => [\n                        'type' => Segment::class,\n                        'options' => [\n                            'route'    => '/edit/:id',\n                            'defaults' => [\n                                'controller' => Controller\\WriteController::class,\n                                'action'     => 'edit',\n                            ],\n                            'constraints' => [\n                                'id' => '[1-9]\\d*',\n                            ],\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n    'view_manager'    => [ /* ... */ ],\n];",
            "title": "Adding the edit route"
        },
        {
            "location": "/in-depth-guide/data-binding/#creating-the-edit-template",
            "text": "Rendering the form remains essentially the same between the  add  and  edit \ntemplates; the only difference between them is the form action. As such, we will\ncreate a new  partial  script for the form, update the  add  template to use it,\nand create a new  edit  template.  Create a new file,  module/Blog/view/blog/write/form.phtml , with the following\ncontents:  <?php\n$form = $this->form;\n$fieldset = $form->get('post');\n\n$title = $fieldset->get('title');\n$title->setAttribute('class', 'form-control');\n$title->setAttribute('placeholder', 'Post title');\n\n$text = $fieldset->get('text');\n$text->setAttribute('class', 'form-control');\n$text->setAttribute('placeholder', 'Post content');\n\n$submit = $form->get('submit');\n$submit->setValue($this->submitLabel);\n$submit->setAttribute('class', 'btn btn-primary');\n\n$form->prepare();\n\necho $this->form()->openTag($form);\n?>\n\n<fieldset>\n<div class=\"form-group\">\n    <?= $this->formLabel($title) ?>\n    <?= $this->formElement($title) ?>\n    <?= $this->formElementErrors()->render($title, ['class' => 'help-block']) ?>\n</div>\n\n<div class=\"form-group\">\n    <?= $this->formLabel($text) ?>\n    <?= $this->formElement($text) ?>\n    <?= $this->formElementErrors()->render($text, ['class' => 'help-block']) ?>\n</div>\n</fieldset>\n\n<?php\necho $this->formSubmit($submit);\necho $this->formHidden($fieldset->get('id'));\necho $this->form()->closeTag();  Now, update the  add  template,  module/Blog/view/write/add.phtml  to read as\nfollows:  <h1>Add a blog post</h1>\n\n<?php\n$form = $this->form;\n$form->setAttribute('action', $this->url());\necho $this->partial('blog/write/form', [\n    'form' => $form,\n    'submitLabel' => 'Insert new post',\n]);  The above retrieves the form, sets the form action, provides a\ncontext-appropriate label for the submit button, and renders it with our new\npartial view script.  Next in line is the creation of the new template,  blog/write/edit :  <h1>Edit blog post</h1>\n\n<?php\n$form = $this->form;\n$form->setAttribute('action', $this->url('blog/edit', [], true));\necho $this->partial('blog/write/form', [\n    'form' => $form,\n    'submitLabel' => 'Update post',\n]);  The three differences between the  add  and  edit  templates are:   The heading at the top of the page.  The URI used for the form action.  The label used for the submit button.   Because the URI requires the identifier, we need to ensure the identifier is\npassed. The way we've done this in the controllers is to pass the identifier as\na parameter:  $this->url('blog/edit/', ['id' => $id]) . This would require that\nwe pass the original  Post  instance or the identifier we pull from it to the\nview, however. zend-router allows another option, however: you can tell it to\nre-use currently matched parameters.  This is done by setting the last parameter\nof the view-helper to  true :  $this->url('blog/edit', [], true) .  If you try and update the post, it'll be successful, but you'll notice that no\nedits were saved! Why? Because we have not yet implemented the functionality in\nour command class. Let's do that now.  Edit the file  module/Blog/src/Model/ZendDbSqlCommand.php , and update the updatePost()  method to read as follows:  public function updatePost(Post $post)\n{\n    if (! $post->getId()) {\n        throw new RuntimeException('Cannot update post; missing identifier');\n    }\n\n    $update = new Update('posts');\n    $update->set([\n            'title' => $post->getTitle(),\n            'text' => $post->getText(),\n    ]);\n    $update->where(['id = ?' => $post->getId()]);\n\n    $sql = new Sql($this->db);\n    $statement = $sql->prepareStatementForSqlObject($update);\n    $result = $statement->execute();\n\n    if (! $result instanceof ResultInterface) {\n        throw new RuntimeException(\n            'Database error occurred during blog post update operation'\n        );\n    }\n\n    return $post;\n}  This looks very similar to the  insertPost()  implementation we did earlier. The\nprimary difference is the usage of the  Update  class; instead of calling a values()  method on it, we call:   set() , to provide the values we are updating.  where() , to provide criteria to determine which records (record singular, in\n  our case) are updated.   Additionally, we test for the presence of an identifier before performing the\noperation, and, because we already have one, and the  Post  submitted to us\ncontains all the edits we submitted to the database, we return it verbatim on\nsuccess.",
            "title": "Creating the edit template"
        },
        {
            "location": "/in-depth-guide/data-binding/#implementing-the-delete-functionality",
            "text": "Last but not least, it's time to delete some data. We start this process by\nimplementing the  deletePost()  method in our  ZendDbSqlCommand  class:  // In module/Blog/src/Model/ZendDbSqlCommand.php:\n\npublic function deletePost(Post $post)\n{\n    if (! $post->getId()) {\n        throw new RuntimeException('Cannot update post; missing identifier');\n    }\n\n    $delete = new Delete('posts');\n    $delete->where(['id = ?' => $post->getId()]);\n\n    $sql = new Sql($this->db);\n    $statement = $sql->prepareStatementForSqlObject($delete);\n    $result = $statement->execute();\n\n    if (! $result instanceof ResultInterface) {\n        return false;\n    }\n\n    return true;\n}  The above uses  Zend\\Db\\Sql\\Delete  to create the SQL necessary to delete the\npost with the given identifier, which we then execute.  Next, let's create a new controller,  Blog\\Controller\\DeleteController , in a\nnew file  module/Blog/src/Controller/DeleteController.php , with the following\ncontents:  <?php\nnamespace Blog\\Controller;\n\nuse Blog\\Model\\Post;\nuse Blog\\Model\\PostCommandInterface;\nuse Blog\\Model\\PostRepositoryInterface;\nuse InvalidArgumentException;\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass DeleteController extends AbstractActionController\n{\n    /**\n     * @var PostCommandInterface\n     */\n    private $command;\n\n    /**\n     * @var PostRepositoryInterface\n     */\n    private $repository;\n\n    /**\n     * @param PostCommandInterface $command\n     * @param PostRepositoryInterface $repository\n     */\n    public function __construct(\n        PostCommandInterface $command,\n        PostRepositoryInterface $repository\n    ) {\n        $this->command = $command;\n        $this->repository = $repository;\n    }\n\n    public function deleteAction()\n    {\n        $id = $this->params()->fromRoute('id');\n        if (! $id) {\n            return $this->redirect()->toRoute('blog');\n        }\n\n        try {\n            $post = $this->repository->findPost($id);\n        } catch (InvalidArgumentException $ex) {\n            return $this->redirect()->toRoute('blog');\n        }\n\n        $request = $this->getRequest();\n        if (! $request->isPost()) {\n            return new ViewModel(['post' => $post]);\n        }\n\n        if ($id != $request->getPost('id')\n            || 'Delete' !== $request->getPost('confirm', 'no')\n        ) {\n            return $this->redirect()->toRoute('blog');\n        }\n\n        $post = $this->command->deletePost($post);\n        return $this->redirect()->toRoute('blog');\n    }\n}  Like the  WriteController , it composes both our  PostRepositoryInterface  and PostCommandInterface . The former is used to ensure we are referencing a valid\npost instance, and the latter to perform the actual deletion.  When a user requests the page via the  GET  method, we will display a page\ncontaining details of the post, and a confirmation form. When submitted, we'll\ncheck to make sure they confirmed the deletion before issuing our delete\ncommand. If any conditions fail, or on a successful deletion, we redirect to our\nblog listing page.  Like the other controllers, we now need a factory. Create the file module/Blog/src/Factory/DeleteControllerFactory.php  with the following\ncontents:  <?php\nnamespace Blog\\Factory;\n\nuse Blog\\Controller\\DeleteController;\nuse Blog\\Model\\PostCommandInterface;\nuse Blog\\Model\\PostRepositoryInterface;\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Factory\\FactoryInterface;\n\nclass DeleteControllerFactory implements FactoryInterface\n{\n    /**\n     * @param ContainerInterface $container\n     * @param string $requestedName\n     * @param null|array $options\n     * @return DeleteController\n     */\n    public function __invoke(ContainerInterface $container, $requestedName, array $options = null)\n    {\n        return new DeleteController(\n            $container->get(PostCommandInterface::class),\n            $container->get(PostRepositoryInterface::class)\n        );\n    }\n}  We'll now wire this into the application, mapping the controller to its factory,\nand providing a new route. Open the file  module/Blog/config/module.config.php \nand make the following edits.  First, map the controller to its factory:  'controllers' => [\n    'factories' => [\n        Controller\\ListController::class => Factory\\ListControllerFactory::class,\n        Controller\\WriteController::class => Factory\\WriteControllerFactory::class,\n        // Add the following line:\n        Controller\\DeleteController::class => Factory\\DeleteControllerFactory::class,\n    ],\n],  Now add another child route to our \"blog\" route:  'router' => [\n    'routes' => [\n        'blog' => [\n            /* ... */\n\n            'child_routes' => [\n                /* ... */\n\n                'delete' => [\n                    'type' => Segment::class,\n                    'options' => [\n                        'route' => '/delete/:id',\n                        'defaults' => [\n                            'controller' => Controller\\DeleteController::class,\n                            'action'     => 'delete',\n                        ],\n                        'constraints' => [\n                            'id' => '[1-9]\\d*',\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n],  Finally, we'll create a new view script, module/Blog/view/blog/delete/delete.phtml , with the following contents:  <h1>Delete post</h1>\n\n<p>Are you sure you want to delete the following post?</p>\n\n<ul class=\"list-group\">\n    <li class=\"list-group-item\"><?= $this->escapeHtml($this->post->getTitle()) ?></li>\n</ul>\n\n<form action=\"<?php $this->url('blog/delete', [], true) ?>\" method=\"post\">\n    <input type=\"hidden\" name=\"id\" value=\"<?= $this->escapeHtmlAttr($this->post->getId()) ?>\" />\n    <input class=\"btn btn-default\" type=\"submit\" name=\"confirm\" value=\"Cancel\" />\n    <input class=\"btn btn-danger\" type=\"submit\" name=\"confirm\" value=\"Delete\" />\n</form>  This time around, we're not using zend-form; as it consists of just a hidden\nelement and cancel/confirm buttons, there's no need to provide an OOP model for it.  From here, you can now visit one of the existing blog posts, e.g., http://localhost:8080/blog/delete/1  to see the form. If you choose  Cancel ,\nyou should be taken back to the list; if you choose  Delete , it should delete\nthe post and then take you back to the list, and you should see the post is no\nlonger present.",
            "title": "Implementing the delete functionality"
        },
        {
            "location": "/in-depth-guide/data-binding/#making-the-list-more-useful",
            "text": "Our blog post list currently lists everything about all of our blog posts;\nadditionally, it doesn't link to them, which means we have to manually update\nthe URL in our browser in order to test functionality. Let's update the list\nview to be more useful; we'll:   List just the title of each blog post;  linking the title to the post display;  and providing links for editing and deleting the post.  Add a button to allow users to add a new post.   In a real-world application, we'd probably use some sort of access controls to\ndetermine if the edit and delete links will be displayed; we'll leave that for\nanother tutorial, however.  Open your  module/Blog/view/blog/list/index.phtml  file, and update it to read\nas follows:  <h1>Blog Posts</h1>\n\n<div class=\"list-group\">\n<?php foreach ($this->posts as $post): ?>\n  <div class=\"list-group-item\">\n    <h4 class=\"list-group-item-heading\">\n      <a href=\"<?= $this->url('blog/detail', ['id' => $post->getId()]) ?>\">\n        <?= $post->getTitle() ?>\n      </a>\n    </h4>\n\n    <div class=\"btn-group\" role=\"group\" aria-label=\"Post actions\">\n      <a class=\"btn btn-xs btn-default\" href=\"<?= $this->url('blog/edit', ['id' => $post->getId()]) ?>\">Edit</a>\n      <a class=\"btn btn-xs btn-danger\" href=\"<?= $this->url('blog/delete', ['id' => $post->getId()]) ?>\">Delete</a>\n    </div>\n  </div>    \n<?php endforeach ?>\n</div>\n\n<div class=\"btn-group\" role=\"group\" aria-label=\"Post actions\">\n  <a class=\"btn btn-primary\" href=\"<?= $this->url('blog/add') ?>\">Write new post</a>\n</div>  At this point, we have a far more functional blog, as we can move around between\npages using links and buttons.",
            "title": "Making the list more useful"
        },
        {
            "location": "/in-depth-guide/data-binding/#summary",
            "text": "In this chapter we've learned how data binding within the zend-form component\nworks, and used it to provide functionality for our update routine. We also\nlearned how this allows us to de-couple our controllers from the details of how\na form is structured, helping us keep implementation details out of our\ncontroller.  We also demonstrated the use of view partials, which allow us to split out\nduplication in our views and re-use them. In particular, we did this with our\nform, to prevent needlessly duplicating the form markup.  Finally, we looked at two more aspects of the  Zend\\Db\\Sql  subcomponent, and\nlearned how to  Update  and  Delete  operations.  In the next chapter we'll summarize everything we've done. We'll talk about the\ndesign patterns we've used, and we'll cover several questions that likely arose\nduring the course of this tutorial.",
            "title": "Summary"
        },
        {
            "location": "/in-depth-guide/review/",
            "text": "Reviewing the Blog Module\n\n\nThroughout the tutorial, we have created a fully functional CRUD module\nusing a blog as an example. While doing so, we've made use of several different\ndesign patterns and best-practices. Now it's time to reiterate and take a look\nat some of the code samples we've written. This is going to be done in a Q&A\nfashion.\n\n\nDo we always need all the layers and interfaces?\n\n\nShort answer: no.\n\n\nLong answer: The importance of interfaces increases the bigger your application\nbecomes. If you can foresee that your application will be used by other people\nor should be extendable, then you should strongly consider creating interfaces\nand coding to them.  This is a very common best-practice that is not tied to\nZend Framework specifically, but rather more general object oriented\nprogramming.\n\n\nThe main role of the multiple layers that we have introduced are to provide a\nstrict separation of concerns for our application.\n\n\nIt is tempting to include your database access directly in your controllers. We\nrecommend splitting it out to other objects, and providing interfaces for the\ninteractions whenever you can. Doing so helps decouple your controllers from the\nimplementation, allowing you to swap out the implementation later without\nchanging the controllers. Using interfaces also simplifies testing, as you can\nprovide mock implementations easily.\n\n\nWhy are there so many controllers?\n\n\nWith the exception of our \nListController\n, we created a controller for each\nroute we added.\n\n\nWe could have combined these into a single controller. In practice, we have\nobserved the following when doing so:\n\n\n\n\nControllers grow in complexity, making maintenance and additions more\n  difficult.\n\n\nThe number of dependencies grows with the number of responsibilities. Many\n  actions may need only a subset of the dependencies, leading to needless\n  performance and resource overhead.\n\n\nTesting becomes more difficult.\n\n\nRe-use becomes more difficult.\n\n\n\n\nThe primary problem is that such controllers quickly break the\n\nSingle Responsibility Principle\n,\nand inherit all the problems that principle attempts to combat.\n\n\nWe recommend a single action per controller whenever possible.\n\n\nDo you have more questions? PR them!\n\n\nIf there's anything you feel that's missing in this FAQ, please create an issue\nor send a pull request with your question!",
            "title": "Revisando o M\u00f3dulo Blog"
        },
        {
            "location": "/in-depth-guide/review/#reviewing-the-blog-module",
            "text": "Throughout the tutorial, we have created a fully functional CRUD module\nusing a blog as an example. While doing so, we've made use of several different\ndesign patterns and best-practices. Now it's time to reiterate and take a look\nat some of the code samples we've written. This is going to be done in a Q&A\nfashion.",
            "title": "Reviewing the Blog Module"
        },
        {
            "location": "/in-depth-guide/review/#do-we-always-need-all-the-layers-and-interfaces",
            "text": "Short answer: no.  Long answer: The importance of interfaces increases the bigger your application\nbecomes. If you can foresee that your application will be used by other people\nor should be extendable, then you should strongly consider creating interfaces\nand coding to them.  This is a very common best-practice that is not tied to\nZend Framework specifically, but rather more general object oriented\nprogramming.  The main role of the multiple layers that we have introduced are to provide a\nstrict separation of concerns for our application.  It is tempting to include your database access directly in your controllers. We\nrecommend splitting it out to other objects, and providing interfaces for the\ninteractions whenever you can. Doing so helps decouple your controllers from the\nimplementation, allowing you to swap out the implementation later without\nchanging the controllers. Using interfaces also simplifies testing, as you can\nprovide mock implementations easily.",
            "title": "Do we always need all the layers and interfaces?"
        },
        {
            "location": "/in-depth-guide/review/#why-are-there-so-many-controllers",
            "text": "With the exception of our  ListController , we created a controller for each\nroute we added.  We could have combined these into a single controller. In practice, we have\nobserved the following when doing so:   Controllers grow in complexity, making maintenance and additions more\n  difficult.  The number of dependencies grows with the number of responsibilities. Many\n  actions may need only a subset of the dependencies, leading to needless\n  performance and resource overhead.  Testing becomes more difficult.  Re-use becomes more difficult.   The primary problem is that such controllers quickly break the Single Responsibility Principle ,\nand inherit all the problems that principle attempts to combat.  We recommend a single action per controller whenever possible.",
            "title": "Why are there so many controllers?"
        },
        {
            "location": "/in-depth-guide/review/#do-you-have-more-questions-pr-them",
            "text": "If there's anything you feel that's missing in this FAQ, please create an issue\nor send a pull request with your question!",
            "title": "Do you have more questions? PR them!"
        },
        {
            "location": "/advanced-config/",
            "text": "Advanced Configuration Tricks\n\n\nConfiguration of zend-mvc applications happens in several steps:\n\n\n\n\nInitial configuration is passed to the \nApplication\n instance and used to seed\n  the \nModuleManager\n and \nServiceManager\n. In this tutorial, we will call this\n  configuration \nsystem configuration\n.\n\n\nThe \nModuleManager\n's \nConfigListener\n aggregates configuration and merges it\n  while modules are being loaded. In this tutorial, we will call this\n  configuration \napplication configuration\n.\n\n\nOnce configuration is aggregated from all modules, the \nConfigListener\n will\n  also merge application configuration globbed in specified directories\n  (typically \nconfig/autoload/\n).\n\n\nFinally, immediately prior to the merged application configuration being\n  passed to the \nServiceManager\n, it is passed to a special \nEVENT_MERGE_CONFIG\n\n  event to allow further modification.\n\n\n\n\nIn this tutorial, we'll look at the exact sequence, and how you can tie into it.\n\n\nSystem configuration\n\n\nTo begin module loading, we have to tell the \nApplication\n instance about the\navailable modules and where they live, optionally provide some information to\nthe default module listeners (e.g., where application configuration lives, and\nwhat files to load; whether to cache merged configuration, and where; etc.), and\noptionally seed the \nServiceManager\n. For purposes of this tutorial we will call\nthis the \nsystem configuration\n.\n\n\nWhen using the skeleton application, the \nsystem configuration\n is by default\nin \nconfig/application.config.php\n. The defaults look like this:\n\n\nreturn [\n    // Retrieve list of modules used in this application.\n    'modules' => require __DIR__ . '/modules.config.php',\n\n    // These are various options for the listeners attached to the ModuleManager\n    'module_listener_options' => [\n        // This should be an array of paths in which modules reside.\n        // If a string key is provided, the listener will consider that a module\n        // namespace, the value of that key the specific path to that module's\n        // Module class.\n        'module_paths' => [\n            './module',\n            './vendor',\n        ],\n\n        // An array of paths from which to glob configuration files after\n        // modules are loaded. These effectively override configuration\n        // provided by modules themselves. Paths may use GLOB_BRACE notation.\n        'config_glob_paths' => [\n            realpath(__DIR__) . '/autoload/{{,*.}global,{,*.}local}.php',\n        ],\n\n        // Whether or not to enable a configuration cache.\n        // If enabled, the merged configuration will be cached and used in\n        // subsequent requests.\n        'config_cache_enabled' => true,\n\n        // The key used to create the configuration cache file name.\n        'config_cache_key' => 'application.config.cache',\n\n        // Whether or not to enable a module class map cache.\n        // If enabled, creates a module class map cache which will be used\n        // by in future requests, to reduce the autoloading process.\n        'module_map_cache_enabled' => true,\n\n        // The key used to create the class map cache file name.\n        'module_map_cache_key' => 'application.module.cache',\n\n        // The path in which to cache merged configuration.\n        'cache_dir' => 'data/cache/',\n\n        // Whether or not to enable modules dependency checking.\n        // Enabled by default, prevents usage of modules that depend on other modules\n        // that weren't loaded.\n        // 'check_dependencies' => true,\n    ],\n\n    // Used to create an own service manager. May contain one or more child arrays.\n    // 'service_listener_options' => [\n    //     [\n    //         'service_manager' => $stringServiceManagerName,\n    //         'config_key'      => $stringConfigKey,\n    //         'interface'       => $stringOptionalInterface,\n    //         'method'          => $stringRequiredMethodName,\n    //     ],\n    // ],\n\n    // Initial configuration with which to seed the ServiceManager.\n    // Should be compatible with Zend\\ServiceManager\\Config.\n    // 'service_manager' => [],\n];\n\n\n\nThe system configuration is for the bits and pieces related to the MVC that run\nbefore your application is ready. The configuration is usually brief, and quite\nminimal.\n\n\nAlso, system configuration is used \nimmediately\n, and is not merged with any\nother configuration \u2014 which means, with the exception of the values under\nthe \nservice_manager\n key, it cannot be overridden by a module.\n\n\nThis leads us to our first trick: how do you provide environment-specific system\nconfiguration?\n\n\nEnvironment-specific system configuration\n\n\nWhat happens when you want to change the set of modules you use based on the\nenvironment? Or if the configuration caching should be enabled based on\nenvironment?\n\n\nIt is for this reason that the default system configuration we provide in the\nskeleton application is in PHP; providing it in PHP means you can\nprogrammatically manipulate it.\n\n\nAs an example, let's make the following requirements:\n\n\n\n\nWe want to use the \nZendDeveloperTools\n module in development only.\n\n\nWe want to have configuration caching on in production only.\n\n\n\n\nzfcampus/zf-development-mode\n\nprovides a concise and conventions-based approach to switching between\nspecifically production and development.  The package is installed by default\nwith version 3+ skeletons, and can be installed with existing v2 skeletons\nusing the following:\n\n\n$ composer require zfcampus/zf-development-mode\n\n\n\nThe approach it takes is as follows:\n\n\n\n\nThe user provides production settings in \nconfig/application.config.php\n.\n\n\nThe user provides development settings in\n  \nconfig/development.config.php.dist\n to override bootstrap-level settings\n  such as modules and configuration caching, and optionally also in\n  \nconfig/autoload/development.local.php.dist\n (to override application\n  settings).\n\n\nThe bootstrap script (\npublic/index.php\n) checks for\n  \nconfig/development.config.php\n, and, if found, merges its configuration with\n  the application configuration prior to configuring the \nApplication\n instance.\n\n\n\n\nWhen you execute:\n\n\n$ ./vendor/bin/zf-development-mode enable\n\n\n\nThe \n.dist\n files are copied to versions removing the suffix; doing so ensures\nthey will then be used when invoking the application.\n\n\nAs such, to accomplish our goals, we will do the following:\n\n\n\n\nIn \nconfig/development.config.php.dist\n, add \nZendDeveloperTools\n to the list\n  of modules:\n\n\n\n\n'modules' => [\n    'ZendDeveloperTools',\n],\n\n\n\n\n\nAlso in \nconfig/development.config.php.dist\n, we will disable config caching:\n\n\n\n\n'config_cache_enable' => false,\n\n\n\n\n\nIn \nconfig/application.config.php\n, we will enable config caching:\n\n\n\n\n'config_cache_enable' => true,\n\n\n\nEnabling development mode now enables the selected module, and disables\nconfiguration caching; disabling development mode enables configuration\ncaching. (Also, either operation clears the configuration cache.)\n\n\nIf you require additional environments, you can extend zf-development-mode to\naddress them using the same workflow.\n\n\nEnvironment-specific application configuration\n\n\nSometimes you want to change application configuration to load things such as\ndatabase adapters, log writers, cache adapters, and more based on the\nenvironment. These are typically managed in the service manager, and may be\ndefined by modules. You can override them at the application level via\n\nZend\\ModuleManager\\Listener\\ConfigListener\n, by specifying a glob path in the\n\nsystem configuration\n \u2014 the \nmodule_listener_options.config_glob_paths\n\nkey from the previous examples.\n\n\nThe default value for this is \nconfig/autoload/{{,*.}global,{,*.}local}.php\n.\nWhat this means is that it will look for \napplication configuration\n files in\nthe \nconfig/autoload\n directory, in the following order:\n\n\n\n\nglobal.php\n\n\n*.global.php\n\n\nlocal.php\n\n\n*.local.php\n\n\n\n\nThis allows you to define application-level defaults in \"global\" configuration\nfiles, which you would then commit to your version control system, and\nenvironment-specific overrides in your \"local\" configuration files, which you\nwould \nomit\n from version control.\n\n\n\n\nAdditional glob patterns for development mode\n\n\nWhen using zf-development-mode, as detailed in the previous section, the\nshipped \nconfig/development.config.php.dist\n file provides an additional\nglob pattern for specifying development configuration:\n\n\n\n\nconfig/autoload/{,*.}{global,local}-development.php\n\n\n\n\nThis will match files such as:\n\n\n\n\ndatabase.global-development.php\n\n\ndatabase.local-development.php\n\n\n\n\nThese will only be considered when development mode is enabled!\n\n\n\n\nThis is a great solution for development, as it allows you to specify alternate\nconfiguration that's specific to your development environment without worrying\nabout accidently deploying it. However, what if you have more environments\n\u2014 such as a \"testing\" or \"staging\" environment \u2014 and they each have\ntheir own specific overrides?\n\n\nTo accomplish this, we'll provide an \nenvironment variable\n via our web server\nconfiguration, \nAPP_ENV\n. In Apache, you'd put a directive like the following\nin either your system-wide apache.conf or httpd.conf, or in the definition for\nyour virtual host; alternately, it can be placed in an .htaccess file.\n\n\nSetEnv \"APP_ENV\" \"development\"\n\n\n\nFor other web servers, consult the web server documentation to determine how to\nset environment variables.\n\n\nTo simplify matters, we'll assume the environment is \"production\" if no\nenvironment variable is present.\n\n\nWith that in place, We can alter the glob path in the system configuration\nslightly:\n\n\n'config_glob_paths' => [\n    realpath(__DIR__) . sprintf('config/autoload/{,*.}{global,%s,local}.php', getenv('APP_ENV') ?: 'production')\n],\n\n\n\nThe above will allow you to define an additional set of application\nconfiguration files per environment; furthermore, these will be loaded \nonly\n if\nthat environment is detected!\n\n\nAs an example, consider the following tree of configuration files:\n\n\nconfig/\n    autoload/\n        global.php\n        local.php\n        users.development.php\n        users.testing.php\n        users.local.php\n\n\n\nIf \n$env\n evaluates to \ntesting\n, then the following files will be merged, in\nthe following order:\n\n\nglobal.php\nusers.testing.php\nlocal.php\nusers.local.php\n\n\n\nNote that \nusers.development.php\n is not loaded \u2014 this is because it will\nnot match the glob pattern!\n\n\nAlso, because of the order in which they are loaded, you can predict which\nvalues will overwrite the others, allowing you to both selectively overwrite as\nwell as debug later.\n\n\n\n\nOrder of config merging\n\n\nThe files under \nconfig/autoload/\n are merged \nafter\n your module\nconfiguration, detailed in next section. We have detailed it here, however, as\nsetting up the \napplication configuration\n glob path happens within the\n\nsystem configuration\n (\nconfig/application.config.php\n).\n\n\n\n\nModule Configuration\n\n\nOne responsibility of modules is to provide their own configuration to the\napplication. Modules have two general mechanisms for doing this.\n\n\nFirst\n, modules that either implement\n\nZend\\ModuleManager\\Feature\\ConfigProviderInterface\n and/or a \ngetConfig()\n\nmethod can return their configuration. The default, recommended implementation\nof the \ngetConfig()\n method is:\n\n\npublic function getConfig()\n{\n    return include __DIR__ . '/config/module.config.php';\n}\n\n\n\nwhere \nmodule.config.php\n returns a PHP array. From that PHP array you can\nprovide general configuration as well as configuration for all the available\n\nManager\n classes provided by the ServiceManager. Please refer to the\n\nConfiguration mapping table\n to see which\nconfiguration key is used for each specific \nManager\n.\n\n\nSecond\n, modules can implement a number of interfaces and/or methods related\nto specific service manager or plugin manager configuration. You will find an\noverview of all interfaces and their matching Module Configuration functions\ninside the \nConfiguration mapping table\n.\n\n\nMost interfaces are in the \nZend\\ModuleManager\\Feature\n namespace (some have\nmoved to the individual components), and each is expected to return an array of\nconfiguration for a service manager, as denoted in the section on\n\ndefault service configuration\n.\n\n\nConfiguration mapping table\n\n\n\n\n\n\n\n\nManager name\n\n\nInterface name\n\n\nModule method name\n\n\nConfig key name\n\n\n\n\n\n\n\n\n\n\nControllerPluginManager\n\n\nControllerPluginProviderInterface\n\n\ngetControllerPluginConfig()\n\n\ncontroller_plugins\n\n\n\n\n\n\nControllerManager\n\n\nControllerProviderInterface\n\n\ngetControllerConfig()\n\n\ncontrollers\n\n\n\n\n\n\nFilterManager\n\n\nFilterProviderInterface\n\n\ngetFilterConfig()\n\n\nfilters\n\n\n\n\n\n\nFormElementManager\n\n\nFormElementProviderInterface\n\n\ngetFormElementConfig()\n\n\nform_elements\n\n\n\n\n\n\nHydratorManager\n\n\nHydratorProviderInterface\n\n\ngetHydratorConfig()\n\n\nhydrators\n\n\n\n\n\n\nInputFilterManager\n\n\nInputFilterProviderInterface\n\n\ngetInputFilterConfig()\n\n\ninput_filters\n\n\n\n\n\n\nRoutePluginManager\n\n\nRouteProviderInterface\n\n\ngetRouteConfig()\n\n\nroute_manager\n\n\n\n\n\n\nSerializerAdapterManager\n\n\nSerializerProviderInterface\n\n\ngetSerializerConfig()\n\n\nserializers\n\n\n\n\n\n\nServiceLocator\n\n\nServiceProviderInterface\n\n\ngetServiceConfig()\n\n\nservice_manager\n\n\n\n\n\n\nValidatorManager\n\n\nValidatorProviderInterface\n\n\ngetValidatorConfig()\n\n\nvalidators\n\n\n\n\n\n\nViewHelperManager\n\n\nViewHelperProviderInterface\n\n\ngetViewHelperConfig()\n\n\nview_helpers\n\n\n\n\n\n\nLogProcessorManager\n\n\nLogProcessorProviderInterface\n\n\ngetLogProcessorConfig\n\n\nlog_processors\n\n\n\n\n\n\nLogWriterManager\n\n\nLogWriterProviderInterface\n\n\ngetLogWriterConfig\n\n\nlog_writers\n\n\n\n\n\n\n\n\nConfiguration Priority\n\n\nConsidering that you may have service configuration in your module configuration file, what has precedence?\n\n\nThe order in which they are merged is:\n\n\n\n\nconfiguration returned by the various service configuration methods in a module class\n\n\nconfiguration returned by \ngetConfig()\n\n\n\n\nIn other words, your \ngetConfig()\n wins over the various service configuration\nmethods. Additionally, and of particular note: the configuration returned from\nthose methods will \nnot\n be cached.\n\n\n\n\nUse cases for service configuration methods\n\n\nUse the various service configuration methods when you need to define closures\nor instance callbacks for factories, abstract factories, and initializers.\nThis prevents caching problems, and also allows you to write your\nconfiguration files in other markup formats.\n\n\n\n\nManipulating merged configuration\n\n\nOccasionally you will want to not just override an application configuration\nkey, but actually remove it. Since merging will not remove keys, how can you\nhandle this?\n\n\nZend\\ModuleManager\\Listener\\ConfigListener\n triggers a special event,\n\nZend\\ModuleManager\\ModuleEvent::EVENT_MERGE_CONFIG\n, after merging all\nconfiguration, but prior to it being passed to the \nServiceManager\n. By\nlistening to this event, you can inspect the merged configuration and manipulate\nit.\n\n\nThe \nConfigListener\n itself listens to the event at priority 1000 (i.e., very\nhigh), which is when the configuration is merged. You can tie into this to\nmodify the merged configuration from your module, via the \ninit()\n method.\n\n\nnamespace Foo;\n\nuse Zend\\ModuleManager\\ModuleEvent;\nuse Zend\\ModuleManager\\ModuleManager;\n\nclass Module\n{\n    public function init(ModuleManager $moduleManager)\n    {\n        $events = $moduleManager->getEventManager();\n\n        // Registering a listener at default priority, 1, which will trigger\n        // after the ConfigListener merges config.\n        $events->attach(ModuleEvent::EVENT_MERGE_CONFIG, [$this, 'onMergeConfig']);\n    }\n\n    public function onMergeConfig(ModuleEvent $e)\n    {\n        $configListener = $e->getConfigListener();\n        $config         = $configListener->getMergedConfig(false);\n\n        // Modify the configuration; here, we'll remove a specific key:\n        if (isset($config['some_key'])) {\n            unset($config['some_key']);\n        }\n\n        // Pass the changed configuration back to the listener:\n        $configListener->setMergedConfig($config);\n    }\n}\n\n\n\nAt this point, the merged application configuration will no longer contain the\nkey \nsome_key\n.\n\n\n\n\nCached configuration and merging\n\n\nIf a cached config is used by the \nModuleManager\n, the \nEVENT_MERGE_CONFIG\n\nevent will not be triggered. However, typically that means that what is cached\nwill be what was originally manipulated by your listener.\n\n\n\n\nConfiguration merging workflow\n\n\nTo cap off the tutorial, let's review how and when configuration is defined and\nmerged.\n\n\n\n\nSystem configuration\n\n\nDefined in \nconfig/application.config.php\n\n\nNo merging occurs\n\n\nAllows manipulation programmatically, which allows the ability to:\n\n\nAlter flags based on computed values\n\n\nAlter the configuration glob path based on computed values\n\n\nConfiguration is passed to the \nApplication\n instance, and then the\n  \nModuleManager\n in order to initialize the system.\n\n\n\n\n\n\nApplication configuration\n\n\nThe \nModuleManager\n loops through each module class in the order defined in the \nsystem configuration\n\n\nService configuration defined in \nModule\n class methods is aggregated\n\n\nConfiguration returned by \nModule::getConfig()\n is aggregated\n\n\nFiles detected from the \nservice configuration\n \nconfig_glob_paths\n\n  setting are merged, based on the order they resolve in the glob path.\n\n\nConfigListener\n triggers \nEVENT_MERGE_CONFIG\n:\n\n\nConfigListener\n merges configuration\n\n\nAny other event listeners manipulate the configuration\n\n\nMerged configuration is finally passed to the \nServiceManager",
            "title": "Configura\u00e7\u00e3o Avan\u00e7ada"
        },
        {
            "location": "/advanced-config/#advanced-configuration-tricks",
            "text": "Configuration of zend-mvc applications happens in several steps:   Initial configuration is passed to the  Application  instance and used to seed\n  the  ModuleManager  and  ServiceManager . In this tutorial, we will call this\n  configuration  system configuration .  The  ModuleManager 's  ConfigListener  aggregates configuration and merges it\n  while modules are being loaded. In this tutorial, we will call this\n  configuration  application configuration .  Once configuration is aggregated from all modules, the  ConfigListener  will\n  also merge application configuration globbed in specified directories\n  (typically  config/autoload/ ).  Finally, immediately prior to the merged application configuration being\n  passed to the  ServiceManager , it is passed to a special  EVENT_MERGE_CONFIG \n  event to allow further modification.   In this tutorial, we'll look at the exact sequence, and how you can tie into it.",
            "title": "Advanced Configuration Tricks"
        },
        {
            "location": "/advanced-config/#system-configuration",
            "text": "To begin module loading, we have to tell the  Application  instance about the\navailable modules and where they live, optionally provide some information to\nthe default module listeners (e.g., where application configuration lives, and\nwhat files to load; whether to cache merged configuration, and where; etc.), and\noptionally seed the  ServiceManager . For purposes of this tutorial we will call\nthis the  system configuration .  When using the skeleton application, the  system configuration  is by default\nin  config/application.config.php . The defaults look like this:  return [\n    // Retrieve list of modules used in this application.\n    'modules' => require __DIR__ . '/modules.config.php',\n\n    // These are various options for the listeners attached to the ModuleManager\n    'module_listener_options' => [\n        // This should be an array of paths in which modules reside.\n        // If a string key is provided, the listener will consider that a module\n        // namespace, the value of that key the specific path to that module's\n        // Module class.\n        'module_paths' => [\n            './module',\n            './vendor',\n        ],\n\n        // An array of paths from which to glob configuration files after\n        // modules are loaded. These effectively override configuration\n        // provided by modules themselves. Paths may use GLOB_BRACE notation.\n        'config_glob_paths' => [\n            realpath(__DIR__) . '/autoload/{{,*.}global,{,*.}local}.php',\n        ],\n\n        // Whether or not to enable a configuration cache.\n        // If enabled, the merged configuration will be cached and used in\n        // subsequent requests.\n        'config_cache_enabled' => true,\n\n        // The key used to create the configuration cache file name.\n        'config_cache_key' => 'application.config.cache',\n\n        // Whether or not to enable a module class map cache.\n        // If enabled, creates a module class map cache which will be used\n        // by in future requests, to reduce the autoloading process.\n        'module_map_cache_enabled' => true,\n\n        // The key used to create the class map cache file name.\n        'module_map_cache_key' => 'application.module.cache',\n\n        // The path in which to cache merged configuration.\n        'cache_dir' => 'data/cache/',\n\n        // Whether or not to enable modules dependency checking.\n        // Enabled by default, prevents usage of modules that depend on other modules\n        // that weren't loaded.\n        // 'check_dependencies' => true,\n    ],\n\n    // Used to create an own service manager. May contain one or more child arrays.\n    // 'service_listener_options' => [\n    //     [\n    //         'service_manager' => $stringServiceManagerName,\n    //         'config_key'      => $stringConfigKey,\n    //         'interface'       => $stringOptionalInterface,\n    //         'method'          => $stringRequiredMethodName,\n    //     ],\n    // ],\n\n    // Initial configuration with which to seed the ServiceManager.\n    // Should be compatible with Zend\\ServiceManager\\Config.\n    // 'service_manager' => [],\n];  The system configuration is for the bits and pieces related to the MVC that run\nbefore your application is ready. The configuration is usually brief, and quite\nminimal.  Also, system configuration is used  immediately , and is not merged with any\nother configuration \u2014 which means, with the exception of the values under\nthe  service_manager  key, it cannot be overridden by a module.  This leads us to our first trick: how do you provide environment-specific system\nconfiguration?",
            "title": "System configuration"
        },
        {
            "location": "/advanced-config/#environment-specific-system-configuration",
            "text": "What happens when you want to change the set of modules you use based on the\nenvironment? Or if the configuration caching should be enabled based on\nenvironment?  It is for this reason that the default system configuration we provide in the\nskeleton application is in PHP; providing it in PHP means you can\nprogrammatically manipulate it.  As an example, let's make the following requirements:   We want to use the  ZendDeveloperTools  module in development only.  We want to have configuration caching on in production only.   zfcampus/zf-development-mode \nprovides a concise and conventions-based approach to switching between\nspecifically production and development.  The package is installed by default\nwith version 3+ skeletons, and can be installed with existing v2 skeletons\nusing the following:  $ composer require zfcampus/zf-development-mode  The approach it takes is as follows:   The user provides production settings in  config/application.config.php .  The user provides development settings in\n   config/development.config.php.dist  to override bootstrap-level settings\n  such as modules and configuration caching, and optionally also in\n   config/autoload/development.local.php.dist  (to override application\n  settings).  The bootstrap script ( public/index.php ) checks for\n   config/development.config.php , and, if found, merges its configuration with\n  the application configuration prior to configuring the  Application  instance.   When you execute:  $ ./vendor/bin/zf-development-mode enable  The  .dist  files are copied to versions removing the suffix; doing so ensures\nthey will then be used when invoking the application.  As such, to accomplish our goals, we will do the following:   In  config/development.config.php.dist , add  ZendDeveloperTools  to the list\n  of modules:   'modules' => [\n    'ZendDeveloperTools',\n],   Also in  config/development.config.php.dist , we will disable config caching:   'config_cache_enable' => false,   In  config/application.config.php , we will enable config caching:   'config_cache_enable' => true,  Enabling development mode now enables the selected module, and disables\nconfiguration caching; disabling development mode enables configuration\ncaching. (Also, either operation clears the configuration cache.)  If you require additional environments, you can extend zf-development-mode to\naddress them using the same workflow.",
            "title": "Environment-specific system configuration"
        },
        {
            "location": "/advanced-config/#environment-specific-application-configuration",
            "text": "Sometimes you want to change application configuration to load things such as\ndatabase adapters, log writers, cache adapters, and more based on the\nenvironment. These are typically managed in the service manager, and may be\ndefined by modules. You can override them at the application level via Zend\\ModuleManager\\Listener\\ConfigListener , by specifying a glob path in the system configuration  \u2014 the  module_listener_options.config_glob_paths \nkey from the previous examples.  The default value for this is  config/autoload/{{,*.}global,{,*.}local}.php .\nWhat this means is that it will look for  application configuration  files in\nthe  config/autoload  directory, in the following order:   global.php  *.global.php  local.php  *.local.php   This allows you to define application-level defaults in \"global\" configuration\nfiles, which you would then commit to your version control system, and\nenvironment-specific overrides in your \"local\" configuration files, which you\nwould  omit  from version control.",
            "title": "Environment-specific application configuration"
        },
        {
            "location": "/advanced-config/#additional-glob-patterns-for-development-mode",
            "text": "When using zf-development-mode, as detailed in the previous section, the\nshipped  config/development.config.php.dist  file provides an additional\nglob pattern for specifying development configuration:   config/autoload/{,*.}{global,local}-development.php   This will match files such as:   database.global-development.php  database.local-development.php   These will only be considered when development mode is enabled!   This is a great solution for development, as it allows you to specify alternate\nconfiguration that's specific to your development environment without worrying\nabout accidently deploying it. However, what if you have more environments\n\u2014 such as a \"testing\" or \"staging\" environment \u2014 and they each have\ntheir own specific overrides?  To accomplish this, we'll provide an  environment variable  via our web server\nconfiguration,  APP_ENV . In Apache, you'd put a directive like the following\nin either your system-wide apache.conf or httpd.conf, or in the definition for\nyour virtual host; alternately, it can be placed in an .htaccess file.  SetEnv \"APP_ENV\" \"development\"  For other web servers, consult the web server documentation to determine how to\nset environment variables.  To simplify matters, we'll assume the environment is \"production\" if no\nenvironment variable is present.  With that in place, We can alter the glob path in the system configuration\nslightly:  'config_glob_paths' => [\n    realpath(__DIR__) . sprintf('config/autoload/{,*.}{global,%s,local}.php', getenv('APP_ENV') ?: 'production')\n],  The above will allow you to define an additional set of application\nconfiguration files per environment; furthermore, these will be loaded  only  if\nthat environment is detected!  As an example, consider the following tree of configuration files:  config/\n    autoload/\n        global.php\n        local.php\n        users.development.php\n        users.testing.php\n        users.local.php  If  $env  evaluates to  testing , then the following files will be merged, in\nthe following order:  global.php\nusers.testing.php\nlocal.php\nusers.local.php  Note that  users.development.php  is not loaded \u2014 this is because it will\nnot match the glob pattern!  Also, because of the order in which they are loaded, you can predict which\nvalues will overwrite the others, allowing you to both selectively overwrite as\nwell as debug later.",
            "title": "Additional glob patterns for development mode"
        },
        {
            "location": "/advanced-config/#order-of-config-merging",
            "text": "The files under  config/autoload/  are merged  after  your module\nconfiguration, detailed in next section. We have detailed it here, however, as\nsetting up the  application configuration  glob path happens within the system configuration  ( config/application.config.php ).",
            "title": "Order of config merging"
        },
        {
            "location": "/advanced-config/#module-configuration",
            "text": "One responsibility of modules is to provide their own configuration to the\napplication. Modules have two general mechanisms for doing this.  First , modules that either implement Zend\\ModuleManager\\Feature\\ConfigProviderInterface  and/or a  getConfig() \nmethod can return their configuration. The default, recommended implementation\nof the  getConfig()  method is:  public function getConfig()\n{\n    return include __DIR__ . '/config/module.config.php';\n}  where  module.config.php  returns a PHP array. From that PHP array you can\nprovide general configuration as well as configuration for all the available Manager  classes provided by the ServiceManager. Please refer to the Configuration mapping table  to see which\nconfiguration key is used for each specific  Manager .  Second , modules can implement a number of interfaces and/or methods related\nto specific service manager or plugin manager configuration. You will find an\noverview of all interfaces and their matching Module Configuration functions\ninside the  Configuration mapping table .  Most interfaces are in the  Zend\\ModuleManager\\Feature  namespace (some have\nmoved to the individual components), and each is expected to return an array of\nconfiguration for a service manager, as denoted in the section on default service configuration .",
            "title": "Module Configuration"
        },
        {
            "location": "/advanced-config/#configuration-mapping-table",
            "text": "Manager name  Interface name  Module method name  Config key name      ControllerPluginManager  ControllerPluginProviderInterface  getControllerPluginConfig()  controller_plugins    ControllerManager  ControllerProviderInterface  getControllerConfig()  controllers    FilterManager  FilterProviderInterface  getFilterConfig()  filters    FormElementManager  FormElementProviderInterface  getFormElementConfig()  form_elements    HydratorManager  HydratorProviderInterface  getHydratorConfig()  hydrators    InputFilterManager  InputFilterProviderInterface  getInputFilterConfig()  input_filters    RoutePluginManager  RouteProviderInterface  getRouteConfig()  route_manager    SerializerAdapterManager  SerializerProviderInterface  getSerializerConfig()  serializers    ServiceLocator  ServiceProviderInterface  getServiceConfig()  service_manager    ValidatorManager  ValidatorProviderInterface  getValidatorConfig()  validators    ViewHelperManager  ViewHelperProviderInterface  getViewHelperConfig()  view_helpers    LogProcessorManager  LogProcessorProviderInterface  getLogProcessorConfig  log_processors    LogWriterManager  LogWriterProviderInterface  getLogWriterConfig  log_writers",
            "title": "Configuration mapping table"
        },
        {
            "location": "/advanced-config/#configuration-priority",
            "text": "Considering that you may have service configuration in your module configuration file, what has precedence?  The order in which they are merged is:   configuration returned by the various service configuration methods in a module class  configuration returned by  getConfig()   In other words, your  getConfig()  wins over the various service configuration\nmethods. Additionally, and of particular note: the configuration returned from\nthose methods will  not  be cached.",
            "title": "Configuration Priority"
        },
        {
            "location": "/advanced-config/#use-cases-for-service-configuration-methods",
            "text": "Use the various service configuration methods when you need to define closures\nor instance callbacks for factories, abstract factories, and initializers.\nThis prevents caching problems, and also allows you to write your\nconfiguration files in other markup formats.",
            "title": "Use cases for service configuration methods"
        },
        {
            "location": "/advanced-config/#manipulating-merged-configuration",
            "text": "Occasionally you will want to not just override an application configuration\nkey, but actually remove it. Since merging will not remove keys, how can you\nhandle this?  Zend\\ModuleManager\\Listener\\ConfigListener  triggers a special event, Zend\\ModuleManager\\ModuleEvent::EVENT_MERGE_CONFIG , after merging all\nconfiguration, but prior to it being passed to the  ServiceManager . By\nlistening to this event, you can inspect the merged configuration and manipulate\nit.  The  ConfigListener  itself listens to the event at priority 1000 (i.e., very\nhigh), which is when the configuration is merged. You can tie into this to\nmodify the merged configuration from your module, via the  init()  method.  namespace Foo;\n\nuse Zend\\ModuleManager\\ModuleEvent;\nuse Zend\\ModuleManager\\ModuleManager;\n\nclass Module\n{\n    public function init(ModuleManager $moduleManager)\n    {\n        $events = $moduleManager->getEventManager();\n\n        // Registering a listener at default priority, 1, which will trigger\n        // after the ConfigListener merges config.\n        $events->attach(ModuleEvent::EVENT_MERGE_CONFIG, [$this, 'onMergeConfig']);\n    }\n\n    public function onMergeConfig(ModuleEvent $e)\n    {\n        $configListener = $e->getConfigListener();\n        $config         = $configListener->getMergedConfig(false);\n\n        // Modify the configuration; here, we'll remove a specific key:\n        if (isset($config['some_key'])) {\n            unset($config['some_key']);\n        }\n\n        // Pass the changed configuration back to the listener:\n        $configListener->setMergedConfig($config);\n    }\n}  At this point, the merged application configuration will no longer contain the\nkey  some_key .",
            "title": "Manipulating merged configuration"
        },
        {
            "location": "/advanced-config/#cached-configuration-and-merging",
            "text": "If a cached config is used by the  ModuleManager , the  EVENT_MERGE_CONFIG \nevent will not be triggered. However, typically that means that what is cached\nwill be what was originally manipulated by your listener.",
            "title": "Cached configuration and merging"
        },
        {
            "location": "/advanced-config/#configuration-merging-workflow",
            "text": "To cap off the tutorial, let's review how and when configuration is defined and\nmerged.   System configuration  Defined in  config/application.config.php  No merging occurs  Allows manipulation programmatically, which allows the ability to:  Alter flags based on computed values  Alter the configuration glob path based on computed values  Configuration is passed to the  Application  instance, and then the\n   ModuleManager  in order to initialize the system.    Application configuration  The  ModuleManager  loops through each module class in the order defined in the  system configuration  Service configuration defined in  Module  class methods is aggregated  Configuration returned by  Module::getConfig()  is aggregated  Files detected from the  service configuration   config_glob_paths \n  setting are merged, based on the order they resolve in the glob path.  ConfigListener  triggers  EVENT_MERGE_CONFIG :  ConfigListener  merges configuration  Any other event listeners manipulate the configuration  Merged configuration is finally passed to the  ServiceManager",
            "title": "Configuration merging workflow"
        },
        {
            "location": "/i18n/",
            "text": "Internationalization\n\n\nIf you are building a site for an international audience, you will likely want\nto provide localized versions of common strings on your website, including menu\nitems, form labels, button labels, and more. Additionally, some websites require\nthat route path segments be localized.\n\n\nZend Framework provides internationalization (i18n) tools via the\n\nzend-i18n\n component, and\nintegration with zend-mvc via the \nzend-mvc-i18n\n\ncomponent.\n\n\nInstallation\n\n\nInstall zend-mvc-i18n via Composer:\n\n\n$ composer require zendframework/zend-mvc-i18n\n\n\n\nAssuming you are using \nzend-component-installer\n\n(which is installed by default with the skeleton application), this will prompt\nyou to install the component as a module in your application; make sure you\nselect either \napplication.config.php\n or \nmodules.config.php\n for the location.\n\n\nOnce installed, this component exposes several services, including:\n\n\n\n\nMvcTranslator\n, which implements the zend-i18n \nTranslatorInterface\n, as well\n  as the version specific to zend-validator, providing an instance that can be\n  used for all application contexts.\n\n\nA \"translator aware\" router.\n\n\n\n\nBy default, until you configure translations, installation has no practical\neffect. So the next step is creating translations to use in your application.\n\n\nCreating translations\n\n\nThe \nzend-i18n Translation chapter\n\ncovers the details of adding translations to your application. You can use PHP\narrays, INI files, or the popular gettext package (which allows you to use\nindustry standard tools such as \npoedit\n to\nedit translations).\n\n\n\n\nOnce you have some translation sources, you will need to put them somewhere your\napplication can access them. Options include:\n\n\n\n\nIn a subdirectory of the module that defines and/or consumes the translation\n  strings. As an example, \nmodule/Application/language/\n.\n\n\nIn your application data directory; e.g., \ndata/language/\n.\n\n\n\n\nMake sure you follow the guidelines from the zend-i18n documentation with\nregards to naming your files. Additionally, you may want to further segregate\nany such directory by text domain.\n\n\nFrom here, you need to configure the translator to use your files. This requires\nadding configuration in either your module or application configuration files\nthat provides:\n\n\n\n\nThe default locale if none is provided.\n\n\nTranslation file patterns, which include:\n\n\nthe translation source type (e.g., \ngettext\n, \nphparray\n, \nini\n)\n\n\nthe base directory in which they are stored\n\n\na file pattern for identifying the files to use\n\n\n\n\nAs examples:\n\n\n// in a module's module.config.php:\n'translator' => [\n    'locale' => 'en_US',\n    'translation_file_patterns' => [\n        [\n            'type'     => 'gettext',\n            'base_dir' => __DIR__ . '/../language',\n            'pattern'  => '%s.mo',\n        ],\n    ],\n],\n\n// or in config/autoload/global.php:\n'translator' => [\n    'locale' => 'en_US',\n    'translation_file_patterns' => [\n        [\n            'type'     => 'gettext',\n            'base_dir' => getcwd() .  '/data/language',\n            'pattern'  => '%s.mo',\n        ],\n    ],\n],\n\n\n\nOnce the above configuration is in place, the translator will be active in your\napplication, allowing you to use it.\n\n\nTranslating strings in templates\n\n\nOnce you have defined some strings to translate, and configured the application\nto use them, you can translate them in your application. The \ntranslate()\n\nand \ntranslatePlural()\n\nview helpers allow you to provide translations within your view scripts.\n\n\nAs an example, you might want to translate the string \"All rights reserved\" in\nyour footer. You could do the following in your layout script:\n\n\n<p>&copy; 2016 by Examples Ltd. <?= $this->translate('All rights reserved') ?></p>\n\n\n\nTranslating route segments\n\n\nIn order to enable route translation, you need to do two things:\n\n\n\n\nTell the router to use the translation-aware route class.\n\n\nOptionally, tell it which text domain to use (if not using the default text domain).\n\n\n\n\nTo tell the application to use the translation-aware route class, we can update\nour routing configuration. Underneath the top-level \nrouter\n key, we'll add the\n\nrouter_class\n key:\n\n\n// In a module.config.php file, or config/autoload/global.php:\n'router' => [\n    'router_class' => Zend\\Mvc\\I18n\\Router\\TranslatorAwareTreeRouteStack::class,\n    'routes' => [\n        /* ... */\n    ],\n],\n\n\n\nIf you want to use an alternate text domain, you can do so via the\n\ntranslator_text_domain\n key, also directly below the \nrouter\n key:\n\n\n// In a module.config.php file, or config/autoload/global.php:\n'router' => [\n    'router_class' => Zend\\Mvc\\I18n\\Router\\TranslatorAwareTreeRouteStack::class,\n    'translator_text_domain' => 'router',\n    'routes' => [\n        /* ... */\n    ],\n],\n\n\n\nNow that the router is aware of translations, we can use translatable strings in\nour routes. To do so, surround the string capable of translation with braces\n(\n{}\n). As an example:\n\n\n'route' => '/{login}',\n\n\n\nspecifies the word \"login\" as translatable.",
            "title": "Internacionaliza\u00e7\u00e3o"
        },
        {
            "location": "/i18n/#internationalization",
            "text": "If you are building a site for an international audience, you will likely want\nto provide localized versions of common strings on your website, including menu\nitems, form labels, button labels, and more. Additionally, some websites require\nthat route path segments be localized.  Zend Framework provides internationalization (i18n) tools via the zend-i18n  component, and\nintegration with zend-mvc via the  zend-mvc-i18n \ncomponent.",
            "title": "Internationalization"
        },
        {
            "location": "/i18n/#installation",
            "text": "Install zend-mvc-i18n via Composer:  $ composer require zendframework/zend-mvc-i18n  Assuming you are using  zend-component-installer \n(which is installed by default with the skeleton application), this will prompt\nyou to install the component as a module in your application; make sure you\nselect either  application.config.php  or  modules.config.php  for the location.  Once installed, this component exposes several services, including:   MvcTranslator , which implements the zend-i18n  TranslatorInterface , as well\n  as the version specific to zend-validator, providing an instance that can be\n  used for all application contexts.  A \"translator aware\" router.   By default, until you configure translations, installation has no practical\neffect. So the next step is creating translations to use in your application.",
            "title": "Installation"
        },
        {
            "location": "/i18n/#creating-translations",
            "text": "The  zend-i18n Translation chapter \ncovers the details of adding translations to your application. You can use PHP\narrays, INI files, or the popular gettext package (which allows you to use\nindustry standard tools such as  poedit  to\nedit translations).   Once you have some translation sources, you will need to put them somewhere your\napplication can access them. Options include:   In a subdirectory of the module that defines and/or consumes the translation\n  strings. As an example,  module/Application/language/ .  In your application data directory; e.g.,  data/language/ .   Make sure you follow the guidelines from the zend-i18n documentation with\nregards to naming your files. Additionally, you may want to further segregate\nany such directory by text domain.  From here, you need to configure the translator to use your files. This requires\nadding configuration in either your module or application configuration files\nthat provides:   The default locale if none is provided.  Translation file patterns, which include:  the translation source type (e.g.,  gettext ,  phparray ,  ini )  the base directory in which they are stored  a file pattern for identifying the files to use   As examples:  // in a module's module.config.php:\n'translator' => [\n    'locale' => 'en_US',\n    'translation_file_patterns' => [\n        [\n            'type'     => 'gettext',\n            'base_dir' => __DIR__ . '/../language',\n            'pattern'  => '%s.mo',\n        ],\n    ],\n],\n\n// or in config/autoload/global.php:\n'translator' => [\n    'locale' => 'en_US',\n    'translation_file_patterns' => [\n        [\n            'type'     => 'gettext',\n            'base_dir' => getcwd() .  '/data/language',\n            'pattern'  => '%s.mo',\n        ],\n    ],\n],  Once the above configuration is in place, the translator will be active in your\napplication, allowing you to use it.",
            "title": "Creating translations"
        },
        {
            "location": "/i18n/#translating-strings-in-templates",
            "text": "Once you have defined some strings to translate, and configured the application\nto use them, you can translate them in your application. The  translate() \nand  translatePlural() \nview helpers allow you to provide translations within your view scripts.  As an example, you might want to translate the string \"All rights reserved\" in\nyour footer. You could do the following in your layout script:  <p>&copy; 2016 by Examples Ltd. <?= $this->translate('All rights reserved') ?></p>",
            "title": "Translating strings in templates"
        },
        {
            "location": "/i18n/#translating-route-segments",
            "text": "In order to enable route translation, you need to do two things:   Tell the router to use the translation-aware route class.  Optionally, tell it which text domain to use (if not using the default text domain).   To tell the application to use the translation-aware route class, we can update\nour routing configuration. Underneath the top-level  router  key, we'll add the router_class  key:  // In a module.config.php file, or config/autoload/global.php:\n'router' => [\n    'router_class' => Zend\\Mvc\\I18n\\Router\\TranslatorAwareTreeRouteStack::class,\n    'routes' => [\n        /* ... */\n    ],\n],  If you want to use an alternate text domain, you can do so via the translator_text_domain  key, also directly below the  router  key:  // In a module.config.php file, or config/autoload/global.php:\n'router' => [\n    'router_class' => Zend\\Mvc\\I18n\\Router\\TranslatorAwareTreeRouteStack::class,\n    'translator_text_domain' => 'router',\n    'routes' => [\n        /* ... */\n    ],\n],  Now that the router is aware of translations, we can use translatable strings in\nour routes. To do so, surround the string capable of translation with braces\n( {} ). As an example:  'route' => '/{login}',  specifies the word \"login\" as translatable.",
            "title": "Translating route segments"
        },
        {
            "location": "/db-adapter/",
            "text": "Setting up a database adapter\n\n\nzend-db provides a general purpose database abstraction layer. At its heart is\nthe \nAdapter\n, which abstracts common database operations across the variety of\ndrivers we support.\n\n\nIn this guide, we will document how to configure both a single, default adapter\nas well as multiple adapters (which may be useful in architectures that have a\ncluster of read-only replicated servers and a single writable server of record).\n\n\nInstalling zend-db\n\n\nFirst, install zend-db using Composer:\n\n\n$ composer require zendframework/zend-db\n\n\n\nIf you are using \nzend-component-installer\n\n(installed by default with the skeleton application, and optionally for\nExpressive applications), you will be prompted to install the package\nconfiguration.\n\n\n\n\nFor zend-mvc applications, choose either \napplication.config.php\n or\n  \nmodules.config.php\n.\n\n\nFor Expressive applications, choose \nconfig/config.php\n.\n\n\n\n\nIf you are not using the installer, you will need to manually configure add the\ncomponent to your application.\n\n\n\n\n\n\nFor zend-mvc applications, update your list of modules in either\n  \nconfig/application.config.php\n or \nconfig/modules.config.php\n to add an\n  entry for \n'Zend\\Db'\n at the top of the list:\n  \n<?php\n  // In config/modules.config.php\n  return [\n    'Zend\\Db', // <-- This line\n    'Zend\\Form', \n    /* ... */\n  ];\n\n  // OR in config/application.config.php\n  return [\n  /* ... */\n  // Retrieve list of modules used in this application.\n  'modules' => [\n    'Zend\\Db', // <-- This line\n    'Zend\\Form', \n    /* ... */\n  ],\n  /* ... */\n\n\n\n\n\n\nFor Expressive applications, create a new file,\n  \nconfig/autoload/zend-db.global.php\n, with the following contents:\n\n\n\n\n\n\n<?php\nuse Zend\\Db\\ConfigProvider;\n\nreturn (new ConfigProvider())();\n\n\n\nConfiguring the default adapter\n\n\nWithin your service factories, you may retrieve the default adapter from your application container using the\nclass name \nZend\\Db\\Adapter\\AdapterInterface\n:\n\n\nuse Zend\\Db\\Adapter\\AdapterInterface;\n\nfunction ($container) {\n    return new SomeServiceObject($container->get(AdapterInterface::class));\n}\n\n\n\nWhen installed and configured, the factory associated with \nAdapterInterface\n\nwill look for a top-level \ndb\n key in the configuration, and use it to create an\nadapter. As an example, the following would connect to a MySQL database using\nPDO, and the supplied PDO DSN:\n\n\n// In config/autoload/global.php\nreturn [\n    'db' => [\n        'driver' => 'Pdo',\n        'dsn'    => 'mysql:dbname=zftutorial;host=localhost;charset=utf8',\n    ],\n];\n\n\n\nMore information on adapter configuration can be found in the docs for\n\nZend\\Db\\Adapter\n.\n\n\nConfiguring named adapters\n\n\nSometimes you may need multiple adapters. As an example, if you work with a\ncluster of databases, one may allow write operations, while another may be\nread-only.\n\n\nzend-db provides an \nabstract factory\n,\n\nZend\\Db\\Adapter\\AdapterAbstractServiceFactory\n, for this purpose. To use it,\nyou will need to create named configuration keys under \ndb.adapters\n, each with\nconfiguration for an adapter:\n\n\n// In config/autoload/global.php\nreturn [\n    'db' => [\n        'adapters' => [\n            'Application\\Db\\WriteAdapter' => [\n                'driver' => 'Pdo',\n                'dsn'    => 'mysql:dbname=application;host=canonical.example.com;charset=utf8',\n            ],\n            'Application\\Db\\ReadOnlyAdapter' => [\n                'driver' => 'Pdo',\n                'dsn'    => 'mysql:dbname=application;host=replica.example.com;charset=utf8',\n            ],\n        ],\n    ],\n];\n\n\n\nYou retrieve the database adapters using the keys you define, so ensure they are\nunique to your application, and descriptive of their purpose!\n\n\nRetrieving named adapters\n\n\nRetrieve named adapters in your service factories just as you would another\nservice:\n\n\nfunction ($container) {\n    return new SomeServiceObject($container->get('Application\\Db\\ReadOnlyAdapter));\n}\n\n\n\nUsing the AdapterAbstractServiceFactory as a factory\n\n\nDepending on what application container you use, abstract factories may not be\navailable. Alternately, you may want to reduce lookup time when retrieving an\nadapter from the container (abstract factories are consulted last!).\nzend-servicemanager abstract factories work as factories in their own right, and\nare passed the service name as an argument, allowing them to vary their return\nvalue based on requested service name. As such, you can add the following\nservice configuration as well:\n\n\nuse Zend\\Db\\Adapter\\AdapterAbstractServiceFactory;\n\n// If using zend-mvc:\n// In module/YourModule/config/module.config.php\n'service_manager' => [\n    'factories' => [\n        'Application\\Db\\WriteAdapter' => AdapterAbstractServiceFactory::class,\n    ],\n],\n\n// If using Expressive\n'dependencies' => [\n    'factories' => [\n        'Application\\Db\\WriteAdapter' => AdapterAbstractServiceFactory::class,\n    ],\n],",
            "title": "Configurando um Adapter de Bancos de Dados"
        },
        {
            "location": "/db-adapter/#setting-up-a-database-adapter",
            "text": "zend-db provides a general purpose database abstraction layer. At its heart is\nthe  Adapter , which abstracts common database operations across the variety of\ndrivers we support.  In this guide, we will document how to configure both a single, default adapter\nas well as multiple adapters (which may be useful in architectures that have a\ncluster of read-only replicated servers and a single writable server of record).",
            "title": "Setting up a database adapter"
        },
        {
            "location": "/db-adapter/#installing-zend-db",
            "text": "First, install zend-db using Composer:  $ composer require zendframework/zend-db  If you are using  zend-component-installer \n(installed by default with the skeleton application, and optionally for\nExpressive applications), you will be prompted to install the package\nconfiguration.   For zend-mvc applications, choose either  application.config.php  or\n   modules.config.php .  For Expressive applications, choose  config/config.php .   If you are not using the installer, you will need to manually configure add the\ncomponent to your application.    For zend-mvc applications, update your list of modules in either\n   config/application.config.php  or  config/modules.config.php  to add an\n  entry for  'Zend\\Db'  at the top of the list:\n   <?php\n  // In config/modules.config.php\n  return [\n    'Zend\\Db', // <-- This line\n    'Zend\\Form', \n    /* ... */\n  ];\n\n  // OR in config/application.config.php\n  return [\n  /* ... */\n  // Retrieve list of modules used in this application.\n  'modules' => [\n    'Zend\\Db', // <-- This line\n    'Zend\\Form', \n    /* ... */\n  ],\n  /* ... */    For Expressive applications, create a new file,\n   config/autoload/zend-db.global.php , with the following contents:    <?php\nuse Zend\\Db\\ConfigProvider;\n\nreturn (new ConfigProvider())();",
            "title": "Installing zend-db"
        },
        {
            "location": "/db-adapter/#configuring-the-default-adapter",
            "text": "Within your service factories, you may retrieve the default adapter from your application container using the\nclass name  Zend\\Db\\Adapter\\AdapterInterface :  use Zend\\Db\\Adapter\\AdapterInterface;\n\nfunction ($container) {\n    return new SomeServiceObject($container->get(AdapterInterface::class));\n}  When installed and configured, the factory associated with  AdapterInterface \nwill look for a top-level  db  key in the configuration, and use it to create an\nadapter. As an example, the following would connect to a MySQL database using\nPDO, and the supplied PDO DSN:  // In config/autoload/global.php\nreturn [\n    'db' => [\n        'driver' => 'Pdo',\n        'dsn'    => 'mysql:dbname=zftutorial;host=localhost;charset=utf8',\n    ],\n];  More information on adapter configuration can be found in the docs for Zend\\Db\\Adapter .",
            "title": "Configuring the default adapter"
        },
        {
            "location": "/db-adapter/#configuring-named-adapters",
            "text": "Sometimes you may need multiple adapters. As an example, if you work with a\ncluster of databases, one may allow write operations, while another may be\nread-only.  zend-db provides an  abstract factory , Zend\\Db\\Adapter\\AdapterAbstractServiceFactory , for this purpose. To use it,\nyou will need to create named configuration keys under  db.adapters , each with\nconfiguration for an adapter:  // In config/autoload/global.php\nreturn [\n    'db' => [\n        'adapters' => [\n            'Application\\Db\\WriteAdapter' => [\n                'driver' => 'Pdo',\n                'dsn'    => 'mysql:dbname=application;host=canonical.example.com;charset=utf8',\n            ],\n            'Application\\Db\\ReadOnlyAdapter' => [\n                'driver' => 'Pdo',\n                'dsn'    => 'mysql:dbname=application;host=replica.example.com;charset=utf8',\n            ],\n        ],\n    ],\n];  You retrieve the database adapters using the keys you define, so ensure they are\nunique to your application, and descriptive of their purpose!",
            "title": "Configuring named adapters"
        },
        {
            "location": "/db-adapter/#retrieving-named-adapters",
            "text": "Retrieve named adapters in your service factories just as you would another\nservice:  function ($container) {\n    return new SomeServiceObject($container->get('Application\\Db\\ReadOnlyAdapter));\n}",
            "title": "Retrieving named adapters"
        },
        {
            "location": "/db-adapter/#using-the-adapterabstractservicefactory-as-a-factory",
            "text": "Depending on what application container you use, abstract factories may not be\navailable. Alternately, you may want to reduce lookup time when retrieving an\nadapter from the container (abstract factories are consulted last!).\nzend-servicemanager abstract factories work as factories in their own right, and\nare passed the service name as an argument, allowing them to vary their return\nvalue based on requested service name. As such, you can add the following\nservice configuration as well:  use Zend\\Db\\Adapter\\AdapterAbstractServiceFactory;\n\n// If using zend-mvc:\n// In module/YourModule/config/module.config.php\n'service_manager' => [\n    'factories' => [\n        'Application\\Db\\WriteAdapter' => AdapterAbstractServiceFactory::class,\n    ],\n],\n\n// If using Expressive\n'dependencies' => [\n    'factories' => [\n        'Application\\Db\\WriteAdapter' => AdapterAbstractServiceFactory::class,\n    ],\n],",
            "title": "Using the AdapterAbstractServiceFactory as a factory"
        },
        {
            "location": "/event-manager/",
            "text": "Using the EventManager\n\n\nThis tutorial explores the features of zend-eventmanager in-depth.\n\n\nTerminology\n\n\n\n\nAn \nEvent\n is a named action.\n\n\nA \nListener\n is any PHP callback that reacts to an \nevent\n.\n\n\nAn \nEventManager\n \naggregates\n listeners for one or more named events, and\n  \ntriggers\n events.\n\n\n\n\nTypically, an \nevent\n will be modeled as an object, containing metadata\nsurrounding when and how it was triggered, including the event name, what object\ntriggered the event (the \"target\"), and what parameters were provided. Events\nare \nnamed\n, which allows a single \nlistener\n to branch logic based on the\nevent.\n\n\nGetting started\n\n\nThe minimal things necessary to start using events are:\n\n\n\n\nAn \nEventManager\n instance\n\n\nOne or more listeners on one or more events\n\n\nA call to \ntrigger()\n an event\n\n\n\n\nA basic example looks something like this:\n\n\nuse Zend\\EventManager\\EventManager;\n\n$events = new EventManager();\n$events->attach('do', function ($e) {\n    $event = $e->getName();\n    $params = $e->getParams();\n    printf(\n        'Handled event \"%s\", with parameters %s',\n        $event,\n        json_encode($params)\n    );\n});\n\n$params = ['foo' => 'bar', 'baz' => 'bat'];\n$events->trigger('do', null, $params);\n\n\n\nThe above will result in the following:\n\n\nHandled event \"do\", with parameters {\"foo\":\"bar\",\"baz\":\"bat\"}\n\n\n\n\n\nClosures are not required\n\n\nThroughout this tutorial, we use closures as listeners. However, any valid PHP\ncallback can be attached as a listeners: PHP function names, static class\nmethods, object instance methods, functors, or closures. We use closures\nwithin this post for illustration only.\n\n\n\n\nEvent instances\n\n\ntrigger()\n is useful as it will create a \nZend\\EventManager\\Event\n instance for\nyou. You may want to create such an instance manually; for instance, you may\nwant to re-use the same event instance to trigger multiple events, or you may\nwant to use a custom instance.\n\n\nZend\\EventManager\\Event\n, which is the shipped event type and the one used by\nthe \nEventManager\n by default  has a constructor that accepts the same three\narguments passed to \ntrigger()\n:\n\n\nuse Zend\\EventManager\\Event;\n\n$event = new Event('do', null, $params);\n\n\n\nWhen you have an instance available, you will use a different \nEventManager\n\nmethod to trigger the event: \ntriggerEvent()\n. As an example:\n\n\n$events->triggerEvent($event);\n\n\n\nEvent targets\n\n\nIf you were paying attention to the first example, you will have noted the\n\nnull\n second argument both when calling \ntrigger()\n as well as creating an\n\nEvent\n instance. Why is it there?\n\n\nTypically, you will compose an \nEventManager\n within a class, to allow\ntriggering actions within methods. The middle argument to \ntrigger()\n is the\n\"target\", and in the case described, would be the current object instance. This\ngives event listeners access to the calling object, which can often be useful.\n\n\nuse Zend\\EventManager\\EventManager;\nuse Zend\\EventManager\\EventManagerAwareInterface;\nuse Zend\\EventManager\\EventManagerInterface;\n\nclass Example implements EventManagerAwareInterface\n{\n    protected $events;\n\n    public function setEventManager(EventManagerInterface $events)\n    {\n        $events->setIdentifiers([\n            __CLASS__,\n            get_class($this),\n        ]);\n        $this->events = $events;\n    }\n\n    public function getEventManager()\n    {\n        if (! $this->events) {\n            $this->setEventManager(new EventManager());\n        }\n        return $this->events;\n    }\n\n    public function doIt($foo, $baz)\n    {\n        $params = compact('foo', 'baz');\n        $this->getEventManager()->trigger(__FUNCTION__, $this, $params);\n    }\n\n}\n\n$example = new Example();\n\n$example->getEventManager()->attach('doIt', function($e) {\n    $event  = $e->getName();\n    $target = get_class($e->getTarget()); // \"Example\"\n    $params = $e->getParams();\n    printf(\n        'Handled event \"%s\" on target \"%s\", with parameters %s',\n        $event,\n        $target,\n        json_encode($params)\n    );\n});\n\n$example->doIt('bar', 'bat');\n\n\n\nThe above is basically the same as the first example. The main difference is\nthat we're now using that middle argument in order to pass the target, the\ninstance of \nExample\n, on to the listeners. Our listener is now retrieving that\n(\n$e->getTarget()\n), and doing something with it.\n\n\nIf you're reading this critically, you should have a new question: What is the\ncall to \nsetIdentifiers()\n for?\n\n\nShared managers\n\n\nOne aspect that the \nEventManager\n implementation provides is an ability to\ncompose a \nSharedEventManagerInterface\n implementation.\n\n\nZend\\EventManager\\SharedEventManagerInterface\n describes an object that\naggregates listeners for events attached to objects with specific \nidentifiers\n.\nIt does not trigger events itself. Instead, an \nEventManager\n instance that\ncomposes a \nSharedEventManager\n will query the \nSharedEventManager\n for\nlisteners on identifiers it's interested in, and trigger those listeners as\nwell.\n\n\nHow does this work, exactly?\n\n\nConsider the following:\n\n\nuse Zend\\EventManager\\SharedEventManager;\n\n$sharedEvents = new SharedEventManager();\n$sharedEvents->attach('Example', 'do', function ($e) {\n    $event  = $e->getName();\n    $target = get_class($e->getTarget()); // \"Example\"\n    $params = $e->getParams();\n    printf(\n        'Handled event \"%s\" on target \"%s\", with parameters %s',\n        $event,\n        $target,\n        json_encode($params)\n    );\n});\n\n\n\nThis looks almost identical to the previous example; the key difference is that\nthere is an additional argument at the \nstart\n of the list, \n'Example'\n. This\ncode is saying, \"Listen to the 'do' event of the 'Example' target, and, when\nnotified, execute this callback.\"\n\n\nThis is where the \nsetIdentifiers()\n argument of \nEventManager\n comes into play.\nThe method allows passing a string, or an array of strings, defining the name or\nnames of the context or targets the given instance will be interested in. If an\narray is given, then any listener on any of the targets given will be notified.\n\n\nSo, getting back to our example, let's assume that the above shared listener is\nregistered, and also that the \nExample\n class is defined as above. We can then\nexecute the following:\n\n\n$example = new Example();\n$example->getEventManager()->setSharedManager($sharedEvents);\n$example->do('bar', 'bat');\n\n\n\nand expect the following to be \necho\n'd:\n\n\nHandled event \"do\" on target \"Example\", with parameters {\"foo\":\"bar\",\"baz\":\"bat\"}\n\n\n\nNow, let's say we extended \nExample\n as follows:\n\n\nclass SubExample extends Example\n{\n}\n\n\n\nOne interesting aspect of our \nsetEventManager()\n method is that we defined it\nto listen both on \n__CLASS__\n and \nget_class($this)\n. This means that calling\n\ndo()\n on our \nSubExample\n class would also trigger the shared listener! It also\nmeans that, if desired, we could attach to specifically \nSubExample\n, and\nlisteners attached to only the \nExample\n target would not be triggered.\n\n\nFinally, the names used as contexts or targets need not be class names; they can\nbe some name that only has meaning in your application if desired. As an\nexample, you could have a set of classes that respond to \"log\" or \"cache\"\n\u2014 and listeners on these would be notified by any of them.\n\n\n\n\nUse class names as identifiers\n\n\nWe recommend using class names, interface names, and/or abstract class names\nfor identifiers. This makes determining what events are available easier, as\nwell as finding which listeners might be attaching to those events. Interfaces\nmake a particularly good use case, as they allow attaching to a group of\nrelated classes a single operation.\n\n\n\n\nAt any point, if you do not want to notify shared listeners, pass a \nnull\n value\nto \nsetSharedManager()\n:\n\n\n$events->setSharedManager(null);\n\n\n\nand they will be ignored. If at any point, you want to enable them again, pass\nthe \nSharedEventManager\n instance:\n\n\n$events->setSharedManager($sharedEvents);\n\n\n\nWildcards\n\n\nSo far, with both a normal \nEventManager\n instance and with the\n\nSharedEventManager\n instance, we've seen the usage of string event and string\ntarget names to which we want to attach. What if you want to attach a listener\nto multiple events or targets?\n\n\nThe answer is to supply an array of events or targets, or a wildcard, \n*\n.\n\n\nConsider the following examples:\n\n\n// Multiple named events:\n$events->attach(\n    ['foo', 'bar', 'baz'], // events\n    $listener\n);\n\n// All events via wildcard:\n$events->attach(\n    '*', // all events\n    $listener\n);\n\n// Multiple named targets:\n$sharedEvents->attach(\n    ['Foo', 'Bar', 'Baz'], // targets\n    'doSomething', // named event\n    $listener\n);\n\n// All targets via wildcard\n$sharedEvents->attach(\n    '*', // all targets\n    'doSomething', // named event\n    $listener\n);\n\n// Mix and match: multiple named events on multiple named targets:\n$sharedEvents->attach(\n    ['Foo', 'Bar', 'Baz'], // targets\n    ['foo', 'bar', 'baz'], // events\n    $listener\n);\n\n// Mix and match: all events on multiple named targets:\n$sharedEvents->attach(\n    ['Foo', 'Bar', 'Baz'], // targets\n    '*', // events\n    $listener\n);\n\n// Mix and match: multiple named events on all targets:\n$sharedEvents->attach(\n    '*', // targets\n    ['foo', 'bar', 'baz'], // events\n    $listener\n);\n\n// Mix and match: all events on all targets:\n$sharedEvents->attach(\n    '*', // targets\n    '*', // events\n    $listener\n);\n\n\n\nThe ability to specify multiple targets and/or events when attaching can slim\ndown your code immensely.\n\n\n\n\nWildcards can cause problems\n\n\nWildcards, while they simplify listener attachment, can cause some problems.\nFirst, the listener must either be able to accept any incoming event, or it\nmust have logic to branch based on the type of event, the target, or the\nevent parameters. This can quickly become difficult to manage.\n\n\nAdditionally, there are performance considerations. Each time an event is\ntriggered, it loops through all attached listeners; if your listener cannot\nactually handle the event, but was attached as a wildcard listener, you're\nintroducing needless cycles both in aggregating the listeners to trigger, and\nby handling the event itself.\n\n\nWe recommend being specific about what you attach a listener to, in order\nto prevent these problems.\n\n\n\n\nListener aggregates\n\n\nAnother approach to listening to multiple events is via a concept of listener\naggregates, represented by \nZend\\EventManager\\ListenerAggregateInterface\n. Via\nthis approach, a single class can listen to multiple events, attaching one or\nmore instance methods as listeners.\n\n\nThis interface defines two methods, \nattach(EventManagerInterface $events)\n and\n\ndetach(EventManagerInterface $events)\n. You pass an \nEventManager\n instance to\none and/or the other, and then it's up to the implementing class to determine\nwhat to do.\n\n\nThe trait \nZend\\EventManager\\ListenerAggregateTrait\n defines a \n$listeners\n\nproperty and common logic for detaching an aggregate's listeners. We'll use that\nto demonstrate creating an aggregate logging listener:\n\n\nuse Zend\\EventManager\\EventInterface;\nuse Zend\\EventManager\\EventManagerInterface;\nuse Zend\\EventManager\\ListenerAggregateInterface;\nuse Zend\\EventManager\\ListenerAggregateTrait;\nuse Zend\\Log\\Logger;\n\nclass LogEvents implements ListenerAggregateInterface\n{\n    use ListenerAggregateTrait;\n\n    private $log;\n\n    public function __construct(Logger $log)\n    {\n        $this->log = $log;\n    }\n\n    public function attach(EventManagerInterface $events)\n    {\n        $this->listeners[] = $events->attach('do', [$this, 'log']);\n        $this->listeners[] = $events->attach('doSomethingElse', [$this, 'log']);\n    }\n\n    public function log(EventInterface $e)\n    {\n        $event  = $e->getName();\n        $params = $e->getParams();\n        $this->log->info(sprintf('%s: %s', $event, json_encode($params)));\n    }\n}\n\n\n\nAttach the aggregate by passing it an event manager instance:\n\n\n$logListener = new LogEvents($logger);\n$logListener->attach($events);\n\n\n\nAny events the aggregate attaches to will then be notified when triggered.\n\n\nWhy bother? For a couple of reasons:\n\n\n\n\nAggregates allow you to have stateful listeners. The above example\n  demonstrates this via the composition of the logger; another example would be\n  tracking configuration options.\n\n\nAggregates make detaching listeners easier, as you can detach all\n  listeners a class defines at once.\n\n\n\n\nIntrospecting results\n\n\nSometimes you'll want to know what your listeners returned. One thing to\nremember is that you may have multiple listeners on the same event; the\ninterface for results must be consistent regardless of the number of listeners.\n\n\nThe \nEventManager\n implementation by default returns a\n\nZend\\EventManager\\ResponseCollection\n instance. This class extends PHP's\n\nSplStack\n, allowing you to loop through responses in reverse order (since the\nlast one executed is likely the one you're most interested in). It also\nimplements the following methods:\n\n\n\n\nfirst()\n will retrieve the first result received\n\n\nlast()\n will retrieve the last result received\n\n\ncontains($value)\n allows you to test all values to see if a given one was\n  received, and returns a boolean \ntrue\n if found, and \nfalse\n if not.\n\n\nstopped()\n will return a boolean value indicating whether or not a\n  short-circuit occured; more on this in the next section.\n\n\n\n\nTypically, you should not worry about the return values from events, as the\nobject triggering the event shouldn't really have much insight into what\nlisteners are attached. However, sometimes you may want to short-circuit\nexecution if interesting results are obtained. (zend-mvc uses this feature to\ncheck for listeners returning responses, which are then returned immediately.)\n\n\nShort-circuiting listener execution\n\n\nYou may want to short-circuit execution if a particular result is obtained, or if\na listener determines that something is wrong, or that it can return something\nquicker than the target.\n\n\nAs examples, one rationale for adding an \nEventManager\n is as a caching\nmechanism. You can trigger one event early in the method, returning if a cache\nis found, and trigger another event late in the method, seeding the cache.\n\n\nThe \nEventManager\n component offers two ways to handle this, depending on\nwhether you have an event instance already, or want the event manager to create\none for you.\n\n\n\n\ntriggerEventUntil(callable $callback, EventInterface $event)\n\n\ntriggerUntil(callable $callback, $eventName, $target = null, $argv = [])\n\n\n\n\nIn each case, \n$callback\n will be any PHP callable, and will be passed the\nreturn value from the most recently executed listener. The \n$callback\n must then\nreturn a boolean value indicating whether or not to halt execution; boolean\n\ntrue\n indicates execution should halt.\n\n\nYour consuming code can then check to see if execution was short-circuited by\nusing the \nstopped()\n method of the returned \nResponseCollection\n.\n\n\nHere's an example:\n\n\npublic function someExpensiveCall($criteria1, $criteria2)\n{\n    $params  = compact('criteria1', 'criteria2');\n    $results = $this->getEventManager()->triggerUntil(\n        function ($r) {\n            return ($r instanceof SomeResultClass);\n        },\n        __FUNCTION__, \n        $this, \n        $params\n    );\n\n    if ($results->stopped()) {\n        return $results->last();\n    }\n\n    // ... do some work ...\n}\n\n\n\nWith this paradigm, we know that the likely reason of execution halting is due\nto the last result meeting the test callback criteria; as such, we return that\nlast result.\n\n\nThe other way to halt execution is within a listener, acting on the \nEvent\n\nobject it receives. In this case, the listener calls \nstopPropagation(true)\n,\nand the \nEventManager\n will then return without notifying any additional\nlisteners.\n\n\n$events->attach('do', function ($e) {\n    $e->stopPropagation();\n    return new SomeResultClass();\n});\n\n\n\nThis, of course, raises some ambiguity when using the trigger paradigm, as you\ncan no longer be certain that the last result meets the criteria it's searching\non. As such, we recommend that you standardize on one approach or the other.\n\n\nKeeping it in order\n\n\nOn occasion, you may be concerned about the order in which listeners execute. As\nan example, you may want to do any logging early, to ensure that if\nshort-circuiting occurs, you've logged; if implementing a cache, you may want\nto return early if a cache hit is found, and execute late when saving to a\ncache.\n\n\nEach of \nEventManager::attach()\n and \nSharedEventManager::attach()\n accept one\nadditional argument, a \npriority\n. By default, if this is omitted, listeners get\na priority of 1, and are executed in the order in which they are attached.\nHowever, if you provide a priority value, you can influence order of execution.\n\n\n\n\nHigher\n priority values execute \nearlier\n.\n\n\nLower\n (negative) priority values execute \nlater\n.\n\n\n\n\nTo borrow an example from earlier:\n\n\n$priority = 100;\n$events->attach('Example', 'do', function($e) {\n    $event  = $e->getName();\n    $target = get_class($e->getTarget()); // \"Example\"\n    $params = $e->getParams();\n    printf(\n        'Handled event \"%s\" on target \"%s\", with parameters %s',\n        $event,\n        $target,\n        json_encode($params)\n    );\n}, $priority);\n\n\n\nThis would execute with high priority, meaning it would execute early. If we\nchanged \n$priority\n to \n-100\n, it would execute with low priority, executing\nlate.\n\n\nWhile you can't necessarily know all the listeners attached, chances are you can\nmake adequate guesses when necessary in order to set appropriate priority\nvalues.\n\n\nWe advise avoiding setting a priority value unless absolutely necessary.\n\n\nCustom event objects\n\n\nAs noted earlier, an \nEvent\n instance is created when you call either\n\ntrigger()\n or \ntriggerUntil()\n, using the arguments passed to each;\nadditionally, you can manually create an instance. Why would you do so, however?\n\n\nOne thing that looks like a code smell is when you have code like this:\n\n\n$routeMatch = $e->getParam('route-match', false);\nif (! $routeMatch) {\n    // Oh noes! we cannot do our work! whatever shall we do?!?!?!\n}\n\n\n\nThe problems with this are several: \n\n\n\n\nRelying on string keys for event parameters is going to very quickly run into\n  problems \u2014 typos when setting or retrieving the argument can lead to\n  hard to debug situations.\n\n\nSecond, we now have a documentation issue; how do we document expected\n  arguments? how do we document what we're shoving into the event?\n\n\nThird, as a side effect, we can't use IDE or editor hinting support \u2014\n  string keys give these tools nothing to work with.\n\n\n\n\nSimilarly, consider how you might represent a computational result of a method\nwhen triggering an event. As an example:\n\n\n// in the method:\n$params['__RESULT__'] = $computedResult;\n$events->trigger(__FUNCTION__ . '.post', $this, $params);\n\n// in the listener:\n$result = $e->getParam('__RESULT__');\nif (! $result) {\n    // Oh noes! we cannot do our work! whatever shall we do?!?!?!\n}\n\n\n\nSure, that key may be unique, but it suffers from a lot of the same issues.\n\n\nThe solution is to create \ncustom event types\n. As an example, zend-mvc defines\na custom \nMvcEvent\n; this event composes the application instance,\nthe router, the route match, the request and response instances, the view\nmodel, and also a result. We end up with code like this in our listeners:\n\n\n$response = $e->getResponse();\n$result   = $e->getResult();\nif (is_string($result)) {\n    $content = $view->render('layout.phtml', ['content' => $result]);\n    $response->setContent($content);\n}\n\n\n\nAs noted earlier, if using a custom event, you will need to use the\n\ntriggerEvent()\n and/or \ntriggerEventUntil()\n methods instead of the normal\n\ntrigger()\n and \ntriggerUntil()\n.\n\n\nPutting it together: Implementing a caching system\n\n\nIn previous sections, I indicated that short-circuiting is a way to potentially\nimplement a caching solution. Let's create a full example.\n\n\nFirst, let's define a method that could use caching. You'll note that in most of\nthe examples, we use \n__FUNCTION__\n as the event name; this is a good practice,\nas it makes code completion simpler, maps event names directly to the method\ntriggering the event, and typically keeps the event names unique.  However, in\nthe case of a caching example, this might lead to identical events being\ntriggered, as we will be triggering multiple events from the same method. In\nsuch cases, we recommend adding a semantic suffix: \n__FUNCTION__ . 'pre'\n,\n\n__FUNCTION__ . 'post'\n, \n__FUNCTION__ . 'error'\n, etc.  We will use this\nconvention in the upcoming example.\n\n\nAdditionally, you'll notice that the \n$params\n passed to the event are usually\nthe parameters passed to the method. This is because those are often not\nstored in the object, and also to ensure the listeners have the exact same\ncontext as the calling method. In the upcoming example, however, we will be\ntriggering an event using the \nresults of execution\n, and will need a way of\nrepresenting that. We have two possibilities:\n\n\n\n\nUse a \"magic\" key, such as \n__RESULT__\n, and add that to our parameter list.\n\n\nCreate a custom event that allows injecting the result.\n\n\n\n\nThe latter is a more correct approach, as it introduces type safety, and\nprevents typographical errors. Let's create that event now:\n\n\nuse Zend\\EventManager\\Event;\n\nclass ExpensiveCallEvent extends Event\n{\n    private $criteria1;\n    private $criteria2;\n    private $result;\n\n    public function __construct($target, $criteria1, $criteria2)\n    {\n        // Set the default event name:\n        $this->setName('someExpensiveCall');\n        $this->setTarget($target);\n        $this->criteria1 = $criteria1;\n        $this->criteria2 = $criteria2;\n    }\n\n    public function getCriteria1()\n    {\n        return $this->criteria1;\n    }\n\n    public function getCriteria2()\n    {\n        return $this->criteria2;\n    }\n\n    public function setResult(SomeResultClass $result)\n    {\n        $this->result = $result;\n    }\n\n    public function getResult()\n    {\n        return $this->result;\n    }\n}\n\n\n\nWe can now create an instance of this within our class method, and use it to\ntrigger listeners:\n\n\npublic function someExpensiveCall($criteria1, $criteria2)\n{\n    $event = new ExpensiveCallEvent($this, $criteria1, $criteria2);\n    $event->setName(__FUNCTION__ . '.pre');\n    $results = $this->getEventManager()->triggerEventUntil(\n        function ($r) {\n            return ($r instanceof SomeResultClass);\n        },\n        $event\n    );\n\n    if ($results->stopped()) {\n        return $results->last();\n    }\n\n    // ... do some work ...\n\n    $event->setName(__FUNCTION__ . '.post');\n    $event->setResult($calculatedResult);\n    $this->events()->triggerEvent($event);\n    return $calculatedResult;\n}\n\n\n\nBefore triggering either event, we set the event name in the instance to ensure\nthe correct listeners are notified. The first trigger checks to see if we get a\nresult class returned, and, if so, we return it. The second trigger is a\nfire-and-forget; we don't care what is returned, and only want to notify\nlisteners of the result.\n\n\nTo provide some caching listeners, we'll need to attach to each of the\n\nsomeExpensiveCall.pre\n and \nsomeExpensiveCall.post\n events. In the former case,\nif a cache hit is detected, we return it. In the latter, we store the value in\nthe cache.\n\n\nThe following listeners attach to the \n.pre\n and \n.post\n events triggered by the\nabove method. We'll assume \n$cache\n is defined, and is a\n\nzend-cache\n storage adapter. The\nfirst listener will return a result when a cache hit occurs, and the second will\nstore a result in the cache if one is provided.\n\n\n$events->attach('someExpensiveCall.pre', function (ExpensiveCallEvent $e) use ($cache) {\n    $key = md5(json_encode([\n        'criteria1' => $e->getCriteria1(),\n        'criteria2' => $e->getCriteria2(),\n    ]));\n\n    $result = $cache->getItem($key, $success);\n\n    if (! $success) {\n        return;\n    }\n\n    $result = new SomeResultClass($result);\n    $e->setResult($result);\n    return $result;\n});\n\n$events->attach('someExpensiveCall.post', function (ExpensiveCallEvent $e) use ($cache) {\n    $result = $e->getResult();\n    if (! $result instanceof SomeResultClass) {\n        return;\n    }\n\n    $key = md5(json_encode([\n        'criteria1' => $e->getCriteria1(),\n        'criteria2' => $e->getCriteria2(),\n    ]));\n\n    $cache->setItem($key, $result);\n});\n\n\n\n\n\nListenerAggregates allow stateful listeners\n\n\nThe above could have been done within a \nListenerAggregate\n, which would have\nallowed keeping the \n$cache\n instance as a stateful property, instead of\nimporting it into closures.\n\n\n\n\nAnother approach would be to move the body of the method to a listener as well,\nwhich would allow using the priority system in order to implement caching.\n\n\nIf we did that, we'd modify the \nExpensiveCallEvent\n to omit the \n.pre\n suffix\non the default event name, and then implement the class that triggers the event\nas follows:\n\n\npublic function setEventManager(EventManagerInterface $events)\n{\n    $this->events = $events;\n    $events->setIdentifiers([__CLASS__, get_class($this)));\n    $events->attach('someExpensiveCall', [$this, 'doSomeExpensiveCall']);\n}\n\npublic function someExpensiveCall($criteria1, $criteria2)\n{\n    $event = new ExpensiveCallEvent($this, $criteria1, $criteria2);\n    $this->getEventManager()->triggerEventUntil(\n        function ($r) {\n            return $r instanceof SomeResultClass;\n        },\n        $event\n    );\n    return $event->getResult();\n}\n\npublic function doSomeExpensiveCall(ExpensiveCallEvent $e)\n{\n    // ... do some work ...\n    $e->setResult($calculatedResult);\n}\n\n\n\nNote that the \ndoSomeExpensiveCall\n method does not return the result directly;\nthis allows what was originally our \n.post\n listener to trigger. You'll also\nnotice that we return the result from the \nEvent\n instance; this is why the\nfirst listener passes the result into the event, as we can then use it from the\ncalling method!\n\n\nWe will need to change how we attach the listeners; they will now attach\ndirectly to the \nsomeExpensiveCall\n event, without any suffixes; they will also\nnow use priority in order to intercept before and after the default listener\nregistered by the class. The first listener will listen at priority \n100\n to\nensure it executes before the default listener, and the second will listen at\npriority \n-100\n to ensure it triggers after we already have a result:\n\n\n$events->attach('someExpensiveCall', function (ExpensiveCallEvent $e) use ($cache) {\n    // listener for checking against the cache\n}, 100);\n\n$events->attach('someExpensiveCall', function (ExpensiveCallEvent $e) use ($cache) {\n    // listener for injecting into the cache\n}, -100);\n\n\n\nThe workflow ends up being approximately the same, but eliminates the\nconditional logic from the original version, and reduces the number of events to\none.\n\n\nThe alternative, of course, is to have the object compose a cache instance and\nuse it directly. However, the event-based approach\nallows:\n\n\n\n\nRe-using the listeners with multiple events.\n\n\nAttaching multiple listeners to the event; as an example, to implement\n  argument validation, or to add logging.\n\n\n\n\nThe point is that if you design your object with events in mind, you can add\nflexibility and extension points without requiring decoration or class\nextension.\n\n\nConclusion\n\n\nzend-eventmanager is a powerful component. It drives the workflow of zend-mvc,\nand is used in many Zend Framework components to provide hook points for\ndevelopers to manipulate the workflow. It can be a powerful tool in your\ndevelopment toolbox.",
            "title": "Usando o EventManager"
        },
        {
            "location": "/event-manager/#using-the-eventmanager",
            "text": "This tutorial explores the features of zend-eventmanager in-depth.",
            "title": "Using the EventManager"
        },
        {
            "location": "/event-manager/#terminology",
            "text": "An  Event  is a named action.  A  Listener  is any PHP callback that reacts to an  event .  An  EventManager   aggregates  listeners for one or more named events, and\n   triggers  events.   Typically, an  event  will be modeled as an object, containing metadata\nsurrounding when and how it was triggered, including the event name, what object\ntriggered the event (the \"target\"), and what parameters were provided. Events\nare  named , which allows a single  listener  to branch logic based on the\nevent.",
            "title": "Terminology"
        },
        {
            "location": "/event-manager/#getting-started",
            "text": "The minimal things necessary to start using events are:   An  EventManager  instance  One or more listeners on one or more events  A call to  trigger()  an event   A basic example looks something like this:  use Zend\\EventManager\\EventManager;\n\n$events = new EventManager();\n$events->attach('do', function ($e) {\n    $event = $e->getName();\n    $params = $e->getParams();\n    printf(\n        'Handled event \"%s\", with parameters %s',\n        $event,\n        json_encode($params)\n    );\n});\n\n$params = ['foo' => 'bar', 'baz' => 'bat'];\n$events->trigger('do', null, $params);  The above will result in the following:  Handled event \"do\", with parameters {\"foo\":\"bar\",\"baz\":\"bat\"}",
            "title": "Getting started"
        },
        {
            "location": "/event-manager/#closures-are-not-required",
            "text": "Throughout this tutorial, we use closures as listeners. However, any valid PHP\ncallback can be attached as a listeners: PHP function names, static class\nmethods, object instance methods, functors, or closures. We use closures\nwithin this post for illustration only.",
            "title": "Closures are not required"
        },
        {
            "location": "/event-manager/#event-instances",
            "text": "trigger()  is useful as it will create a  Zend\\EventManager\\Event  instance for\nyou. You may want to create such an instance manually; for instance, you may\nwant to re-use the same event instance to trigger multiple events, or you may\nwant to use a custom instance.  Zend\\EventManager\\Event , which is the shipped event type and the one used by\nthe  EventManager  by default  has a constructor that accepts the same three\narguments passed to  trigger() :  use Zend\\EventManager\\Event;\n\n$event = new Event('do', null, $params);  When you have an instance available, you will use a different  EventManager \nmethod to trigger the event:  triggerEvent() . As an example:  $events->triggerEvent($event);",
            "title": "Event instances"
        },
        {
            "location": "/event-manager/#event-targets",
            "text": "If you were paying attention to the first example, you will have noted the null  second argument both when calling  trigger()  as well as creating an Event  instance. Why is it there?  Typically, you will compose an  EventManager  within a class, to allow\ntriggering actions within methods. The middle argument to  trigger()  is the\n\"target\", and in the case described, would be the current object instance. This\ngives event listeners access to the calling object, which can often be useful.  use Zend\\EventManager\\EventManager;\nuse Zend\\EventManager\\EventManagerAwareInterface;\nuse Zend\\EventManager\\EventManagerInterface;\n\nclass Example implements EventManagerAwareInterface\n{\n    protected $events;\n\n    public function setEventManager(EventManagerInterface $events)\n    {\n        $events->setIdentifiers([\n            __CLASS__,\n            get_class($this),\n        ]);\n        $this->events = $events;\n    }\n\n    public function getEventManager()\n    {\n        if (! $this->events) {\n            $this->setEventManager(new EventManager());\n        }\n        return $this->events;\n    }\n\n    public function doIt($foo, $baz)\n    {\n        $params = compact('foo', 'baz');\n        $this->getEventManager()->trigger(__FUNCTION__, $this, $params);\n    }\n\n}\n\n$example = new Example();\n\n$example->getEventManager()->attach('doIt', function($e) {\n    $event  = $e->getName();\n    $target = get_class($e->getTarget()); // \"Example\"\n    $params = $e->getParams();\n    printf(\n        'Handled event \"%s\" on target \"%s\", with parameters %s',\n        $event,\n        $target,\n        json_encode($params)\n    );\n});\n\n$example->doIt('bar', 'bat');  The above is basically the same as the first example. The main difference is\nthat we're now using that middle argument in order to pass the target, the\ninstance of  Example , on to the listeners. Our listener is now retrieving that\n( $e->getTarget() ), and doing something with it.  If you're reading this critically, you should have a new question: What is the\ncall to  setIdentifiers()  for?",
            "title": "Event targets"
        },
        {
            "location": "/event-manager/#shared-managers",
            "text": "One aspect that the  EventManager  implementation provides is an ability to\ncompose a  SharedEventManagerInterface  implementation.  Zend\\EventManager\\SharedEventManagerInterface  describes an object that\naggregates listeners for events attached to objects with specific  identifiers .\nIt does not trigger events itself. Instead, an  EventManager  instance that\ncomposes a  SharedEventManager  will query the  SharedEventManager  for\nlisteners on identifiers it's interested in, and trigger those listeners as\nwell.  How does this work, exactly?  Consider the following:  use Zend\\EventManager\\SharedEventManager;\n\n$sharedEvents = new SharedEventManager();\n$sharedEvents->attach('Example', 'do', function ($e) {\n    $event  = $e->getName();\n    $target = get_class($e->getTarget()); // \"Example\"\n    $params = $e->getParams();\n    printf(\n        'Handled event \"%s\" on target \"%s\", with parameters %s',\n        $event,\n        $target,\n        json_encode($params)\n    );\n});  This looks almost identical to the previous example; the key difference is that\nthere is an additional argument at the  start  of the list,  'Example' . This\ncode is saying, \"Listen to the 'do' event of the 'Example' target, and, when\nnotified, execute this callback.\"  This is where the  setIdentifiers()  argument of  EventManager  comes into play.\nThe method allows passing a string, or an array of strings, defining the name or\nnames of the context or targets the given instance will be interested in. If an\narray is given, then any listener on any of the targets given will be notified.  So, getting back to our example, let's assume that the above shared listener is\nregistered, and also that the  Example  class is defined as above. We can then\nexecute the following:  $example = new Example();\n$example->getEventManager()->setSharedManager($sharedEvents);\n$example->do('bar', 'bat');  and expect the following to be  echo 'd:  Handled event \"do\" on target \"Example\", with parameters {\"foo\":\"bar\",\"baz\":\"bat\"}  Now, let's say we extended  Example  as follows:  class SubExample extends Example\n{\n}  One interesting aspect of our  setEventManager()  method is that we defined it\nto listen both on  __CLASS__  and  get_class($this) . This means that calling do()  on our  SubExample  class would also trigger the shared listener! It also\nmeans that, if desired, we could attach to specifically  SubExample , and\nlisteners attached to only the  Example  target would not be triggered.  Finally, the names used as contexts or targets need not be class names; they can\nbe some name that only has meaning in your application if desired. As an\nexample, you could have a set of classes that respond to \"log\" or \"cache\"\n\u2014 and listeners on these would be notified by any of them.",
            "title": "Shared managers"
        },
        {
            "location": "/event-manager/#use-class-names-as-identifiers",
            "text": "We recommend using class names, interface names, and/or abstract class names\nfor identifiers. This makes determining what events are available easier, as\nwell as finding which listeners might be attaching to those events. Interfaces\nmake a particularly good use case, as they allow attaching to a group of\nrelated classes a single operation.   At any point, if you do not want to notify shared listeners, pass a  null  value\nto  setSharedManager() :  $events->setSharedManager(null);  and they will be ignored. If at any point, you want to enable them again, pass\nthe  SharedEventManager  instance:  $events->setSharedManager($sharedEvents);",
            "title": "Use class names as identifiers"
        },
        {
            "location": "/event-manager/#wildcards",
            "text": "So far, with both a normal  EventManager  instance and with the SharedEventManager  instance, we've seen the usage of string event and string\ntarget names to which we want to attach. What if you want to attach a listener\nto multiple events or targets?  The answer is to supply an array of events or targets, or a wildcard,  * .  Consider the following examples:  // Multiple named events:\n$events->attach(\n    ['foo', 'bar', 'baz'], // events\n    $listener\n);\n\n// All events via wildcard:\n$events->attach(\n    '*', // all events\n    $listener\n);\n\n// Multiple named targets:\n$sharedEvents->attach(\n    ['Foo', 'Bar', 'Baz'], // targets\n    'doSomething', // named event\n    $listener\n);\n\n// All targets via wildcard\n$sharedEvents->attach(\n    '*', // all targets\n    'doSomething', // named event\n    $listener\n);\n\n// Mix and match: multiple named events on multiple named targets:\n$sharedEvents->attach(\n    ['Foo', 'Bar', 'Baz'], // targets\n    ['foo', 'bar', 'baz'], // events\n    $listener\n);\n\n// Mix and match: all events on multiple named targets:\n$sharedEvents->attach(\n    ['Foo', 'Bar', 'Baz'], // targets\n    '*', // events\n    $listener\n);\n\n// Mix and match: multiple named events on all targets:\n$sharedEvents->attach(\n    '*', // targets\n    ['foo', 'bar', 'baz'], // events\n    $listener\n);\n\n// Mix and match: all events on all targets:\n$sharedEvents->attach(\n    '*', // targets\n    '*', // events\n    $listener\n);  The ability to specify multiple targets and/or events when attaching can slim\ndown your code immensely.",
            "title": "Wildcards"
        },
        {
            "location": "/event-manager/#wildcards-can-cause-problems",
            "text": "Wildcards, while they simplify listener attachment, can cause some problems.\nFirst, the listener must either be able to accept any incoming event, or it\nmust have logic to branch based on the type of event, the target, or the\nevent parameters. This can quickly become difficult to manage.  Additionally, there are performance considerations. Each time an event is\ntriggered, it loops through all attached listeners; if your listener cannot\nactually handle the event, but was attached as a wildcard listener, you're\nintroducing needless cycles both in aggregating the listeners to trigger, and\nby handling the event itself.  We recommend being specific about what you attach a listener to, in order\nto prevent these problems.",
            "title": "Wildcards can cause problems"
        },
        {
            "location": "/event-manager/#listener-aggregates",
            "text": "Another approach to listening to multiple events is via a concept of listener\naggregates, represented by  Zend\\EventManager\\ListenerAggregateInterface . Via\nthis approach, a single class can listen to multiple events, attaching one or\nmore instance methods as listeners.  This interface defines two methods,  attach(EventManagerInterface $events)  and detach(EventManagerInterface $events) . You pass an  EventManager  instance to\none and/or the other, and then it's up to the implementing class to determine\nwhat to do.  The trait  Zend\\EventManager\\ListenerAggregateTrait  defines a  $listeners \nproperty and common logic for detaching an aggregate's listeners. We'll use that\nto demonstrate creating an aggregate logging listener:  use Zend\\EventManager\\EventInterface;\nuse Zend\\EventManager\\EventManagerInterface;\nuse Zend\\EventManager\\ListenerAggregateInterface;\nuse Zend\\EventManager\\ListenerAggregateTrait;\nuse Zend\\Log\\Logger;\n\nclass LogEvents implements ListenerAggregateInterface\n{\n    use ListenerAggregateTrait;\n\n    private $log;\n\n    public function __construct(Logger $log)\n    {\n        $this->log = $log;\n    }\n\n    public function attach(EventManagerInterface $events)\n    {\n        $this->listeners[] = $events->attach('do', [$this, 'log']);\n        $this->listeners[] = $events->attach('doSomethingElse', [$this, 'log']);\n    }\n\n    public function log(EventInterface $e)\n    {\n        $event  = $e->getName();\n        $params = $e->getParams();\n        $this->log->info(sprintf('%s: %s', $event, json_encode($params)));\n    }\n}  Attach the aggregate by passing it an event manager instance:  $logListener = new LogEvents($logger);\n$logListener->attach($events);  Any events the aggregate attaches to will then be notified when triggered.  Why bother? For a couple of reasons:   Aggregates allow you to have stateful listeners. The above example\n  demonstrates this via the composition of the logger; another example would be\n  tracking configuration options.  Aggregates make detaching listeners easier, as you can detach all\n  listeners a class defines at once.",
            "title": "Listener aggregates"
        },
        {
            "location": "/event-manager/#introspecting-results",
            "text": "Sometimes you'll want to know what your listeners returned. One thing to\nremember is that you may have multiple listeners on the same event; the\ninterface for results must be consistent regardless of the number of listeners.  The  EventManager  implementation by default returns a Zend\\EventManager\\ResponseCollection  instance. This class extends PHP's SplStack , allowing you to loop through responses in reverse order (since the\nlast one executed is likely the one you're most interested in). It also\nimplements the following methods:   first()  will retrieve the first result received  last()  will retrieve the last result received  contains($value)  allows you to test all values to see if a given one was\n  received, and returns a boolean  true  if found, and  false  if not.  stopped()  will return a boolean value indicating whether or not a\n  short-circuit occured; more on this in the next section.   Typically, you should not worry about the return values from events, as the\nobject triggering the event shouldn't really have much insight into what\nlisteners are attached. However, sometimes you may want to short-circuit\nexecution if interesting results are obtained. (zend-mvc uses this feature to\ncheck for listeners returning responses, which are then returned immediately.)",
            "title": "Introspecting results"
        },
        {
            "location": "/event-manager/#short-circuiting-listener-execution",
            "text": "You may want to short-circuit execution if a particular result is obtained, or if\na listener determines that something is wrong, or that it can return something\nquicker than the target.  As examples, one rationale for adding an  EventManager  is as a caching\nmechanism. You can trigger one event early in the method, returning if a cache\nis found, and trigger another event late in the method, seeding the cache.  The  EventManager  component offers two ways to handle this, depending on\nwhether you have an event instance already, or want the event manager to create\none for you.   triggerEventUntil(callable $callback, EventInterface $event)  triggerUntil(callable $callback, $eventName, $target = null, $argv = [])   In each case,  $callback  will be any PHP callable, and will be passed the\nreturn value from the most recently executed listener. The  $callback  must then\nreturn a boolean value indicating whether or not to halt execution; boolean true  indicates execution should halt.  Your consuming code can then check to see if execution was short-circuited by\nusing the  stopped()  method of the returned  ResponseCollection .  Here's an example:  public function someExpensiveCall($criteria1, $criteria2)\n{\n    $params  = compact('criteria1', 'criteria2');\n    $results = $this->getEventManager()->triggerUntil(\n        function ($r) {\n            return ($r instanceof SomeResultClass);\n        },\n        __FUNCTION__, \n        $this, \n        $params\n    );\n\n    if ($results->stopped()) {\n        return $results->last();\n    }\n\n    // ... do some work ...\n}  With this paradigm, we know that the likely reason of execution halting is due\nto the last result meeting the test callback criteria; as such, we return that\nlast result.  The other way to halt execution is within a listener, acting on the  Event \nobject it receives. In this case, the listener calls  stopPropagation(true) ,\nand the  EventManager  will then return without notifying any additional\nlisteners.  $events->attach('do', function ($e) {\n    $e->stopPropagation();\n    return new SomeResultClass();\n});  This, of course, raises some ambiguity when using the trigger paradigm, as you\ncan no longer be certain that the last result meets the criteria it's searching\non. As such, we recommend that you standardize on one approach or the other.",
            "title": "Short-circuiting listener execution"
        },
        {
            "location": "/event-manager/#keeping-it-in-order",
            "text": "On occasion, you may be concerned about the order in which listeners execute. As\nan example, you may want to do any logging early, to ensure that if\nshort-circuiting occurs, you've logged; if implementing a cache, you may want\nto return early if a cache hit is found, and execute late when saving to a\ncache.  Each of  EventManager::attach()  and  SharedEventManager::attach()  accept one\nadditional argument, a  priority . By default, if this is omitted, listeners get\na priority of 1, and are executed in the order in which they are attached.\nHowever, if you provide a priority value, you can influence order of execution.   Higher  priority values execute  earlier .  Lower  (negative) priority values execute  later .   To borrow an example from earlier:  $priority = 100;\n$events->attach('Example', 'do', function($e) {\n    $event  = $e->getName();\n    $target = get_class($e->getTarget()); // \"Example\"\n    $params = $e->getParams();\n    printf(\n        'Handled event \"%s\" on target \"%s\", with parameters %s',\n        $event,\n        $target,\n        json_encode($params)\n    );\n}, $priority);  This would execute with high priority, meaning it would execute early. If we\nchanged  $priority  to  -100 , it would execute with low priority, executing\nlate.  While you can't necessarily know all the listeners attached, chances are you can\nmake adequate guesses when necessary in order to set appropriate priority\nvalues.  We advise avoiding setting a priority value unless absolutely necessary.",
            "title": "Keeping it in order"
        },
        {
            "location": "/event-manager/#custom-event-objects",
            "text": "As noted earlier, an  Event  instance is created when you call either trigger()  or  triggerUntil() , using the arguments passed to each;\nadditionally, you can manually create an instance. Why would you do so, however?  One thing that looks like a code smell is when you have code like this:  $routeMatch = $e->getParam('route-match', false);\nif (! $routeMatch) {\n    // Oh noes! we cannot do our work! whatever shall we do?!?!?!\n}  The problems with this are several:    Relying on string keys for event parameters is going to very quickly run into\n  problems \u2014 typos when setting or retrieving the argument can lead to\n  hard to debug situations.  Second, we now have a documentation issue; how do we document expected\n  arguments? how do we document what we're shoving into the event?  Third, as a side effect, we can't use IDE or editor hinting support \u2014\n  string keys give these tools nothing to work with.   Similarly, consider how you might represent a computational result of a method\nwhen triggering an event. As an example:  // in the method:\n$params['__RESULT__'] = $computedResult;\n$events->trigger(__FUNCTION__ . '.post', $this, $params);\n\n// in the listener:\n$result = $e->getParam('__RESULT__');\nif (! $result) {\n    // Oh noes! we cannot do our work! whatever shall we do?!?!?!\n}  Sure, that key may be unique, but it suffers from a lot of the same issues.  The solution is to create  custom event types . As an example, zend-mvc defines\na custom  MvcEvent ; this event composes the application instance,\nthe router, the route match, the request and response instances, the view\nmodel, and also a result. We end up with code like this in our listeners:  $response = $e->getResponse();\n$result   = $e->getResult();\nif (is_string($result)) {\n    $content = $view->render('layout.phtml', ['content' => $result]);\n    $response->setContent($content);\n}  As noted earlier, if using a custom event, you will need to use the triggerEvent()  and/or  triggerEventUntil()  methods instead of the normal trigger()  and  triggerUntil() .",
            "title": "Custom event objects"
        },
        {
            "location": "/event-manager/#putting-it-together-implementing-a-caching-system",
            "text": "In previous sections, I indicated that short-circuiting is a way to potentially\nimplement a caching solution. Let's create a full example.  First, let's define a method that could use caching. You'll note that in most of\nthe examples, we use  __FUNCTION__  as the event name; this is a good practice,\nas it makes code completion simpler, maps event names directly to the method\ntriggering the event, and typically keeps the event names unique.  However, in\nthe case of a caching example, this might lead to identical events being\ntriggered, as we will be triggering multiple events from the same method. In\nsuch cases, we recommend adding a semantic suffix:  __FUNCTION__ . 'pre' , __FUNCTION__ . 'post' ,  __FUNCTION__ . 'error' , etc.  We will use this\nconvention in the upcoming example.  Additionally, you'll notice that the  $params  passed to the event are usually\nthe parameters passed to the method. This is because those are often not\nstored in the object, and also to ensure the listeners have the exact same\ncontext as the calling method. In the upcoming example, however, we will be\ntriggering an event using the  results of execution , and will need a way of\nrepresenting that. We have two possibilities:   Use a \"magic\" key, such as  __RESULT__ , and add that to our parameter list.  Create a custom event that allows injecting the result.   The latter is a more correct approach, as it introduces type safety, and\nprevents typographical errors. Let's create that event now:  use Zend\\EventManager\\Event;\n\nclass ExpensiveCallEvent extends Event\n{\n    private $criteria1;\n    private $criteria2;\n    private $result;\n\n    public function __construct($target, $criteria1, $criteria2)\n    {\n        // Set the default event name:\n        $this->setName('someExpensiveCall');\n        $this->setTarget($target);\n        $this->criteria1 = $criteria1;\n        $this->criteria2 = $criteria2;\n    }\n\n    public function getCriteria1()\n    {\n        return $this->criteria1;\n    }\n\n    public function getCriteria2()\n    {\n        return $this->criteria2;\n    }\n\n    public function setResult(SomeResultClass $result)\n    {\n        $this->result = $result;\n    }\n\n    public function getResult()\n    {\n        return $this->result;\n    }\n}  We can now create an instance of this within our class method, and use it to\ntrigger listeners:  public function someExpensiveCall($criteria1, $criteria2)\n{\n    $event = new ExpensiveCallEvent($this, $criteria1, $criteria2);\n    $event->setName(__FUNCTION__ . '.pre');\n    $results = $this->getEventManager()->triggerEventUntil(\n        function ($r) {\n            return ($r instanceof SomeResultClass);\n        },\n        $event\n    );\n\n    if ($results->stopped()) {\n        return $results->last();\n    }\n\n    // ... do some work ...\n\n    $event->setName(__FUNCTION__ . '.post');\n    $event->setResult($calculatedResult);\n    $this->events()->triggerEvent($event);\n    return $calculatedResult;\n}  Before triggering either event, we set the event name in the instance to ensure\nthe correct listeners are notified. The first trigger checks to see if we get a\nresult class returned, and, if so, we return it. The second trigger is a\nfire-and-forget; we don't care what is returned, and only want to notify\nlisteners of the result.  To provide some caching listeners, we'll need to attach to each of the someExpensiveCall.pre  and  someExpensiveCall.post  events. In the former case,\nif a cache hit is detected, we return it. In the latter, we store the value in\nthe cache.  The following listeners attach to the  .pre  and  .post  events triggered by the\nabove method. We'll assume  $cache  is defined, and is a zend-cache  storage adapter. The\nfirst listener will return a result when a cache hit occurs, and the second will\nstore a result in the cache if one is provided.  $events->attach('someExpensiveCall.pre', function (ExpensiveCallEvent $e) use ($cache) {\n    $key = md5(json_encode([\n        'criteria1' => $e->getCriteria1(),\n        'criteria2' => $e->getCriteria2(),\n    ]));\n\n    $result = $cache->getItem($key, $success);\n\n    if (! $success) {\n        return;\n    }\n\n    $result = new SomeResultClass($result);\n    $e->setResult($result);\n    return $result;\n});\n\n$events->attach('someExpensiveCall.post', function (ExpensiveCallEvent $e) use ($cache) {\n    $result = $e->getResult();\n    if (! $result instanceof SomeResultClass) {\n        return;\n    }\n\n    $key = md5(json_encode([\n        'criteria1' => $e->getCriteria1(),\n        'criteria2' => $e->getCriteria2(),\n    ]));\n\n    $cache->setItem($key, $result);\n});",
            "title": "Putting it together: Implementing a caching system"
        },
        {
            "location": "/event-manager/#listeneraggregates-allow-stateful-listeners",
            "text": "The above could have been done within a  ListenerAggregate , which would have\nallowed keeping the  $cache  instance as a stateful property, instead of\nimporting it into closures.   Another approach would be to move the body of the method to a listener as well,\nwhich would allow using the priority system in order to implement caching.  If we did that, we'd modify the  ExpensiveCallEvent  to omit the  .pre  suffix\non the default event name, and then implement the class that triggers the event\nas follows:  public function setEventManager(EventManagerInterface $events)\n{\n    $this->events = $events;\n    $events->setIdentifiers([__CLASS__, get_class($this)));\n    $events->attach('someExpensiveCall', [$this, 'doSomeExpensiveCall']);\n}\n\npublic function someExpensiveCall($criteria1, $criteria2)\n{\n    $event = new ExpensiveCallEvent($this, $criteria1, $criteria2);\n    $this->getEventManager()->triggerEventUntil(\n        function ($r) {\n            return $r instanceof SomeResultClass;\n        },\n        $event\n    );\n    return $event->getResult();\n}\n\npublic function doSomeExpensiveCall(ExpensiveCallEvent $e)\n{\n    // ... do some work ...\n    $e->setResult($calculatedResult);\n}  Note that the  doSomeExpensiveCall  method does not return the result directly;\nthis allows what was originally our  .post  listener to trigger. You'll also\nnotice that we return the result from the  Event  instance; this is why the\nfirst listener passes the result into the event, as we can then use it from the\ncalling method!  We will need to change how we attach the listeners; they will now attach\ndirectly to the  someExpensiveCall  event, without any suffixes; they will also\nnow use priority in order to intercept before and after the default listener\nregistered by the class. The first listener will listen at priority  100  to\nensure it executes before the default listener, and the second will listen at\npriority  -100  to ensure it triggers after we already have a result:  $events->attach('someExpensiveCall', function (ExpensiveCallEvent $e) use ($cache) {\n    // listener for checking against the cache\n}, 100);\n\n$events->attach('someExpensiveCall', function (ExpensiveCallEvent $e) use ($cache) {\n    // listener for injecting into the cache\n}, -100);  The workflow ends up being approximately the same, but eliminates the\nconditional logic from the original version, and reduces the number of events to\none.  The alternative, of course, is to have the object compose a cache instance and\nuse it directly. However, the event-based approach\nallows:   Re-using the listeners with multiple events.  Attaching multiple listeners to the event; as an example, to implement\n  argument validation, or to add logging.   The point is that if you design your object with events in mind, you can add\nflexibility and extension points without requiring decoration or class\nextension.",
            "title": "ListenerAggregates allow stateful listeners"
        },
        {
            "location": "/event-manager/#conclusion",
            "text": "zend-eventmanager is a powerful component. It drives the workflow of zend-mvc,\nand is used in many Zend Framework components to provide hook points for\ndevelopers to manipulate the workflow. It can be a powerful tool in your\ndevelopment toolbox.",
            "title": "Conclusion"
        },
        {
            "location": "/migration/to-v3/overview/",
            "text": "Migration from Zend Framework v2 to v3\n\n\nZend Framework v2 to v3 has been intended as an incremental upgrade. We have\neven made efforts in the past year to provide forwards compatibility features in\nv2 versions of components, to allow users to prepare their code for upgrade.\n\n\nThis is not a comprehensive migration guide, however. While we know the majority\nof the areas where breakage can and will occur, we also know that only when\ndevelopers are actually updating will we see the full situation. As such, treat\nthis as a work in progress, and please feel free to propose updates or changes\nvia \nissues\n or\n\npull requests\n so we can\nimprove!",
            "title": "Vis\u00e3o Geral"
        },
        {
            "location": "/migration/to-v3/overview/#migration-from-zend-framework-v2-to-v3",
            "text": "Zend Framework v2 to v3 has been intended as an incremental upgrade. We have\neven made efforts in the past year to provide forwards compatibility features in\nv2 versions of components, to allow users to prepare their code for upgrade.  This is not a comprehensive migration guide, however. While we know the majority\nof the areas where breakage can and will occur, we also know that only when\ndevelopers are actually updating will we see the full situation. As such, treat\nthis as a work in progress, and please feel free to propose updates or changes\nvia  issues  or pull requests  so we can\nimprove!",
            "title": "Migration from Zend Framework v2 to v3"
        },
        {
            "location": "/migration/to-v3/components/",
            "text": "Component migration documentation\n\n\nThe following is a list of migration documents for components we ship.\n\n\n\n\nzend-code\n\n\nzend-eventmanager\n\n\nzend-hydrator\n\n\nzend-json\n\n\nzend-math\n\n\nzend-mvc\n\n\nzend-mvc-console\n\n  (for migrating MVC-based console functionality)\n\n\nzend-mvc-i18n\n\n  (for migrating MVC-based console functionality)\n\n\nzend-router\n\n  (for migrating MVC-based router functionality)\n\n\nzend-servicemanager\n\n\nzend-servicemanager-di\n\n  (for migrating zend-servicemanager <-> zend-di integration)\n\n\nzend-stdlib",
            "title": "Componentes"
        },
        {
            "location": "/migration/to-v3/components/#component-migration-documentation",
            "text": "The following is a list of migration documents for components we ship.   zend-code  zend-eventmanager  zend-hydrator  zend-json  zend-math  zend-mvc  zend-mvc-console \n  (for migrating MVC-based console functionality)  zend-mvc-i18n \n  (for migrating MVC-based console functionality)  zend-router \n  (for migrating MVC-based router functionality)  zend-servicemanager  zend-servicemanager-di \n  (for migrating zend-servicemanager <-> zend-di integration)  zend-stdlib",
            "title": "Component migration documentation"
        },
        {
            "location": "/migration/to-v3/application/",
            "text": "Upgrading Applications\n\n\nIf you have an existing Zend Framework v2 application, and want to update it to\nthe latest versions, you will have some special considerations.\n\n\nUpgrading Zend Framework\n\n\nSince the 2.5 release, the zendframework package has been essentially a\n\"metapackage\", defining no code, and only dependencies on the various component\npackages. This means that when you install \nzendframework/zendframework\n, you\nget the full set of components, at the latest 2.* versions.\n\n\nWith the release of version 3, we recommend:\n\n\n\n\nRemoving the zendframework/zendframework package.\n\n\nInstalling the zendframework/zend-component-installer package.\n\n\nInstalling the zendframework/zend-mvc package.\n\n\nInstalling each ZF component package you actually use in your application.\n\n\n\n\nThe process would look like this:\n\n\n$ composer remove zendframework/zendframework\n$ composer require zendframework/zend-component-installer\n$ composer require zendframework/zend-mvc\n# Repeat as necessary for components you use if not already installed\n\n\n\nWhen you install zend-mvc, it will prompt you to add configuration for\ncomponents; choose either \napplication.config.php\n or \nmodules.config.php\n, and\nre-use your selection for all other packages. This step ensures that the various\ncomponents installed, and any news ones you add later, are configured in your\napplication correctly.\n\n\nThis approach will ensure you are only installing what you actually need. As an\nexample, if you are not using zend-barcode, or zend-permissions-acl, or\nzend-mail, there's no reason to install them.\n\n\n\n\nKeeping the zendframework package\n\n\nIf you want to upgrade quickly, and cannot easily determine which components you\nuse in your application, you can upgrade your zendframework requirement. When\nyou do, you should also install the zend-component-installer, to ensure that\ncomponent configuration is properly injected in your application.\n\n\n$ composer require zendframework/zend-component-installer \"zendframework/zendframework:^3.0\"\n\n\n\nDuring installation, it will prompt you to add configuration for\ncomponents; choose either \napplication.config.php\n or \nmodules.config.php\n, and\nre-use your selection for all other packages. This step ensures that the various\ncomponents installed, and any news ones you add later, are configured in your\napplication correctly.\n\n\nThis will upgrade you to the latest releases of all Zend Framework components at\nonce; it will also install new components developed as part of the version 3\ninitiative.\n\n\nWe still recommend reducing your dependencies at a later date, however.\n\n\n\n\nIntegration packages\n\n\nDuring the Zend Framework 3 initiative, one goal was to reduce the number of\ndependencies for each package. This affected the MVC in particular, as a number\nof features were optional or presented deep integrations between the MVC and\nother components. These include the following:\n\n\nConsole tooling\n\n\nIf you were using the MVC console tooling, and are doing a partial update per\nthe recommendations, you will need to install\n\nzend-mvc-console\n.\n\n\nForms integration\n\n\nIf you were using the forms in your MVC application, and are doing a partial\nupdate per the recommendations, you will need to install\n\nzend-mvc-form\n.\n\n\ni18n integration\n\n\nIf you were using i18n features in your MVC application, and are doing a partial\nupdate per the recommendations, you will need to install\n\nzend-mvc-i18n\n.\n\n\nPlugins\n\n\nIf you were using any of the \nprg()\n, \nfileprg()\n, \nidentity()\n, or\n\nflashMessenger()\n MVC controller plugins, and are doing a partial update per\nthe recommendations, you will need to install\n\nzend-mvc-plugins\n.\n\n\nzend-di integration\n\n\nIf you were using the zend-servicemanager <-> zend-di integration within\nyour application, you will need to install\n\nzend-servicemanager-di\n.\n\n\nAutoloading\n\n\nIf you are doing a partial upgrade per the above recommendations (vs. upgrading\nthe full zendframework package), one change is that zend-loader is no longer\ninstalled by default, nor recommended. Instead, we recommend using\n\nComposer for autoloading\n.\n\n\nAs such, you will need to setup autoloading rules for each module specific to\nyour application.\n\n\nAs an example, if you are still defining the default \nApplication\n module, you\ncan add autoloading for it as follows in your project's \ncomposer.json\n:\n\n\n\"autoload\": {\n    \"psr-4\": {\n        \"Application\\\\\": \"module/Application/src/Application/\"\n    },\n    \"files\":  [\n        \"module/Application/Module.php\"\n    ]\n}\n\n\n\nThe above creates a \nPSR-4\n autoloading rule\nfor the \nApplication\n module, telling it to look in the\n\nmodule/Application/src/Application/\n directory. Since the \nApplication\\Module\n\nclass is defined at the module root, we specify it in the \nfiles\n configuration.\n\n\nTo improve on this, and simplify autoloading, we recommend adopting a complete\nPSR-4 directory structure for your module class files. As an example, to change\nthe existing \nApplication\n module to PSR-4, you can do the following:\n\n\n$ cd module/Application\n$ mv src temp\n$ mv temp/Application src\n$ rm -Rf ./temp\n$ mv Module.php src/\n\n\n\nUpdate your \nModule.php\n file to do the following:\n\n\n\n\nRemove the \ngetAutoloaderConfig()\n method entirely, if defined.\n\n\nUpdate the \ngetConfig()\n method from \ninclude __DIR__ .\n  '/config/module.config.php\n to \ninclude _DIR__ .\n  '/../config/module.config.php\n.\n\n\n\n\nYou can then update the \nautoload\n configuration to:\n\n\n\"autoload\": {\n    \"psr-4\": {\n        \"Application\\\\\": \"module/Application/src/\"\n    }\n}\n\n\n\nAfterwards, run the following to update the generated autoloader:\n\n\n$ composer dump-autoload\n\n\n\nThe updated application skeleton already takes this approach.\n\n\nBootstrap\n\n\nBecause version 3 requires usage of Composer for autoloading, you can simplify\nyour application bootstrap.\n\n\nFirst, if you were using an \ninit_autoloader.php\n file, you can now remove it.\n\n\nSecond, update your \npublic/index.php\n to read as follows:\n\n\n<?php\n\nuse Zend\\Mvc\\Application;\n\n/**\n * This makes our life easier when dealing with paths. Everything is relative\n * to the application root now.\n */\nchdir(dirname(__DIR__));\n\n// Decline static file requests back to the PHP built-in webserver\nif (php_sapi_name() === 'cli-server') {\n    $path = realpath(__DIR__ . parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH));\n    if (__FILE__ !== $path && is_file($path)) {\n        return false;\n    }\n    unset($path);\n}\n\n// Composer autoloading\ninclude __DIR__ . '/../vendor/autoload.php';\n\nif (! class_exists(Application::class)) {\n    throw new RuntimeException(\n        \"Unable to load application.\\n\"\n        . \"- Type `composer install` if you are developing locally.\\n\"\n    );\n}\n\n// Run the application!\nApplication::init(require __DIR__ . '/../config/application.config.php')->run();\n\n\n\nScripts\n\n\nThe skeleton application for version 2 shipped three scripts with it:\n\n\n\n\nbin/classmap_generator.php\n\n\nbin/pluginmap_generator.php\n\n\nbin/templatemap_generator.php\n\n\n\n\nIf you are upgrading an existing application, these will still be present.\nHowever, if you are starting a new application, and used these previously, they\nare no longer present.\n\n\n\n\nclassmap_generator.php\n was removed as it's unnecessary when using Composer\n  for autoloading. When preparing a production installation, run \ncomposer\n  dump-autoload -o\n and/or \ncomposer dump-autoload -a\n; both will generate\n  optimized class map autoloading rules for you.\n\n\npluginmap_generator.php\n was essentially obsolete due to the presence of\n  \nclassmap_generator.php\n anyways.\n\n\ntemplatemap_generator.php\n was moved to the zend-view component with the\n  2.8.0 release of that component, and is now available via\n  \n./vendor/bin/templatemap_generator.php\n. Additionally, its usage signature\n  has changed; please use the \n--help\n or \n-h\n switches on first invocation to\n  discover how to use it.\n\n\n\n\nDevelopment mode\n\n\nVersion 3 of the skeleton application adds a requirement on\n\nzfcampus/zf-development-mode\n,\nwhich provides a way to store common development-specific settings in your\nrepository and then selectively enable/disable them during development.\n\n\nIf you are upgrading from an existing application, you can install this feature:\n\n\n$ composer require zfcampus/zf-development-mode\n\n\n\nPlease refer to the \npackage documentation\n\nfor details on how to setup your application configuration to make use of this\nfeature.",
            "title": "Aplica\u00e7\u00f5es"
        },
        {
            "location": "/migration/to-v3/application/#upgrading-applications",
            "text": "If you have an existing Zend Framework v2 application, and want to update it to\nthe latest versions, you will have some special considerations.",
            "title": "Upgrading Applications"
        },
        {
            "location": "/migration/to-v3/application/#upgrading-zend-framework",
            "text": "Since the 2.5 release, the zendframework package has been essentially a\n\"metapackage\", defining no code, and only dependencies on the various component\npackages. This means that when you install  zendframework/zendframework , you\nget the full set of components, at the latest 2.* versions.  With the release of version 3, we recommend:   Removing the zendframework/zendframework package.  Installing the zendframework/zend-component-installer package.  Installing the zendframework/zend-mvc package.  Installing each ZF component package you actually use in your application.   The process would look like this:  $ composer remove zendframework/zendframework\n$ composer require zendframework/zend-component-installer\n$ composer require zendframework/zend-mvc\n# Repeat as necessary for components you use if not already installed  When you install zend-mvc, it will prompt you to add configuration for\ncomponents; choose either  application.config.php  or  modules.config.php , and\nre-use your selection for all other packages. This step ensures that the various\ncomponents installed, and any news ones you add later, are configured in your\napplication correctly.  This approach will ensure you are only installing what you actually need. As an\nexample, if you are not using zend-barcode, or zend-permissions-acl, or\nzend-mail, there's no reason to install them.",
            "title": "Upgrading Zend Framework"
        },
        {
            "location": "/migration/to-v3/application/#keeping-the-zendframework-package",
            "text": "If you want to upgrade quickly, and cannot easily determine which components you\nuse in your application, you can upgrade your zendframework requirement. When\nyou do, you should also install the zend-component-installer, to ensure that\ncomponent configuration is properly injected in your application.  $ composer require zendframework/zend-component-installer \"zendframework/zendframework:^3.0\"  During installation, it will prompt you to add configuration for\ncomponents; choose either  application.config.php  or  modules.config.php , and\nre-use your selection for all other packages. This step ensures that the various\ncomponents installed, and any news ones you add later, are configured in your\napplication correctly.  This will upgrade you to the latest releases of all Zend Framework components at\nonce; it will also install new components developed as part of the version 3\ninitiative.  We still recommend reducing your dependencies at a later date, however.",
            "title": "Keeping the zendframework package"
        },
        {
            "location": "/migration/to-v3/application/#integration-packages",
            "text": "During the Zend Framework 3 initiative, one goal was to reduce the number of\ndependencies for each package. This affected the MVC in particular, as a number\nof features were optional or presented deep integrations between the MVC and\nother components. These include the following:",
            "title": "Integration packages"
        },
        {
            "location": "/migration/to-v3/application/#console-tooling",
            "text": "If you were using the MVC console tooling, and are doing a partial update per\nthe recommendations, you will need to install zend-mvc-console .",
            "title": "Console tooling"
        },
        {
            "location": "/migration/to-v3/application/#forms-integration",
            "text": "If you were using the forms in your MVC application, and are doing a partial\nupdate per the recommendations, you will need to install zend-mvc-form .",
            "title": "Forms integration"
        },
        {
            "location": "/migration/to-v3/application/#i18n-integration",
            "text": "If you were using i18n features in your MVC application, and are doing a partial\nupdate per the recommendations, you will need to install zend-mvc-i18n .",
            "title": "i18n integration"
        },
        {
            "location": "/migration/to-v3/application/#plugins",
            "text": "If you were using any of the  prg() ,  fileprg() ,  identity() , or flashMessenger()  MVC controller plugins, and are doing a partial update per\nthe recommendations, you will need to install zend-mvc-plugins .",
            "title": "Plugins"
        },
        {
            "location": "/migration/to-v3/application/#zend-di-integration",
            "text": "If you were using the zend-servicemanager <-> zend-di integration within\nyour application, you will need to install zend-servicemanager-di .",
            "title": "zend-di integration"
        },
        {
            "location": "/migration/to-v3/application/#autoloading",
            "text": "If you are doing a partial upgrade per the above recommendations (vs. upgrading\nthe full zendframework package), one change is that zend-loader is no longer\ninstalled by default, nor recommended. Instead, we recommend using Composer for autoloading .  As such, you will need to setup autoloading rules for each module specific to\nyour application.  As an example, if you are still defining the default  Application  module, you\ncan add autoloading for it as follows in your project's  composer.json :  \"autoload\": {\n    \"psr-4\": {\n        \"Application\\\\\": \"module/Application/src/Application/\"\n    },\n    \"files\":  [\n        \"module/Application/Module.php\"\n    ]\n}  The above creates a  PSR-4  autoloading rule\nfor the  Application  module, telling it to look in the module/Application/src/Application/  directory. Since the  Application\\Module \nclass is defined at the module root, we specify it in the  files  configuration.  To improve on this, and simplify autoloading, we recommend adopting a complete\nPSR-4 directory structure for your module class files. As an example, to change\nthe existing  Application  module to PSR-4, you can do the following:  $ cd module/Application\n$ mv src temp\n$ mv temp/Application src\n$ rm -Rf ./temp\n$ mv Module.php src/  Update your  Module.php  file to do the following:   Remove the  getAutoloaderConfig()  method entirely, if defined.  Update the  getConfig()  method from  include __DIR__ .\n  '/config/module.config.php  to  include _DIR__ .\n  '/../config/module.config.php .   You can then update the  autoload  configuration to:  \"autoload\": {\n    \"psr-4\": {\n        \"Application\\\\\": \"module/Application/src/\"\n    }\n}  Afterwards, run the following to update the generated autoloader:  $ composer dump-autoload  The updated application skeleton already takes this approach.",
            "title": "Autoloading"
        },
        {
            "location": "/migration/to-v3/application/#bootstrap",
            "text": "Because version 3 requires usage of Composer for autoloading, you can simplify\nyour application bootstrap.  First, if you were using an  init_autoloader.php  file, you can now remove it.  Second, update your  public/index.php  to read as follows:  <?php\n\nuse Zend\\Mvc\\Application;\n\n/**\n * This makes our life easier when dealing with paths. Everything is relative\n * to the application root now.\n */\nchdir(dirname(__DIR__));\n\n// Decline static file requests back to the PHP built-in webserver\nif (php_sapi_name() === 'cli-server') {\n    $path = realpath(__DIR__ . parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH));\n    if (__FILE__ !== $path && is_file($path)) {\n        return false;\n    }\n    unset($path);\n}\n\n// Composer autoloading\ninclude __DIR__ . '/../vendor/autoload.php';\n\nif (! class_exists(Application::class)) {\n    throw new RuntimeException(\n        \"Unable to load application.\\n\"\n        . \"- Type `composer install` if you are developing locally.\\n\"\n    );\n}\n\n// Run the application!\nApplication::init(require __DIR__ . '/../config/application.config.php')->run();",
            "title": "Bootstrap"
        },
        {
            "location": "/migration/to-v3/application/#scripts",
            "text": "The skeleton application for version 2 shipped three scripts with it:   bin/classmap_generator.php  bin/pluginmap_generator.php  bin/templatemap_generator.php   If you are upgrading an existing application, these will still be present.\nHowever, if you are starting a new application, and used these previously, they\nare no longer present.   classmap_generator.php  was removed as it's unnecessary when using Composer\n  for autoloading. When preparing a production installation, run  composer\n  dump-autoload -o  and/or  composer dump-autoload -a ; both will generate\n  optimized class map autoloading rules for you.  pluginmap_generator.php  was essentially obsolete due to the presence of\n   classmap_generator.php  anyways.  templatemap_generator.php  was moved to the zend-view component with the\n  2.8.0 release of that component, and is now available via\n   ./vendor/bin/templatemap_generator.php . Additionally, its usage signature\n  has changed; please use the  --help  or  -h  switches on first invocation to\n  discover how to use it.",
            "title": "Scripts"
        },
        {
            "location": "/migration/to-v3/application/#development-mode",
            "text": "Version 3 of the skeleton application adds a requirement on zfcampus/zf-development-mode ,\nwhich provides a way to store common development-specific settings in your\nrepository and then selectively enable/disable them during development.  If you are upgrading from an existing application, you can install this feature:  $ composer require zfcampus/zf-development-mode  Please refer to the  package documentation \nfor details on how to setup your application configuration to make use of this\nfeature.",
            "title": "Development mode"
        }
    ]
}